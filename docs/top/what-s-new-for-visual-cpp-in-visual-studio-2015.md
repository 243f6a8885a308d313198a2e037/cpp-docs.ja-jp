---
title: "Visual Studio 2015 における Visual C++ の新機能 | Microsoft Docs"
ms.custom: ""
ms.date: "12/16/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
ms.assetid: 1cc09fad-85a2-43c2-b022-bb99f5fe0ad7
caps.latest.revision: 101
caps.handback.revision: 101
author: "ghogen"
ms.author: "ghogen"
manager: "ghogen"
---
# Visual Studio 2015 における Visual C++ の新機能
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Visual Studio 2015 では、C\+\+ コンパイラと標準ライブラリが更新されました。C\+\+11 のサポートが強化され、一部の C\+\+14 機能が初めてサポートされました。  また、C\+\+17 規格に組み込まれる予定の機能の一部も予備的にサポートされています。  
  
 さらに、[Android および iOS](../Topic/Visual%20C++%20for%20Cross-Platform%20Mobile%20Development.md) 上でクロスプラットフォームのマルチ デバイス開発を行うためのプロジェクト テンプレートが追加され、[診断](#BK_Diagnostics)と[生産性](#BK_IDE)に関わるさまざまな機能が向上し、[ビルド時間](#BK_FasterBuildTimes)が大幅に向上しました。  
  
> [!WARNING]
>  Visual Studio 2015 では、既定で Visual C\+\+ がインストールされません。  インストール時に、**\[カスタム\]** インストールを選択してから、必要な C\+\+ コンポーネントを選択します。  または、Visual Studio が既にインストールされている状態で、**\[ファイル &#124;新規作成 &#124;プロジェクト &#124;C\+\+\]** を選択すると、必要なコンポーネントをインストールするように求められます。  
  
 Visual Studio 2015 のその他の追加機能について詳しくは、「[Visual Studio 2015 の新機能](../Topic/What's%20New%20in%20Visual%20Studio%202015.md)」を参照してください。  
  
 このトピックの内容  
  
1.  [コンパイラ](#BK_Compiler)  
  
2.  [C++ 標準ライブラリ](#BK_CppStdLib)  
  
3.  [C ランタイム ライブラリ](#BK_CRT)  
  
4.  [ビルドの高速化](#BK_FasterBuildTimes)  
  
5.  [パフォーマンスとコードの品質](#BK_PerfCodeQuality)  
  
6.  [生産性、デバッグ、および診断](#BK_IDE)  
  
    1.  [単一ファイルの IntelliSense](#BK_SingleFileIntelliSense)  
  
    2.  [リファクタリング](#BK_Refactoring)  
  
    3.  [プログラム データベースの機能強化](#BK_PDB)  
  
    4.  [診断](#BK_Diagnostics)  
  
7.  [Windows 10 をターゲットにする](#BK_Win10)  
  
8.  [グラフィックス診断](#BK_GraphicsDiagnostics)  
  
9. [新しい GPU Usage ツール](#BK_GPUUsage)  
  
10. [MFC の新機能](#BK_MFC)  
  
## ISO C\/C\+\+ 標準のサポート  
  
###  <a name="BK_Compiler"></a> コンパイラ  
  
-   **再開可能な関数 \(resume\/await\)**。resume および await キーワードにより、非同期プログラミングのサポートが言語レベルで提供され、再開可能な関数を使用できるようになりました。  現時点では、この機能はまだ実験的なものであり、x64 ターゲットでのみ使用可能です。  **\(C\+\+17 に対する提案 \[N3858\]\)**  
  
-   **ジェネリック \(ポリモーフィック\) ラムダ式**。ラムダ関数のパラメーターの型を auto を使用して指定できるようになりました。コンパイラはこのコンテキストの auto を、クロージャの関数呼び出し演算子がメンバー関数テンプレートであることを意味し、ラムダ式で auto が使用されているそれぞれの箇所が個々のテンプレート型パラメーターに対応することを意味すると解釈します。  **\(C\+\+14\)**  
  
-   **ラムダ キャプチャの式の一般化**。init キャプチャとも呼ばれます。  任意の式の結果を、ラムダのキャプチャ句内の変数に割り当てることができるようになりました。  これにより、移動専用の型を値によってキャプチャできるようになり、クロージャ オブジェクトに含まれる任意のデータ メンバーをラムダ式を使用して定義できるようになりました。  **\(C\+\+14\)**  
  
-   **2 進数リテラル**。2 進数リテラルがサポートされるようになりました。  このリテラルは、先頭が 0B または 0b で、0 および 1 の桁のみで構成されます。  **\(C\+\+14\)**  
  
-   **戻り値の型の推論**。通常の関数の戻り値の型を推論できるようになりました。これには、複数の return ステートメントのある関数や再帰関数も含まれます。  このような関数定義では、戻り値を後ろに置く関数定義の場合のように auto キーワードを先頭に置きますが、後ろに置く戻り値の型は省略します。  **\(C\+\+14\)**  
  
-   **decltype\(auto\)**。初期化式に auto キーワードを使用した型推論では、ref 修飾子と最上位レベルの cv 修飾子が式から取り除かれます。  decltype\(auto\) では、ref 修飾子と cv 修飾子が保持され、auto を使用できる任意の位置で使用できるようになりました。ただし、推論された戻り値の型を持つ関数、または戻り値の型を後ろに置いた関数の先頭は除きます。  **\(C\+\+14\)**  
  
-   **特殊メンバー関数 move の暗黙的な生成**。条件が許せば、move コンストラクターと move 代入演算子が暗黙的に生成されるようになりました。これにより、コンパイラは C\+\+11 の右辺値参照に完全に準拠しました。  **\(C\+\+11\)**  
  
-   **コンストラクターの継承**。派生クラスで基底クラス Base のコンストラクターを継承するように指定するために、その定義に Base::Base; を使用したステートメントを含めることができるようになりました。  派生クラスは、基底クラスのすべてのコンストラクターしか継承できません。特定の基底コンストラクターのみを継承する方法はありません。  複数の基底クラスに同じシグネチャを持つコンストラクターがある場合は、派生クラスはそれら複数の基底クラスから継承することはできません。また、継承されたコンストラクターのいずれかと同じシグネチャを持つコンストラクターを派生クラスで定義することもできません。  **\(C\+\+11\)**  
  
-   **アラインメントの照会と制御**。変数のアラインメントを照会するには alignof\(\) 演算子を使用し、アラインメントを制御するには alignas\(\) 指定子を使用します。  alignof\(\) は、型のインスタンスを揃える必要のあるバイト境界を返します。参照の場合は、参照された型のアラインメントを返します。配列の場合は、要素の型のアラインメントを返します。  alignas\(\) は、変数のアラインメントを制御します。定数または type を引数にとります。ここで、type は alignas\(alignof\(type\)\) の短縮形です。  **\(C\+\+11\)**  
  
-   **サイズ割り当て解除**。グローバル  `void operator delete(void *, std::size_t) noexcept` とグローバル `void operator delete[](void *, std::size_t) noexcept` をオーバーロードできるようになりました。  
  
-   **sizeof の拡張機能**。クラスまたは構造体のメンバー変数のサイズを、クラスまたは構造体のインスタンスなしで sizeof\(\) を使用して判別できるようになりました。**\(C\+\+11\)**  
  
-   **属性**。新しいキーワードを定義せずに関数、変数、型、およびその他のプログラム要素の構文を拡張する手段を提供します。**\(C\+\+11\)**  
  
-   **constexpr**。コンパイル時定数変数、関数、およびユーザー定義型を作成します。  **\(C\+\+11\)**  
  
-   **ユーザー定義リテラル \(UDL\)**。特定の意味を持たせるために、数値リテラルおよび文字列リテラルにサフィックスを追加できるようになりました。  コンパイラは、サフィックスの付いたリテラルを該当する UDL 演算子への呼び出しとして解釈します。  **\(C\+\+11\)**  
  
-   **スレッド セーフな "マジック" 静的変数**。静的ローカル変数は、スレッド セーフな方法で初期化されるようになったため、手動による同期の必要がなくなりました。  スレッド セーフであるのは初期化のみであるため、複数のスレッドで静的ローカル変数を使用する場合には、引き続き手動で同期する必要があります。  CRT の依存関係を避けるには、\/Zc:threadSafeInit\-フラグを使用してスレッド セーフな静的変数の機能を無効にできます。  **\(C\+\+11\)**  
  
-   **スレッド ローカル ストレージ**。thread\_local キーワードを使用すると、スレッドごとに独立したオブジェクトを作成する必要があることを宣言できます。  **\(C\+\+11\)**  
  
-   **noexcept**。noexcept 演算子を使用して、式が例外をスローする可能性があるかどうかを確認できるようになりました。  関数が例外をスローしないことを指定するには、noexcept 指定子を使用できます。  **\(C\+\+11\)**  
  
-   **インライン名前空間**。名前空間をインラインで指定し、その指定で囲まれた内容の名前空間を宣言できるようになりました。  インラインの名前空間を使用すると、既定では最新バージョンを公開しながら、明示的に指定すれば引き続き以前のバージョンの API を使用できるという、バージョン管理されたライブラリを作成できます。  **\(C\+\+11\)**  
  
-   **共用体の制限解除**。共用体型に、自明でないコンストラクターを持つ型を含められるようになりました。  このような共用体では、コンストラクターを定義する必要があります。  **\(C\+\+11\)**  
  
-   **新しい文字型と Unicode リテラル**。UTF\-8、UTF\-16、および UTF\-32 の文字リテラルと文字列リテラルがサポートされるようになり、新しい文字型として char16\_t と char32\_t が導入されました。  文字リテラルの先頭には u8 \(UTF\-8\)、u \(UTF\-16\)、または U \(UTF\-32\) を、U'a' のように指定します。また、文字列リテラルには、未加工文字列に相当するプレフィックとして u8R \(UTF\-8 未加工文字列\)、uR \(UTF\-16 未加工文字列\)、または UR \(UTF\-32 未加工文字列\) を追加します。  ユニバーサル文字名を Unicode リテラル内で自由に使用できます \(たとえば、u'\\u00EF'、u8"\\u00EF is i"、u"\\U000000ef is I" など\)。  **\(C\+\+11\)**  
  
-   **桁区切り記号**。長い数値リテラルを読みやすくするために、一定の間隔で単一引用符を挿入することができます。 `int x = 1'000'000;` **\(C\+\+ 14\)**。  
  
-   **\_\_func\_\_**。事前定義の識別子 \_\_func\_\_ は、外側の関数の非修飾かつ非装飾の名前を含む文字列として暗黙的に定義されます。  
  
-   **\_\_restrict\_\_**。restrict を参照に適用できるようになりました。  
  
###  <a name="BK_CppStdLib"></a> C\+\+ 標準ライブラリ  
  
-   **標準ライブラリ型のためのユーザー定義リテラル \(UDL\)**。利便性を高めるため、\<chrono\>、\<string\>、\<complex\> ヘッダーに UDL 演算子が組み込まれました。  たとえば、123ms は std::chrono::milliseconds\(123\) を、"hello"s は std::string\("hello"\) を、3.14i は std::complex\(0.0, 3.14\) を意味します。  
  
-   **Null 前方反復子**。標準ライブラリで、コンテナー インスタンスを参照しない前方反復子を作成できるようになりました。  このような反復子は値で初期化され、特定のコンテナー型との等価性が比較されます。  値で初期化される反復子と値で初期化されない反復子との比較は未定義です。  **\(C\+\+14\)**  
  
-   **quoted\(\)**。標準ライブラリで quoted\(\) 関数がサポートされるようになり、引用符で囲まれた文字列値の処理や入出力が容易になりました。  quoted\(\) では、引用符で囲まれた文字列全体が 1 つのエンティティとして \(入出力ストリーム上で空白以外の文字の文字列として\) 扱われます。また、入出力操作中にエスケープ シーケンスが保持されます。  **\(C\+\+14\)**  
  
-   **異種の連想ルックアップ**。標準ライブラリで連想コンテナーの異種 Lookup 関数がサポートされるようになりました。  この関数では、key\_type と比較可能な型である限り、key\_type 以外の型による参照を実行できます。  **\(C\+\+14\)**  
  
-   **コンパイル時の整数シーケンス**。標準ライブラリで integer\_sequence 型がサポートされるようになりました。これはコンパイル時に評価される整数値のシーケンスを表し、パラメーター パックの操作が簡単になり、一部のテンプレート プログラミング パターンが簡素化されます。  **\(C\+\+14\)**  
  
-   **exchange\(\)**。標準ライブラリで std::exchange\(\) ユーティリティ関数がサポートされるようになりました。この関数は、オブジェクトに新しい値を割り当て、古い値を返します。  複合型の場合、exchange\(\) は、move コンストラクターが使用可能な場合に古い値がコピーされることを防ぎ、新しい値が一時的であるかまたは移動される場合に新しい値がコピーされることを防ぎ、任意の変換代入演算子を利用して任意の型を新しい値として受け入れることができます。  **\(C\+\+14\)**  
  
-   **2 範囲の equal\(\)、is\_permutation\(\)、mismatch\(\)**。標準ライブラリで 2 つの範囲を受け入れる std::equal\(\)、std::is\_permutation\(\)、および std::mismatch\(\) のオーバーロードがサポートされるようになりました。  これらのオーバーロードにより、2 つのシーケンスが同じ長さであることが確認されるため、呼び出し元のコードでこの責任を果たす必要がなくなります。ランダムな反復子の要件をサポートしないシーケンスの場合、これらのオーバーロードは要素の比較時に長さを確認するため、処理の効率が上がります。  **\(C\+\+14\)**  
  
-   **get\<T\>\(\)**。標準ライブラリで、get\<T\>\(\) テンプレート関数がサポートされるようになり、タプル要素をその型によってアドレス指定できるようになりました。  タプルに同じ型の要素が複数含まれている場合、get\<T\>\(\) はその型によってアドレス指定できませんが、その他の固有の型の要素はアドレス指定できます。  **\(C\+\+14\)**  
  
-   **tuple\_element\_t**。標準ライブラリで tuple\_element\_t\<I, T\> 型エイリアスがサポートされるようになりました。これは、型名 tuple\_element\<I, T\>::type のエイリアスです。  これは、\<type\_traits\> のその他のメタ関数型エイリアスと同様に、テンプレート プログラマに利便性を提供します。  **\(C\+\+14\)**  
  
-   **File System "V3" Technical Specification**。含まれている File System Technical Specification の実装がバージョン 3 の仕様に更新されました。  \[N3940\]  
  
-   **最小アロケーター**。標準ライブラリで最小アロケーター インターフェイスが完全にサポートされるようになりました。主な修正点は、std::function、shared\_ptr、allocate\_shared\(\)、および basic\_string などです。  **\(C\+\+11\)**  
  
-   **\<chrono\>**。時系列型 high\_resolution\_clock および steady\_clock が修正されました。  **\(C\+\+11\)**  
  
-   **N2761 通知ハンドラー内のアトミック  \(C\+\+11\)**  
  
-   **N3922 かっこ付き初期化リストを持つ auto の新しい規則 \(C\+\+17\)**  
  
-   **N4051 テンプレートのテンプレート パラメーターの typename \(C\+\+17\)**  
  
-   **N4259 std::uncaught\_exceptions\(\)**  
  
-   **N4266 名前空間と列挙子の属性**  
  
-   **N4267 u8 文字リテラル**  
  
###  <a name="BK_CRT"></a> C ランタイム ライブラリ  
 **CRT ライブラリのリファクタリング**。CRT が 2 つの部分にリファクターされました。  **ユニバーサル CRT** には、標準の C ランタイム ライブラリを実装するコードが含まれています。  vcruntime140.dll \(または .lib\) には、プロセスの開始と例外処理に関するバージョン固有のコードが含まれています。  ユニバーサル CRT は、安定した API を備えているため、Visual Studio のリリースごとにバージョン番号を変更することなく使用できます。  これは、Windows Update によって提供される Windows オペレーティング システムのコンポーネントになりました。  Windows 10 には既にインストールされています。  Visual C\+\+ 再頒布可能パッケージ \(vcredist\) を使用して、以前のバージョンの Windows 用のアプリケーションと共に配布することができます。  
  
 **C99 への準拠**。[!INCLUDE[vs_dev14](../mfc/includes/vs_dev14_md.md)] は C99 標準ライブラリを完全に実装していますが、Visual C\+\+ コンパイラでまだサポートされていないコンパイラ機能に依存するライブラリ機能は除きます \(たとえば、\<tgmath.h\> は実装されていません\)。  
  
 **パフォーマンス**。ライブラリの大部分がリファクターされ、ヘッダー ファイル マクロの使用方法が効率化および簡素化されました。  これにより、コンパイルと IntelliSense が高速化され、読みやすさが向上します。  さらに、標準への準拠とパフォーマンス向上の両方を実現するため、多くの標準入出力関数が書き換えられました。  
  
### 互換性に影響する変更点  
 この ISO C\/C\+\+ 標準のサポート強化に伴って、既存のコードに変更を加える必要が生じる可能性があります。その結果、コードは C\+\+11 および C99 に準拠し、Visual Studio 2015 で正しくコンパイルできるようになります。  詳細については、「[Visual C\+\+ 2015 での互換性に影響する変更点](../Topic/Visual%20C++%20change%20history%202003%20-%2020151.md)」を参照してください。  
  
 ppltasks.h に含まれる concurrency::task クラスおよびそれに関連する型は、ConcRT ランタイムに基づくものではなくなりました。  現在は、スケジューラとして Windows のスレッド プールを使用します。  この変更点は、ConcRT 同期プリミティブを concurrency::task 操作の内側で使用しているコードにのみ影響を与えます。  このようなコードでは、代わりに Windows 同期プリミティブを使用する必要があります。  
  
 また、STL の同期プリミティブも ConcRT に基づくものではなくなりました。  デッドロックを回避するため、**concurrency::parallel\_for** などの関数の内側で、または PPL の非同期エージェント型と一緒に、STL 同期プリミティブは使用しないでください。  
  
##  <a name="BK_FasterBuildTimes"></a> ビルドの高速化  
  
-   **インクリメンタルなリンク時コード生成 \(LTCG\)**。インクリメンタル リンクを LTCG と一緒に使用できるようになり、LTCG を使用するアプリケーションのリンク時間が短縮されます。  この機能を有効にするには、\/LTCG:incremental および \/LTCG:incremental\_rebuild リンカー スイッチを使用します。  \\  
  
-   **静的ライブラリのインクリメンタル リンク**。他のコード モジュールによって参照されている静的ライブラリに対する変更が、インクリメンタルにリンクされるようになりました。  
  
-   **\/Debug:FastLink** では、新しい PDB 作成手法を使用することによりリンク時間が実質的に短縮されます。  
  
-   リンカーのアルゴリズムが改善されたため、リンク時間が短縮されました。  
  
-   テンプレートを大量に使用するコードのビルドを高速化するための改善が行われました。  
  
-   **ガイド付き最適化のプロファイル \(PGO\) のインストルメンテーションの高速化**。ゲームおよびリアルタイムのシステム用の新しい軽量のインストルメンテーション モードが PGO に導入されました。  \/GENPROFILE および \/FASTGETPROFILE リンカー スイッチによって使用可能になった他の新機能と組み合わせて使用することにより、PGO を使用する際にコードの品質とビルド速度のバランスを取ることができます。  
  
-   **オブジェクトのファイル サイズの縮小**。コンパイラと C\+\+ 標準ライブラリの機能強化により、オブジェクト ファイルと静的ライブラリが大幅に小さくなりました。  この機能強化は、動的リンク ライブラリ \(DLL\) や実行可能ファイル \(EXE\) のサイズには影響しません。冗長なコードはこれまでリンカーによって削除されていたためです。  
  
##  <a name="BK_PerfCodeQuality"></a> パフォーマンスとコードの品質  
  
-   **自動ベクター化の機能強化**。制御フロー \(if\-then\-else\) のベクター化、\/O1 でのコンパイル時のベクター化 \(サイズ最小化\)、およびベクター コード品質の全体的な改善 \(並列 STL のサポート、範囲ベースの for ループのベクター化の強化、\#pragma loop\(ivdep\) のサポートなど\) が組み込まれました。  
  
-   **スカラー最適化の機能強化**。ビット テスト演算のコード生成の改良、制御フローのマージと最適化 \(loop\-if スイッチ\)、およびその他のスカラー最適化 \(std::min および std::max のコード生成の改良など\) が行われました。  
  
-   **ガイド付き最適化のプロファイル \(PGO\)**。参照セットの強化、データ レイアウト機能の強化、以前に作成したインライン展開を再利用できる機能、速度  とサイズ、レイアウト決定など、多くの機能拡張が PGO に加えられました。  
  
##  <a name="BK_IDE"></a> 生産性、デバッグ、および診断  
  
###  <a name="BK_SingleFileIntelliSense"></a> 単一ファイルの IntelliSense  
 プロジェクト ファイルを開かないでも、エディターで 1 つのソース コード ファイルを開いた時に IntelliSense を利用できます。  
  
###  <a name="BK_Refactoring"></a> リファクタリング  
 C\+\+ のリファクタリングのサポートに次の機能が追加されました。  
  
-   **シンボルの名前変更**。シンボルのすべての出現箇所を新しい名前に変更します。  
  
-   **関数の抽出**。選択したコードを独自の関数に移動します。  このリファクタリングは、Visual Studio ギャラリーで Visual Studio の拡張機能として入手できます。  
  
-   **純粋仮想関数の実装**。クラスまたは構造体によって継承される純粋仮想関数の関数定義を生成します。  複数および再帰的な継承がサポートされます。  このリファクタリングは、継承しているクラス定義からアクティブ化して、継承されるすべての純粋仮想関数を実装するか、または基底クラスの指定子からアクティブ化して、その基底クラスからの純粋仮想関数のみを実装します。  
  
-   **宣言または定義の作成**。既存の定義から宣言を生成するか、または既存の宣言から既定の定義を生成します。  このリファクタリングへは、既存の宣言または定義から、あるいは電球のインジケーターからアクセスします。  
  
-   **関数定義の移動**。関数の本体をソース コード ファイルとヘッダー ファイルの間で移動します。  このリファクタリングは、関数のシグネチャからアクティブ化します。  
  
-   **未加工の文字列リテラルへの変換**。エスケープ シーケンスを格納している文字列を未加工の文字列リテラルに変換します。  サポートされているエスケープ シーケンスは、\\\\ \(円記号\)、\\n \(改行\)、\\t \(タブ\)、\\' \(単一引用符\)、\\" \(二重引用符\)、および \\? です。  \(疑問符\) に設定します。  この機能をアクティブ化するには、文字列内の任意の場所を右クリックします。  
  
 \[フォルダーを指定して検索\] が機能強化され、後続の検索結果を前の検索結果に追加できるようになり、累積された結果を削除できるようになりました。  
  
 **IntelliSense の読みやすさの向上**。パラメーターのヘルプとクイックヒントで、複雑なテンプレートのインスタンス化と typedef が簡素化され、読みやすくなりました。  
  
###  <a name="BK_PDB"></a> プログラム データベースの機能強化  
  
-   ソリューション \(特に大規模なソリューション\) のスキャンの速度が向上しました。  
  
-   \[定義へ移動\] などの操作が、ソリューションのスキャン中にブロックされなくなりました。ただし、新しいソリューションを初めて開いたときの初期ソリューション スキャンの実行中は除きます。  
  
##  <a name="BK_Diagnostics"></a> 診断  
  
1.  **デバッガーの視覚化機能**。Visual Studio プロジェクトに Natvis デバッガー視覚化機能が追加され、管理とソース制御の統合が容易になりました。  デバッグ セッション中に Natvis ファイルの編集と保存が可能になり、デバッガーはその変更内容を自動的に取得します。  詳細については、この[ブログ投稿](http://blogs.msdn.com/b/vcblog/archive/2014/06/12/project-support-for-natvis.aspx)を参照してください。  
  
2.  **ネイティブ メモリ診断**  
  
    1.  **メモリ診断セッション** \(Ctrl\+Alt\+F2\)。ネイティブ アプリケーションのメモリ使用をデバッグ セッション中にリアルタイムで監視できます。  
  
    2.  **メモリのスナップショット**。アプリケーションのヒープ内容の瞬間的なイメージをキャプチャします。  2 つのメモリ スナップショットを比較すると、ヒープの状態の違いを調べることができます。  アプリケーションを停止した後の各インスタンスのオブジェクト型、インスタンス値、および割り当て呼び出しスタックが表示されます。  各スナップショットの呼び出しツリーがスタック フレームごとに表示されます。  
  
3.  **デッドロックの検出と回復の強化**。\[ウォッチ\] ウィンドウおよび \[イミディエイト\] ウィンドウから C\+\+ の関数を呼び出したときのデッドロックの検出と回復が強化されました。  
  
4.  **コンパイラの診断の強化**。疑わしいコードについてコンパイラが提示する警告が拡張されました。  また、新しい警告が追加されました \(シャドウされた変数や、printf の書式指定文字列の不一致など\)。  既存の警告メッセージがより明確になりました。  
  
5.  **\/Wv フラグ**。特定のコンパイラ バージョン XX.YY.ZZZZ より後に導入された警告を無効にできるようになりました。無効にするには、\/Wv:XX.YY.ZZZZ フラグを使用します。  \/Wv フラグを使用して指定される警告に加えて、その他の特定の警告を無効にすることができます。  
  
6.  **最適化コードのデバッグのサポート強化**。\/Zi、\/Zo、または\/Z7 フラグを有効にすると、コードがデバッグされるようになりました。  
  
##  <a name="BK_Win10"></a> Windows 10 をターゲットにする  
 Visual Studio は、C\+\+ で Windows 10 をターゲットに指定できるようになりました。  ユニバーサル Windows アプリの新しいプロジェクト テンプレートは、デスクトップ コンピューター、携帯電話、タブレット、HoloLens などの Windows 10 デバイスをターゲットに指定できるようになりました。  詳細については、「[C\+\+ を使った "hello world" アプリの作成 \(Windows 10\)](https://msdn.microsoft.com/en-us/library/windows/apps/dn996906.aspx)」を参照してください。  
  
##  <a name="BK_GraphicsDiagnostics"></a> グラフィックス診断  
 グラフィックス診断が次の機能により強化されました。  
  
-   **DirectX12 向けのグラフィックス診断のサポート**。 Visual Studio のグラフィックス診断ツールで、DirectX12 アプリケーションのレンダリングの問題のデバッグがサポートされるようになりました。  
  
-   **連続キャプチャ**。1 つのキャプチャで最大 30 までの連続フレームをキャプチャできます。  
  
-   **プログラムによるキャプチャ**。フレームのキャプチャをプログラムから開始できます。  プログラムによるキャプチャが特に便利になるのは、Present を呼び出すことがないプログラムで計算シェーダーをデバッグする場合や、レンダリングの問題を手動でキャプチャすることが難しいものの、実行時にアプリの状態からプログラムによって予測できる場合などです。  
  
-   **グラフィックス イベント一覧の機能拡張**。新しい \[描画呼び出し\] ビューが追加されました。キャプチャしたイベントとその状態が、描画呼び出しに基づいて編成された階層で表示されます。  描画呼び出しを展開すると、描画呼び出しの時点で最新のデバイスの状態が表示されます。それぞれの状態の種類を展開すると、それらの状態に値を設定したイベントが表示されます。  
  
-   **Windows Phone 8.1 のサポート**。グラフィックス診断で、Phone エミュレーターまたはテザリングされた Phone での Windows Phone 8.1 アプリのデバッグが完全にサポートされるようになりました。  
  
-   **グラフィックス フレーム分析**。このツールは、キャプチャされたフレームに関するパフォーマンス測定値を収集します。また、さまざまなテクスチャ テクニックを適用した場合のパフォーマンスに対する影響を洞察するための情報を提供する、一連の事前定義の実験も実行します。  フレーム分析では、ハードウェアからパフォーマンス カウンタも収集します。  
  
-   **グラフィックス分析の専用 UI**。新しい Visual Studio Graphics Analyzer のウィンドウは、グラフィックス フレーム分析専用のワークスペースです。  
  
-   **シェーダーの編集と適用**。アプリを再実行することなく、キャプチャしたログでシェーダー コードの変更の影響を表示できます。  
  
-   \[ツール\] \-\>\[オプション\] \-\>\[グラフィック診断\] でキャプチャ オプションを設定します。  
  
-   フレームをキャプチャして再生するためのコマンド ライン ツールです。  
  
 詳細については、「[グラフィックス診断 \(DirectX グラフィックスのデバッグ\)](../Topic/Visual%20Studio%20Graphics%20Diagnostics.md)」を参照してください。  
  
##  <a name="BK_GPUUsage"></a> 新しい GPU Usage ツール  
 Visual Studio 2015 の GPU Usage ツールを使用すると、DirectX アプリケーションの GPU 使用状況を把握できます。  アプリケーションの実行中にリアルタイムで、フレーム時間、フレーム レート、および GPU 使用状況のグラフを利用できます。  また、このツールは詳細な GPU 使用状況データを収集して分析することで、個々の DirectX イベントの CPU および GPU 実行時間に関する洞察を提供します。したがって、CPU または GPU がパフォーマンスのボトルネックとなっているかどうかを判断する際に役立ちます。  「[GPU 使用率](../Topic/GPU%20Usage.md)」を参照してください。  
  
##  <a name="BK_MFC"></a> MFC の新機能  
 ユーザーがダイアログ ボックスのサイズを変更したときに、コントロールのサイズと位置の変更を自動制御する方法を指定できるようになりました。  詳細については、「[動的レイアウト](../mfc/dynamic-layout.md)」を参照してください。  
  
## 参照  
 [Visual Studio 2015 の新機能](../Topic/What's%20New%20in%20Visual%20Studio%202015.md)   
 [Visual C\+\+ チーム ブログ](http://blogs.msdn.com/b/vcblog/)