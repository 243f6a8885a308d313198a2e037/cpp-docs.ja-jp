---
title: "テクニカル ノート 22: 標準コマンドの実装 | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "vc.commands"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "コマンド, 標準"
  - "ID_APP_ABOUT コマンド"
  - "ID_APP_EXIT コマンド"
  - "ID_CONTEXT_HELP コマンド"
  - "ID_DEFAULT_HELP コマンド"
  - "ID_EDIT_CLEAR コマンド"
  - "ID_EDIT_CLEAR_ALL コマンド"
  - "ID_EDIT_COPY コマンド"
  - "ID_EDIT_CUT コマンド"
  - "ID_EDIT_FIND コマンド"
  - "ID_EDIT_PASTE コマンド"
  - "ID_EDIT_PASTE_LINK コマンド"
  - "ID_EDIT_PASTE_SPECIAL コマンド"
  - "ID_EDIT_REDO コマンド"
  - "ID_EDIT_REPEAT コマンド"
  - "ID_EDIT_REPLACE コマンド"
  - "ID_EDIT_SELECT_ALL コマンド"
  - "ID_EDIT_UNDO コマンド"
  - "ID_FILE_CLOSE コマンド"
  - "ID_FILE_NEW コマンド"
  - "ID_FILE_OPEN コマンド"
  - "ID_FILE_PAGE_SETUP コマンド"
  - "ID_FILE_PRINT コマンド"
  - "ID_FILE_PRINT_PREVIEW コマンド"
  - "ID_FILE_PRINT_SETUP コマンド"
  - "ID_FILE_SAVE コマンド"
  - "ID_FILE_SAVE_AS コマンド"
  - "ID_FILE_SAVE_COPY_AS コマンド"
  - "ID_FILE_UPDATE コマンド"
  - "ID_HELP コマンド"
  - "ID_HELP_INDEX コマンド"
  - "ID_HELP_USING コマンド"
  - "ID_INDICATOR_CAPS コマンド"
  - "ID_INDICATOR_EXT コマンド"
  - "ID_INDICATOR_KANA コマンド"
  - "ID_INDICATOR_NUM コマンド"
  - "ID_INDICATOR_OVR コマンド"
  - "ID_INDICATOR_REC コマンド"
  - "ID_INDICATOR_SCRL コマンド"
  - "ID_NEXT_PANE コマンド"
  - "ID_OLE_EDIT_LINKS コマンド"
  - "ID_OLE_INSERT_NEW コマンド"
  - "ID_OLE_VERB_FIRST コマンド"
  - "ID_PREV_PANE コマンド"
  - "ID_VIEW_STATUS_BAR コマンド"
  - "ID_VIEW_TOOLBAR コマンド"
  - "ID_WINDOW_ARRANGE コマンド"
  - "ID_WINDOW_CASCADE コマンド"
  - "ID_WINDOW_NEW コマンド"
  - "ID_WINDOW_SPLIT コマンド"
  - "ID_WINDOW_TILE_HORZ コマンド"
  - "ID_WINDOW_TILE_VERT コマンド"
  - "標準コマンド"
  - "TN022"
ms.assetid: a7883b46-23f7-4870-ac3a-804aed9258b5
caps.latest.revision: 10
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
caps.handback.revision: 6
---
# テクニカル ノート 22: 標準コマンドの実装
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

> [!NOTE]
>  次のテクニカル ノートは、最初にオンライン ドキュメントの一部とされてから更新されていません。  結果として、一部のプロシージャおよびトピックが最新でないか、不正になります。  最新の情報について、オンライン ドキュメントのキーワードで関係のあるトピックを検索することをお勧めします。  
  
 ここでは、MFC 2.0 に用意されている標準コマンド実装について説明します。  標準コマンドの多くを実装するために使用される機能を説明するため [テクニカル ノート 21](../mfc/tn021-command-and-message-routing.md) を最初に確認します。  
  
 この説明は、MFC アーキテクチャ、API と共通のプログラミング手法に関する知識があると仮定しています。  文書化された、非公開のな「実装」API について説明します。  これは、MFC のプログラミング方法を機能の学習を開始する場所またはではありません。  一般情報が記載された API の詳細については、" Visual C\+\+ "を参照してください。  
  
## 問題  
 MFC ヘッダー ファイルは、AFXRES.H.の多くの標準コマンド ID を定義します。  これらのコマンドのフレームワークのサポートは異なります。  これらのコマンドをフレームワーク クラスが処理する場所とを理解することができるだけでなく、フレームワークを内部的に作業が、または方法で有用な情報が標準実装をカスタマイズし、独自のコマンド ハンドラーを実装するための手法を教える提供しますか。  
  
## このテクニカル ノートの内容  
 各コマンド ID が 2 のセクションで説明します。:  
  
-   タイトル: コロンで区切られたコマンドの用途に \(たとえば、「現在のドキュメントを保存\) は、コマンド ID のシンボル名 \(たとえば、**ID\_FILE\_SAVE**\)。  
  
-   どのクラスのコマンドを実装し、ことを既定の実装が何を行っているかを示す一つ以上の段落  
  
 ほとんどの既定のコマンドの実装は、.NET Framework の基本クラスのメッセージ マップに事前設定されます。  派生クラスで明示的に接続を必要なコマンド実装があります。  これらは、「メモ」で説明されています。  AppWizard の右側のオプションを選択した場合は、これらの既定のハンドラーは、生成されたスケルトン アプリケーションに自動的に接続されます。  
  
## 名前付け規約  
 標準のコマンドは、可能であれば使用推奨する、単純な名前付け規則に従います。  ほとんどの標準コマンドは、アプリケーションのメニュー バーの標準の場所にあります。  コマンドのシンボル名はメニュー項目名を続ける標準ポップアップ メニュー名の先頭に「ID\_」から開始します。  シンボル名にアンダースコアの単語と中断の大文字にします。  標準メニュー項目の名前を持たないコマンドに対して、論理的なコマンド名は「ID\_」で定義された開始 \(たとえば、**ID\_NEXT\_PANE**\) です。  
  
 これは、メニュー項目、ツール バー ボタン、または他のコマンド ユーザー インターフェイス オブジェクトにバインドされるようにように設計されたコマンドを表示するには、「ID\_」を使用します。  「ID\_」コマンドを処理しているコマンド ハンドラーは `ON_COMMAND` を使用し、MFC の `ON_UPDATE_COMMAND_UI` の機能は、アーキテクチャを表示します。  
  
 これはコマンド アーキテクチャに定義し、メニュー固有のコードをそれを有効にし、無効にする必要なくメニュー項目に使用する標準「IDM\_」プレフィックスをお勧めします。  この特定のコマンドがだけでなく、MFC コマンド アーキテクチャに従うことから小さい必要のあるメニューの数は、コマンド ハンドラーをより強力に \(ツール バーを使用すると、ある\) コマンド ハンドラー コードを再利用できます。  
  
## ID の範囲  
 MFC の ID の範囲の使用の詳細については [テクニカル ノート 20](../mfc/tn020-id-naming-and-numbering-conventions.md) を参照してください。  
  
 MFC の標準コマンドは範囲 ~ に 0xEFFF となります。  これらのライブラリの将来のバージョンで変更されることがあるため、これらの ID を特定の値に依存しないでください。  
  
 アプリケーションは、範囲 0x8000 に 0xDFFF のコマンドを定義する必要があります。  
  
## 標準コマンド ID  
 各コマンド ID で、ファイル PROMPTS.RC で使用できる標準メッセージ行のプロンプト文字列があります。  そのメニュー プロンプトの文字列 ID がコマンド ID のと同じである必要があります。  
  
-   ID\_FILE\_NEW は新しいの作成\/ドキュメントを確保できます。  
  
    > [!NOTE]
    >  `CWinApp`に\-この機能を有効にするには、派生クラスでこのメッセージ マップを接続する必要があります。  
  
     `CWinApp::OnFileNew` は アプリケーションのドキュメント テンプレートの数によってこのコマンドを異なる方法で実装します。  `CDocTemplate`が 1 だけの場合、`CWinApp::OnFileNew` はその型の新しいドキュメント、適切なフレームおよびビュー クラスを作成します。  
  
     複数の `CDocTemplate`がある場合は、`CWinApp::OnFileNew` は選択を使用するドキュメント型、するダイアログ \(**AFX\_IDD\_NEWTYPEDLG**\) を持つユーザーに確認します。  指定 `CDocTemplate` がドキュメントを作成するために使用されます。  
  
     `ID_FILE_NEW` 1 の共通のカスタマイズでは、ドキュメントの種類別にグラフィカルな選択を提供することです。  この場合、独自の **CMyApp::OnFileNew** を実装し、メッセージ マップに `CWinApp::OnFileNew`の代わりに配置できます。  基本クラスの実装を呼び出す必要はありません。  
  
     `ID_FILE_NEW` のもう一つの一般的なカスタマイズは、各種類のドキュメントを作成するために別のコマンドを提供します。  この場合、新しいコマンド ID \(ID\_FILE\_NEW\_CHART と ID\_FILE\_NEW\_SHEET を定義する必要があります。  
  
-   ID\_FILE\_OPEN は、既存のドキュメントを開きます。  
  
    > [!NOTE]
    >  `CWinApp`に\-この機能を有効にするには、派生クラスでこのメッセージ マップを接続する必要があります。  
  
     `CWinApp::OnFileOpen` に **CWinApp::DoPromptFileName** を開くに `CWinApp::OpenDocumentFile` ファイルとが従うして呼び出すことの簡単な実装をファイルのパス名大幅に異なります。  `CWinApp` 実装の定期的な **DoPromptFileName** は現在のドキュメント テンプレートから取得されるファイル拡張子を持つ FileOpen の標準ダイアログと塗りが持ち出します。  
  
     `ID_FILE_OPEN` 1 の共通のカスタマイズは、FileOpen ダイアログをカスタマイズまたは追加ファイル フィルターを追加します。  これをカスタマイズする方法は文書ファイルまたはパス名で FileOpen 独自のダイアログと呼び出し `CWinApp::OpenDocumentFile` と既定の実装を置き換えることです。  基本クラスを呼び出す必要はありません。  
  
-   ID\_FILE\_CLOSE は、現在開いているドキュメントを閉じます。  
  
     **CDocument::OnFileClose** は 変更された呼び出して `OnCloseDocument`を呼び出して、ユーザーがドキュメントを保存するよう促すように `CDocument::SaveModified` を。  ドキュメントの破棄を含むすべての最後のロジックは、`OnCloseDocument` ルーチンで実行されます。  
  
    > [!NOTE]
    >  個別に**ID\_FILE\_CLOSE** 行為ドキュメント フレーム ウィンドウに送信されます `WM_CLOSE` メッセージまたは **SC\_CLOSE** のシステム コマンドです。  ウィンドウを閉じるには、ドキュメントを示す最後のフレーム ウィンドウである場合にのみドキュメントを閉じます。  **ID\_FILE\_CLOSE** のドキュメントを閉じると、だけでなく、ドキュメントは閉じますが、ドキュメントを参照するすべてのフレーム ウィンドウを閉じます。  
  
-   ID\_FILE\_SAVE は現在のドキュメントが保存されます。  
  
     実装は **OnFileSave** と **OnFileSaveAs**の両方で使用されるヘルパー ルーチン **CDocument::DoSave** を使用します。  FileNew のように、保存されなかったまたは読み取りドキュメントから読み取られたドキュメントを、つまりがパス名を格納する場合に、**OnFileSave** ロジックが **ID\_FILE\_SAVE\_AS** コマンドと同様に機能し、ユーザーが新しいファイル名を指定するように要求します。  ファイルを開き、保存を実行する実際のプロセスは仮想関数 `OnSaveDocument`によって実行されます。  
  
     **ID\_FILE\_SAVE**をカスタマイズするには、2 種類の一般的な理由があります。  ドキュメントを保存せずに、ユーザー インターフェイスから **ID\_FILE\_SAVE** のメニュー項目やツール バー ボタンを削除します。  また、変更された状態で文書 \(つまり、`CDocument::SetModifiedFlag`\) を呼び出さないことを確認し、フレームワークでは、文書が保存されることはありません。  ディスク ファイル以外の場所に格納するドキュメントについては、その操作の新しいコマンドを定義します。  
  
     `COleServerDoc`の場合、ファイルが格納 **ID\_FILE\_SAVE** \(通常のドキュメント用\) とファイルの更新の両方に使用されます \(埋め込まれたなドキュメントの場合\)。  
  
     ドキュメント データが個別のディスク ファイルに格納して、既定の **CDocument** のシリアル化するの実装を使用しない場合 **OnFileSave**の代わりに `CDocument::OnSaveDocument` をオーバーライドする必要があります。  
  
-   ID\_FILE\_SAVE\_AS は別のファイル名で現在のドキュメントが保存されます。  
  
     **CDocument::OnFileSaveAs** の実装は **OnFileSave**と同じ **CDocument::DoSave** のヘルパー ルーチンを使用します。  **OnFileSaveAs** コマンドは **ID\_FILE\_SAVE** でドキュメントを保存する前にファイル名がない場合は、処理されます。  **COleServerDoc::OnFileSaveAs** は 通常のドキュメント データ ファイルを保存する、または別のファイルとして他のアプリケーションに埋め込まれた OLE オブジェクトを表すサーバー ドキュメントを格納するためのロジックを実装します。  
  
     **ID\_FILE\_SAVE**ロジックをカスタマイズする場合は」、ドキュメントに適用する可能性がなくなるように、**ID\_FILE\_SAVE\_AS** または「保存操作と同様にカスタマイズする必要があります。  必要な場合を除き、メニューバーからメニュー項目を削除できます。  
  
-   ID\_FILE\_SAVE\_COPY\_AS、新しい名前でコピー \(現在のドキュメントが保存されます。  
  
     **COleServerDoc::OnFileSaveCopyAs** の実装は **CDocument::OnFileSaveAs**とよく似ていますが、基になるファイルへのドキュメント オブジェクトは保存の後に「アタッチされていません」。  保存、まだ「変更済み」の前に、つまり、インメモリ ドキュメントが「変更されて」。  また、このコマンドは、文書内のパス名またはタイトルには影響しません。  
  
-   ID\_FILE\_UPDATE は埋め込まれたなドキュメントを格納するためのコンテナーに通知します。  
  
     埋め込むことが保存することだけで `COleServerDoc::OnUpdateDocument` の実装の notifiies コンテナー。  コンテナーは、埋め込みオブジェクトを格納するために適した OLE API を呼び出します。  
  
-   ID\_FILE\_PAGE\_SETUP はアプリケーション固有のページ設定ダイアログとレイアウトを呼び出します。  
  
     現在このダイアログの標準を持たず、フレームワークでこのコマンドの既定の実装がありません。  
  
     このコマンドを実装する場合は、使用するこのコマンド ID をお勧めします。  
  
-   ID\_FILE\_PRINT\_SETUP は標準の印刷設定ダイアログを呼び出します。  
  
    > [!NOTE]
    >  `CWinApp`に\-この機能を有効にするには、派生クラスでこのメッセージ マップを接続する必要があります。  
  
     このコマンドにより、ユーザーがこのアプリケーションの少なくともこの最大ですべてのドキュメントのプリンターや印刷設定をカスタマイズできる標準の印刷設定ダイアログを呼び出します。  システム全体の既定のプリンター設定を変更するには、コントロール パネルを使用する必要があります。  
  
     `CWinApp::OnFilePrintSetup` に `CPrintDialog` オブジェクトを作成し、**CWinApp::DoPrintDialog** の実装の関数を呼び出す簡単な実装がほとんどありません。  これは、アプリケーションの既定のプリンター設定を設定します。  
  
     このコマンドをカスタマイズするための共通のニーズによって格納時にドキュメントに格納される、ドキュメントのプリンター設定を有効にします。  これを行うには、**CPrintDialog::DoModal,** を呼び出し、変更されたプリンター設定を `CPrintDialog` オブジェクトを作成し、適切なプリンター属性で \(通常 **hDevMode** と **hDevNames**\) 初期化する **CDocument** クラスのメッセージ ハンドラーを追加する必要がある保存します。  厳密な実装では、順序がある既定のシステムで処理とプリンターの変更を追跡するエラーと **CWinApp::UpdatePrinterSelection** を検出するに **CWinApp::DoPrintDialog** の実装のようになります。  
  
-   現在のドキュメントの ID\_FILE\_PRINT の標準の印刷  
  
    > [!NOTE]
    >  `CView`に\-この機能を有効にするには、派生クラスでこのメッセージ マップを接続する必要があります。  
  
     このコマンドは、現在のドキュメント、または、開始印刷エンジン標準印刷ダイアログと実行を呼び出すと、印刷プロセスより正しく印刷します。  
  
     **CView::OnFilePrint** は このコマンドと主要な印刷ループを実装します。  これは、印刷ダイアログでユーザーが確認する仮想 `CView::OnPreparePrinting` を呼び出します。  これは、プリンターにプリンターに進むにおいて、印刷の進行状況ダイアログ**AFX\_IDD\_PRINTDLG** \(\)、および送信を `StartDoc` のエスケープ DC を出力する準備をします。  **CView::OnFilePrint** は、メイン ページ指向の印刷ループが含まれています。  ページごとに、仮想 `CView::OnPrepareDC` を `StartPage` のエスケープ、そのページの仮想 `CView::OnPrint` を呼び出してはさんでから呼び出します。  完了すると、仮想 `CView::OnEndPrinting` が呼び出され、印刷の進行状況ダイアログ ボックスが閉じます。  
  
     MFC の印刷アーキテクチャは、印刷と印刷プレビューのさまざまな方法でフックするように設計されています。  通常 `CView` のさまざまなオーバーライドできるな関数を各ページの印刷指向タスクに対して十分で検索します。  アプリケーションの場合にのみ使用する非ページのプリンターを使用 **ID\_FILE\_PRINT** の実装を置き換える必要が見つかった場合、出力をづけました方向。  
  
-   ID\_FILE\_PRINT\_PREVIEW によっては現在のドキュメントを印刷プレビュー モードになります。  
  
    > [!NOTE]
    >  `CView`に\-この機能を有効にするには、派生クラスでこのメッセージ マップを接続する必要があります。  
  
     **CView::OnFilePrintPreview** は 文書化されているヘルパー関数 **CView::DoPrintPreview**を呼び出して印刷プレビュー モードを開始します。  **CView::DoPrintPreview** は、**OnFilePrint** が印刷ループのメイン エンジンであるため、印刷プレビューのループのメイン エンジンです。  
  
     印刷プレビュー操作はさまざまな方法で **DoPrintPreview**にパラメーターを渡すことによってカスタマイズできます。  [テクニカル ノート 30](../mfc/tn030-customizing-printing-and-print-preview.md)を参照し、印刷プレビューの詳細の一部とコントロールをカスタマイズする方法を検討できます。  
  
-   MRU ファイル `list`のコマンド ID の**ID\_FILE\_MRU\_FILE1**…**FILE16** A の範囲。  
  
     **CWinApp::OnUpdateRecentFileMenu** は `ON_UPDATE_COMMAND_UI` の機能の詳しい使い方の 1 人である Update コマンド UI ハンドラーです。  メニュー リソースの ID **ID\_FILE\_MRU\_FILE1**を含む一つのメニュー項目を定義するだけです。  メニュー項目が最初になること無効になりました。  
  
     MRU リストが増大したときに、より多くのメニュー項目が一覧に追加されます。  `CWinApp` の標準実装は 4 回使用されたファイルの標準制限に最後になります。  よりも大きいか小さい値を持つ `CWinApp::LoadStdProfileSettings` を呼び出して既定を変更できます。  MRU リストはアプリケーションの .INI ファイルに格納されます。  一覧に、アプリケーションの `InitInstance` 関数で `LoadStdProfileSettings`を呼び出す読み込まれ、アプリケーション終了時に格納されます。  MRU Update コマンド UI ハンドラーは、ファイル メニューの表示の相対パス、絶対パスに変換します。  
  
     **CWinApp::OnOpenRecentFile** は 実際のコマンドを実行する `ON_COMMAND` ハンドラーです。  これはファイルを開き、MRU リストを更新するためのすべての作業を行う MRU リストからファイル名を取得し、`CWinApp::OpenDocumentFile`を呼び出します。  
  
     このコマンド ハンドラーのカスタマイズはお勧めしません。  
  
-   ID\_EDIT\_CLEAR、現在の選択をクリアします。  
  
     現在、このコマンドの標準の実装がありません。  各 `CView`ではこれを\-派生クラス実装しなければなりません。  
  
     `CEditView` は `CEdit::Clear`を使用してこのコマンドの実装を提供します。  コマンドは、現在の選択範囲に含まれて無効になります。  
  
     このコマンドを実装する場合は、使用するこのコマンド ID をお勧めします。  
  
-   ID\_EDIT\_CLEAR\_ALL は文書全体を削除します。  
  
     現在、このコマンドの標準の実装がありません。  各 `CView`ではこれを\-派生クラス実装しなければなりません。  
  
     このコマンドを実装する場合は、使用するこのコマンド ID をお勧めします。  MFC の実装例については、"チュートリアル [Scribble](../top/visual-cpp-samples.md) サンプルを参照してください。  
  
-   ID\_EDIT\_COPY はクリップボードに現在の選択をコピーします。  
  
     現在、このコマンドの標準の実装がありません。  各 `CView`ではこれを\-派生クラス実装しなければなりません。  
  
     `CEditView` は `CEdit::Copy`を使用して CF\_TEXT として選択したテキストをクリップボードにコピーする現在このコマンドの実装を提供します。  コマンドは、現在の選択範囲に含まれて無効になります。  
  
     このコマンドを実装する場合は、使用するこのコマンド ID をお勧めします。  
  
-   ID\_EDIT\_CUT はクリップボードに現在の選択を切り取ります。  
  
     現在、このコマンドの標準の実装がありません。  各 `CView`ではこれを\-派生クラス実装しなければなりません。  
  
     `CEditView` は `CEdit::Cut`を使用して CF\_TEXT として選択したテキストをクリップボードに現在クリッピングこのコマンドの実装を提供します。  コマンドは、現在の選択範囲に含まれて無効になります。  
  
     このコマンドを実装する場合は、使用するこのコマンド ID をお勧めします。  
  
-   ID\_EDIT\_FIND は、検索操作を、持ち出しますモードレス ダイアログの検索を開始します。  
  
     現在、このコマンドの標準の実装がありません。  各 `CView`ではこれを\-派生クラス実装しなければなりません。  
  
     `CEditView` では、実装のヘルパー関数 **OnEditFindReplace** を呼び出し、以前の検索を保存するには、プライベートな実装の変数設定を置き換えます。このコマンドの実装を提供します。  `CFindReplaceDialog` クラスをユーザーに求めるためのモードレス ダイアログ ボックスを管理するために使用されます。  
  
     このコマンドを実装する場合は、使用するこのコマンド ID をお勧めします。  
  
-   ID\_EDIT\_PASTE は現在のクリップボードの内容を挿入します。  
  
     現在、このコマンドの標準の実装がありません。  各 `CView`ではこれを\-派生クラス実装しなければなりません。  
  
     `CEditView` は `CEdit::Paste`を使用して、選択したテキストを置換する現在のクリップボード データをコピーする場合は、このコマンドの実装を提供します。  コマンドがクリップボードに **CF\_TEXT** がある無効になります。  
  
     **COleClientDoc** は このコマンドに対する更新コマンド UI ハンドラーを提供します。  クリップボードは埋め込みできの OLE アイテムとオブジェクトがない場合、コマンドは無効になります。  実際に貼り付けることができる実際のコマンドのハンドラーを作成する必要があります。  OLE アプリケーションが他の形式を貼り付けることができるビューまたはドキュメントの UI 更新コマンド ハンドラーを用意する必要があります \(つまり、場所をコマンドの対象のルーティングの **COleClientDoc** の前に\)。  
  
     このコマンドを実装する場合は、使用するこのコマンド ID をお勧めします。  
  
     標準 OLE 実装を置き換えるには、`COleClientItem::CanPaste`を使用します。  
  
-   ID\_EDIT\_PASTE\_LINK は現在のクリップボードの内容でリンクを挿入します。  
  
     現在、このコマンドの標準の実装がありません。  各 `CView`ではこれを\-派生クラス実装しなければなりません。  
  
     `COleDocument` は このコマンドに対する更新コマンド UI ハンドラーを提供します。  クリップボードを連結可能 OLE アイテムとオブジェクトがない場合、コマンドは無効になります。  実際に貼り付けることができる実際のコマンドのハンドラーを作成する必要があります。  OLE アプリケーションが他の形式を貼り付けることができるビューまたはドキュメントの UI 更新コマンド ハンドラーを用意する必要があります \(つまり、場所をコマンドの対象のルーティングの `COleDocument` の前に\)。  
  
     このコマンドを実装する場合は、使用するこのコマンド ID をお勧めします。  
  
     標準 OLE 実装を置き換えるには、`COleClientItem::CanPasteLink`を使用します。  
  
-   ID\_EDIT\_PASTE\_SPECIAL はオプションの現在のクリップボードの内容を挿入します。  
  
     現在、このコマンドの標準の実装がありません。  各 `CView`ではこれを\-派生クラス実装しなければなりません。  MFC はこのダイアログは用意されていません。  
  
     このコマンドを実装する場合は、使用するこのコマンド ID をお勧めします。  
  
-   ID\_EDIT\_REPEAT、最後の操作を繰り返します。  
  
     現在、このコマンドの標準の実装がありません。  各 `CView`ではこれを\-派生クラス実装しなければなりません。  
  
     `CEditView` は 最後の検索操作を繰り返すこのコマンドの実装を提供します。  最後の検索のプライベートな実装の変数が使用されます。  コマンドが指定されている場合は、無効になります。  
  
     このコマンドを実装する場合は、使用するこのコマンド ID をお勧めします。  
  
-   ID\_EDIT\_REPLACE は置換操作を、移動しますが、モードレス ダイアログ ボックスを開始します。  
  
     現在、このコマンドの標準の実装がありません。  各 `CView`ではこれを\-派生クラス実装しなければなりません。  
  
     `CEditView` では、実装のヘルパー関数 **OnEditFindReplace** を呼び出し、以前の検索を保存するには、プライベートな実装の変数設定を置き換えます。このコマンドの実装を提供します。  `CFindReplaceDialog` クラスをユーザーに求めるモードレス ダイアログ ボックスを管理するために使用されます。  
  
     このコマンドを実装する場合は、使用するこのコマンド ID をお勧めします。  
  
-   ID\_EDIT\_SELECT\_ALL は文書全体を選択します。  
  
     現在、このコマンドの標準の実装がありません。  各 `CView`ではこれを\-派生クラス実装しなければなりません。  
  
     `CEditView` は ドキュメント内のすべてのテキストを選択し、このコマンドの実装を提供します。  コマンドは、選択するテキストがない場合無効になります。  
  
     このコマンドを実装する場合は、使用するこのコマンド ID をお勧めします。  
  
-   ID\_EDIT\_UNDO は最後の操作を元に戻します。  
  
     現在、このコマンドの標準の実装がありません。  各 `CView`ではこれを\-派生クラス実装しなければなりません。  
  
     `CEditView` は `CEdit::Undo`を使用してこのコマンドの実装を提供します。  コマンドは `CEdit::CanUndo` が false を返した場合無効になります。  
  
     このコマンドを実装する場合は、使用するこのコマンド ID をお勧めします。  
  
-   ID\_EDIT\_REDO は最後のアクションが実行されます。  
  
     現在、このコマンドの標準の実装がありません。  各 `CView`ではこれを\-派生クラス実装しなければなりません。  
  
     このコマンドを実装する場合は、使用するこのコマンド ID をお勧めします。  
  
-   ID\_WINDOW\_NEW はアクティブ ドキュメントの別のウィンドウを開きます。  
  
     **CMDIFrameWnd::OnWindowNew** は 現在のドキュメントの別のビューを含む別のフレームを作成するには、現在のドキュメントのドキュメント テンプレートを使用してこの強力な機能を実装します。  
  
     ほとんどのマルチ ドキュメント インターフェイス \(MDI\) \(MDI\) ウィンドウのメニュー コマンドと同様に、コマンドはアクティブな MDI 子ウィンドウがない場合無効になります。  
  
     このコマンド ハンドラーのカスタマイズはお勧めしません。  追加ビューまたはフレーム ウィンドウを作成するコマンドを指定する場合は、通常、OK 状態になり、独自のコマンドを利用します。  **CMDIFrameWnd::OnWindowNew** からコードを複製を作成し、お気に入りの特定のフレームとビュー クラスを変更できます。  
  
-   ID\_WINDOW\_ARRANGE が MDI ウィンドウの下部にあるアイコンを配置します。  
  
     `CMDIFrameWnd` は 実装のヘルパー関数 **OnMDIWindowCmd**この MDI の標準コマンドを実装します。  このヘルパーは MDI の Windows メッセージにコマンド ID をマップし、多くのコードを共有できます。  
  
     ほとんどの MDI ウィンドウのメニュー コマンドと同様に、コマンドはアクティブな MDI 子ウィンドウがない場合無効になります。  
  
     このコマンド ハンドラーのカスタマイズはお勧めしません。  
  
-   ID\_WINDOW\_CASCADE は、ウィンドウを重ねて表示など、重複にドロップします。  
  
     `CMDIFrameWnd` は 実装のヘルパー関数 **OnMDIWindowCmd**この MDI の標準コマンドを実装します。  このヘルパーは MDI の Windows メッセージにコマンド ID をマップし、多くのコードを共有できます。  
  
     ほとんどの MDI ウィンドウのメニュー コマンドと同様に、コマンドはアクティブな MDI 子ウィンドウがない場合無効になります。  
  
     このコマンド ハンドラーのカスタマイズはお勧めしません。  
  
-   水平方向の ID\_WINDOW\_TILE\_HORZ のタイル ウィンドウ。  
  
     このコマンドは **ID\_WINDOW\_CASCADE**などの `CMDIFrameWnd` で別の MDI Windows メッセージが操作に使用される以外、実装されます。  
  
     アプリケーションの既定のタイル方向を選択する必要があります。  **ID\_WINDOW\_TILE\_HORZ** または **ID\_WINDOW\_TILE\_VERT**ウィンドウに「」、メニュー項目の ID を変更することで、これを行うことができます。  
  
-   垂直方向の ID\_WINDOW\_TILE\_VERT のタイル ウィンドウ。  
  
     このコマンドは **ID\_WINDOW\_CASCADE**などの `CMDIFrameWnd` で別の MDI Windows メッセージが操作に使用される以外、実装されます。  
  
     アプリケーションの既定のタイル方向を選択する必要があります。  **ID\_WINDOW\_TILE\_HORZ** または **ID\_WINDOW\_TILE\_VERT**ウィンドウに「」、メニュー項目の ID を変更することで、これを行うことができます。  
  
-   分割への ID\_WINDOW\_SPLIT キーボード インターフェイス。  
  
     `CView` は `CSplitterWnd` の実装に対してこのコマンドを処理します。  ビューは、分割ウィンドウの一部である場合、このコマンドは、実装の関数 `CSplitterWnd::DoKeyboardSplit`に委任します。  これは、キーボード ユーザーまたは unsplit が分割ウィンドウ分割するようにするモードに分割されます。  
  
     このコマンドは、ビューが分割にある無効になります。  
  
     このコマンド ハンドラーのカスタマイズはお勧めしません。  
  
-   ID\_APP\_ABOUT は About ダイアログ ボックスを呼び出します。  
  
     ボックスに関するアプリケーションの標準の実装がありません。  AppWizard に既定で作成されたアプリケーションは、アプリケーションのカスタム クラスを作成し、ダイアログ ボックスであるとして使用します。  AppWizard はこのコマンドを処理し、ダイアログを呼び出す単純なコマンド ハンドラーを記述します。  
  
     ほとんどの場合、このコマンドを実装します。  
  
-   ID\_APP\_EXIT アプリケーションの終了。  
  
     **CWinApp::OnAppExit** は アプリケーションのメイン ウィンドウに `WM_CLOSE` メッセージを送信して、このコマンドを処理します。  アプリケーション \(ダーティ ファイルの入力要求など\) の標準シャットダウンは `CFrameWnd` の実装によって処理されます。  
  
     このコマンド ハンドラーのカスタマイズはお勧めしません。  `CWinApp::SaveAllModified` または `CFrameWnd` の最後のロジックをオーバーライドすることをお勧めします。  
  
     このコマンドを実装する場合は、使用するこのコマンド ID をお勧めします。  
  
-   ID\_HELP\_INDEX は .HLP ファイルのヘルプ トピックが表示されます。  
  
    > [!NOTE]
    >  `CWinApp`に\-この機能を有効にするには、派生クラスでこのメッセージ マップを接続する必要があります。  
  
     `CWinApp::OnHelpIndex` は つまらなく `CWinApp::WinHelp`を呼び出して、このコマンドを処理します。  
  
     このコマンド ハンドラーのカスタマイズはお勧めしません。  
  
-   ID\_HELP\_USING の表示方法ではヘルプを使用したりできます。  
  
    > [!NOTE]
    >  `CWinApp`に\-この機能を有効にするには、派生クラスでこのメッセージ マップを接続する必要があります。  
  
     `CWinApp::OnHelpUsing` は つまらなく `CWinApp::WinHelp`を呼び出して、このコマンドを処理します。  
  
     このコマンド ハンドラーのカスタマイズはお勧めしません。  
  
-   ID\_CONTEXT\_HELP は SHIFT\-F1 ヘルプ モードになります。  
  
    > [!NOTE]
    >  `CWinApp`に\-この機能を有効にするには、派生クラスでこのメッセージ マップを接続する必要があります。  
  
     `CWinApp::OnContextHelp` は ヘルプ モードのカーソルを設定し、モーダル ループを入力し、ヘルプを表示するためにウィンドウを選択するようにユーザーの待機により、このコマンドを処理します。  MFC の実装の詳細については [テクニカル ノート 28](../mfc/tn028-context-sensitive-help-support.md) を参照してください。  
  
     このコマンド ハンドラーのカスタマイズはお勧めしません。  
  
-   ID\_HELP が現在のコンテキストのヘルプを示します  
  
    > [!NOTE]
    >  `CWinApp`に\-この機能を有効にするには、派生クラスでこのメッセージ マップを接続する必要があります。  
  
     `CWinApp::OnHelp` は、現在のアプリケーション コンテキストのヘルプ コンテキストを取得して、このコマンドを処理します。  これは単純な F1 ヘルプ、メッセージ ボックスのヘルプなどを処理します。  MFC の実装の詳細については [テクニカル ノート 28](../mfc/tn028-context-sensitive-help-support.md) を参照してください。  
  
     このコマンド ハンドラーのカスタマイズはお勧めしません。  
  
-   ID\_DEFAULT\_HELP の表示は、コンテキストのヘルプを行います。  
  
    > [!NOTE]
    >  `CWinApp`に\-この機能を有効にするには、派生クラスでこのメッセージ マップを接続する必要があります。  
  
     このコマンドは、通常 `CWinApp::OnHelpIndex`にマップされます。  
  
     別のコマンド ハンドラーは既定のヘルプとヘルプ索引の違いが必要な場合は提供できます。  
  
-   ID\_NEXT\_PANE は次のペインに移動します  
  
     `CView` は `CSplitterWnd` の実装に対してこのコマンドを処理します。  ビューは、分割ウィンドウの一部である場合、このコマンドは、実装の関数 **CSplitterWnd::OnNextPaneCmd**に委任します。  これは、分割ウィンドウの次のペインにアクティブなビューを移動します。  
  
     このコマンドは、ビューが分割にない場合、またはに進む次のペインが存在無効になります。  
  
     このコマンド ハンドラーのカスタマイズはお勧めしません。  
  
-   ID\_PREV\_PANE は前のペインに移動します  
  
     `CView` は `CSplitterWnd` の実装に対してこのコマンドを処理します。  ビューは、分割ウィンドウの一部である場合、このコマンドは、実装の関数 **CSplitterWnd::OnNextPaneCmd**に委任します。  これは、分割線の前のペインにアクティブなビューを移動します。  
  
     このコマンドは、ビューが分割にない場合、またはに進む前にペインが存在無効になります。  
  
     このコマンド ハンドラーのカスタマイズはお勧めしません。  
  
-   ID\_OLE\_INSERT\_NEW は新しい OLE オブジェクトを挿入します。  
  
     現在、このコマンドの標準の実装がありません。  `CView`の\-これを現在の選択範囲で新しい OLE アイテムやオブジェクトを挿入する派生クラス実装しなければなりません。  
  
     すべての OLE クライアント アプリケーションは、このコマンドを実装する必要があります。  AppWizard は、OLE オプションとビュー クラスで、完了する必要がある **OnInsertObject** のスケルトン実装を作成します。  
  
     MFC にこのコマンドの完全な実装のサンプル [OCLIENT](../top/visual-cpp-samples.md) OLE の例を参照してください。  
  
-   ID\_OLE\_EDIT\_LINKS は、OLE のリンクの編集  
  
     `COleDocument` は、このコマンドを提供する標準 MFC OLE リンク ダイアログの実装を処理します。  このダイアログ ボックスの実装は `COleLinksDialog` クラスを使用してアクセスします。  現在のドキュメントがリンクが含まれていない場合は、コマンドは無効になります。  
  
     このコマンド ハンドラーのカスタマイズはお勧めしません。  
  
-   ID\_OLE\_VERB\_FIRST…最後の OLE 動詞の ID の範囲  
  
     `COleDocument` は 現在指定 OLE アイテムやオブジェクトでサポートされている動詞にこのコマンド ID の範囲を指定します。  これにより、指定した OLE アイテム\/オブジェクト型ができるゼロ以上のカスタム動詞をサポートするため、範囲である。  アプリケーションのメニューには、**ID\_OLE\_VERB\_FIRST**の ID を持つ 1 個のメニュー項目が必要です。  プログラムを実行すると、メニューは適切な動詞メニューに更新されます \(以上の動詞のポップアップ メニュー\) です。  OLE メニューの管理はこのコマンドの更新コマンド UI に表示される `AfxOleSetEditMenu`ハンドラーによって処理されます。  
  
     この範囲のコマンド ID に処理するための明示的なコマンド ハンドラーはありません。  **COleDocument::OnCmdMsg** は この範囲のすべてのコマンド ID をフックしたり、インデックス番号が 0 から始まる動詞数に回転、動詞のサーバーを起動するようにオーバーライドされます。`COleClientItem::DoVerb`を使用\)。  
  
     このコマンド ID の範囲のカスタマイズまたは他の使用は推奨されていません。  
  
-   ID\_VIEW\_TOOLBAR はツール バーのオンとオフを切り替えます。  
  
     `CFrameWnd` は このコマンドおよび更新コマンド UI ハンドラーをツール バーの表示状態を切り替える処理します。  ツール バーは `AFX_IDW_TOOLBAR`の子ウィンドウ ID のフレーム ウィンドウの子である必要があります。  コマンド ハンドラーが実際にツール バー ウィンドウの表示状態を切り替えます。  `CFrameWnd::RecalcLayout` が 新しい状態ツール バーを含むフレーム ウィンドウを再描画するために使用されます。  更新コマンド UI ハンドラーは、ツール バーが表示されるときに、メニュー項目がチェックされます。  
  
     このコマンド ハンドラーのカスタマイズはお勧めしません。  追加のツール バーを追加する場合は、このコマンドのコマンド ハンドラーと更新コマンド UI ハンドラーを複製を作成し、変更する必要があります。  
  
-   ID\_VIEW\_STATUS\_BAR がステータス バーのオンとオフを切り替えます。  
  
     このコマンドは **ID\_VIEW\_TOOLBAR**などの `CFrameWnd` で別の子ウィンドウ ID \(**AFX\_IDW\_STATUS\_BAR**\) を使用する以外に、実装されます。  
  
## 更新のみコマンド ハンドラー  
 複数の標準コマンド ID がステータス バーのインジケーターとして使用されます。  これらは、アプリケーション アイドル時間中に現在の表示状態を表示するには、同じ更新コマンド UI 処理機構が使用されます。  これらのユーザー \(つまり、ステータス バー ペインを押すことはできません\) で選択できないため、これらのコマンド ID の `ON_COMMAND` ハンドラーは必要ではありません。  
  
-   **ID\_INDICATOR\_CAPS** : Caps ロックのインジケーター。  
  
-   **ID\_INDICATOR\_NUM** : NumLock キーのインジケーター。  
  
-   **ID\_INDICATOR\_SCRL** : SCRL ロックのインジケーター。  
  
-   **ID\_INDICATOR\_KANA** : KANA ロックのインジケーター \(日本語システムにのみ適用\)。  
  
 これらの 3 つがすべて **CFrameWnd::OnUpdateKeyIndicator**の適切な仮想キーに割り当てるためにコマンド ID を使用して実装のヘルパーで実装されます。  一般的な実装は適切な仮想キーが現在ロックされているかどうか \(無効になるステータス バー ペインに \= テキストなし\) `CCmdUI` オブジェクトを、有効または無効にします。  
  
 このコマンド ハンドラーのカスタマイズはお勧めしません。  
  
-   **ID\_INDICATOR\_EXT : EXT**は選択インジケーターを終了します。  
  
-   **ID\_INDICATOR\_OVR : OV**e の**R**strike のインジケーター。  
  
-   インジケーターを ording**ID\_INDICATOR\_REC : REC**。  
  
 現在、このインジケーターの標準の実装がありません。  
  
 このインジケーターを実装することを選択した場合は、ステータス バーで使用するこれらのインジケーターの ID およびインジケーターの順序を維持することをお勧めします \(つまり、この順序で: EXT のため、数値、SCRL、OVR、REC\)。  
  
## 参照  
 [番号順テクニカル ノート](../mfc/technical-notes-by-number.md)   
 [カテゴリ別テクニカル ノート](../mfc/technical-notes-by-category.md)