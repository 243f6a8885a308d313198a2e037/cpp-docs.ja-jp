---
title: "テクニカル ノート 31: コントロール バー | Microsoft Docs"
ms.custom: ""
ms.date: "12/03/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "vc.controls.bars"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "コントロール バー, スタイル"
  - "CStatusBar クラス, テクニカル ノート 31 の使用"
  - "CControlBar クラス, テクニカル ノート 31 の使用"
  - "CControlBar クラス, 派生"
  - "コントロール バー, クラス"
  - "CDialogBar クラス, テクニカル ノート 31 の使用"
  - "CToolBar クラス, テクニカル ノート 31 の使用"
  - "TN031"
  - "スタイル, コントロール バー"
ms.assetid: 8cb895c0-40ea-40ef-90ee-1dd29f34cfd1
caps.latest.revision: 11
caps.handback.revision: 7
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# テクニカル ノート 31: コントロール バー
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

> [!NOTE]
>  次のテクニカル ノートは、最初にオンライン ドキュメントの一部とされてから更新されていません。 結果として、一部のプロシージャおよびトピックが最新でないか、不正になります。 最新の情報について、オンライン ドキュメントのキーワードで関係のあるトピックを検索することをお勧めします。  
  
 ここでは、MFC のコントロール バー クラスとして標準的な [CControlBar](#_mfcnotes_ccontrolbar)、[CStatusBar](#_mfcnotes_cstatusbar)、[CToolBar](#_mfcnotes_ctoolbar)、[CDialogBar](#_mfcnotes_cdialogbar)、**CDockBar** について説明します。  
  
 `CControlBar`  
  
 **ControlBar** は `CWnd` の派生クラスであり、次のような特徴があります。  
  
-   フレーム ウィンドウの上部または下部に配置されます。  
  
-   子項目として、HWND ベースのコントロール \(`CDialogBar` など\) または `HWND` ベースではない項目 \(`CToolBar`、`CStatusBar` など\) のいずれかを含むことができます。  
  
 コントロール バーでは、次の追加スタイルがサポートされています。  
  
-   `CBRS_TOP`: \(既定値\) コントロール バーを上部に固定します。  
  
-   `CBRS_BOTTOM`: コントロール バーを下部に固定します。  
  
-   `CBRS_NOALIGN`: 親のサイズ変更時にコントロール バーの位置を変更しません。  
  
 `CControlBar` からの派生クラスには、次のような、さらに興味深い実装が用意されています。  
  
-   `CStatusBar`: ステータス バー。項目はテキストを含むステータス バー ペインです。  
  
-   `CToolBar`: ツール バー。項目は 1 列に配置されたビットマップ ボタンです。  
  
-   `CDialogBar`: 標準ウィンドウ コントロールを含む、ツール バーに似たフレーム \(ダイアログ テンプレート リソースから作成できます\)。  
  
-   **CDockBar**: その他の `CControlBar` の派生オブジェクト用の汎用ドッキング領域です。 このクラスで利用できる特定のメンバー関数および変数は、今後のリリースで変更される可能性があります。  
  
 すべてのコントロール バー オブジェクト\/ウィンドウが、一部の親フレーム ウィンドウの子ウィンドウになります。 これらは通常、フレームのクライアント領域 \(たとえば、MDI クライアントまたはビュー\) に兄弟として追加されます。 コントロール バーの子ウィンドウ ID は重要な ID です。 コントロール バーの既定のレイアウトは、ID が **AFX\_IDW\_CONTROLBAR\_FIRST** ～ **AFX\_IDW\_CONTROLBAR\_LAST** の範囲内にあるコントロール バーに対してのみ有効です。 コントロール バー ID の範囲が 256 まである場合でも、最初の 32 までは特殊なコントロール バー ID です \(印刷プレビューのアーキテクチャによって直接サポートされるため\)。  
  
 `CControlBar` クラスには、次の目的に利用できる標準実装が用意されています。  
  
-   コントロール バーをフレームの上部、下部、左側、または右側に配置する。  
  
-   コントロール項目の配列を割り当てる。  
  
-   派生クラスの実装をサポートする。  
  
 通常、C\+\+ コントロール バー オブジェクトは `CFrameWnd` 派生クラスのメンバーとして埋め込まれ、親の `HWND` とオブジェクトが破棄された場合にはクリーンアップされます。 ヒープ上にコントロール バー オブジェクトを割り当てる必要がある場合は、`HWND` が破棄されたときにコントロール バーが "**delete this**" を実行するように、**m\_bAutoDestruct** メンバーを **TRUE** に設定します。  
  
> [!NOTE]
>  MFC のいずれかの派生クラス \(`CStatusBar`、`CToolBar`、`CDialogBar` など\) を使用するのではなく、独自の `CControlBar` 派生クラスを作成する場合は、`m_dwStyle` データ メンバーを設定する必要があります。 これは、次のように **Create** のオーバーライドで設定できます。  
  
```  
// CMyControlBar is derived from CControlBar  
BOOL CMyControlBar::Create( CWnd* pParentWnd, DWORD dwStyle, UINT nID )  
{  
   m_dwStyle = dwStyle;  
  
   .  
   .  
   .  
}  
```  
  
 **コントロール バー レイアウトのアルゴリズム**  
  
 コントロール バー レイアウトのアルゴリズムは非常に単純です。 フレーム ウィンドウは、メッセージ **WM\_SIZEPARENT** をコントロール バーの範囲内にあるすべての子に送信します。 このメッセージと共に、親のクライアント領域の四角形を指すポインターが渡されます。 このメッセージは、Z オーダーで子に送信されます。 コントロール バーの子は、この情報を使用して自身を配置し、親のクライアント領域のサイズを縮小します。 通常のクライアント領域用に残された最後の四角形 \(コントロール バー以外の領域\) は、メイン クライアント ウィンドウ \(通常は MDI クライアント、ビュー、または分割ウィンドウ\) を配置するために使用されます。  
  
 詳細については、「`CWnd::RepositionBars`」と「`CFrameWnd::RecalcLayout`」を参照してください。  
  
 **WM\_SIZEPARENT** を含む MFC プライベート Windows メッセージについての説明は、[テクニカル ノート 24](../mfc/tn024-mfc-defined-messages-and-resources.md) に記載されています。  
  
 `CStatusBar`  
  
 ステータス バーとは、テキスト出力ペインの行を持つコントロール バーです。 テキスト出力ペインの使用方法としては、次の 2 つの方法が一般的です。  
  
-   メッセージ行として使用する方法  
  
     \(たとえば、標準メニューのヘルプ メッセージ行\)。 通常、これらのメッセージ行には 0 から始まるインデックスによってアクセスします。  
  
-   ステータス インジケーターとして使用する方法  
  
     \(たとえば、CAP、NUM、および SCRL インジケーター\)。 通常、これらのインジケーターには文字列\/コマンド ID によってアクセスします。  
  
 ステータス バーのフォントは 10 ポイント MS P ゴシックです \(Windows インターフェイス アプリケーション デザイン ガイド、またはフォント マッパーにより 10 ポイント Swiss プロポーショナル フォントに最適なフォントとして指定\)。 日本語版など、特定のバージョンの Windows では、選択されるフォントが異なります。  
  
 ステータス バーで使用される色は、Windows インターフェイス アプリケーション デザイン ガイドの推奨事項にも適合しています。 これらの色はハード コーディングされていないため、コントロール パネルでのユーザーによるカスタマイズに応じて動的に変化します。  
  
|アイテム|Windows COLOR 値|既定の RGB|  
|----------|---------------------|-------------|  
|ステータス バーの背景|**COLOR\_BTNFACE**|RGB \(192, 192, 192\)|  
|ステータス バーのテキスト|**COLOR\_BTNTEXT**|RGB \(000, 000, 000\)|  
|ステータス バーの上端\/左端|**COLOR\_BTNHIGHLIGHT**|RGB \(255, 255, 255\)|  
|ステータス バーの下端\/右端|**COLOR\_BTNSHADOW**|RGB \(128, 128, 128\)|  
  
 **CStatusBar 用の CCmdUI のサポート**  
  
 通常、インジケーターは `ON_UPDATE_COMMAND_UI` のメカニズムを利用した方法で更新されます。 アイドル時、ステータス バーはインジケーター ペインの文字列 ID を使用して `ON_UPDATE_COMMAND_UI` ハンドラーを呼び出します。  
  
 `ON_UPDATE_COMMAND_UI` ハンドラーは以下を呼び出すことができます。  
  
-   **Enable**: ペインを有効または無効にします。 無効なペインの見た目は有効なペインとまったく同じですが、テキストが非表示になります \(つまり、テキスト インジケーターが無効になります\)。  
  
-   **SetText**: テキストを変更します。 これを使用する場合は、ペインのサイズが自動的に変更されない点に注意してください。  
  
 `CStatusBar` の作成およびカスタマイズ API の詳細については、*クラス ライブラリ リファレンス*の [CStatusBar](../mfc/reference/cstatusbar-class.md) クラスを参照してください。 ステータス バーのカスタマイズの大部分は、ステータス バーの初回表示前に行う必要があります。  
  
 ステータス バーでは、可変幅ペインが 1 つだけサポートされており、通常は最初のペインがこれにあたります。 このペインのサイズは、実際には最小サイズです。 ステータス バーがすべてのペインの最小サイズより大きい場合、余分な幅は可変幅ペインに与えられます。 ステータス バーを持つ既定のアプリケーションは、最初のペインが可変幅であるため、CAP、NUM、および SCRL 用のインジケーターが右揃えになります。  
  
 `CToolBar`  
  
 ツール バーとは、ビットマップ ボタンの行を持つコントロール バーであり、区分線を含むことができます。 プッシュ ボタンとチェック ボックス ボタンという 2 つのスタイルがサポートされます。 チェック ボックス ボタンと `ON_UPDATE_COMMAND_UI` を使用して、オプション グループ機能を構築することができます。  
  
 ツール バー内のすべてのビットマップ ボタンは、1 つのビットマップから取得します。 このビットマップには、ボタンごとに 1 つの画像またはグリフが含まれている必要があります。 通常、ビットマップ内の画像\/グリフの順序は、画面に描画される順序と同じです \(この順序はカスタマイズ API を使用して変更できます\)。  
  
 各ボタンは同じサイズにする必要があります。 既定値は標準の 24 x 22 ピクセルです。 各画像\/グリフは同じサイズにする必要があり、ビットマップ内で横並びに配置する必要があります。 既定の画像\/グリフのサイズは 16 x 15 ピクセルです。 そのため、10 個のボタンを持つツール バー \(標準サイズを使用\) には、幅 160 ピクセル、高さ 15 ピクセルのビットマップが必要です。  
  
 各ボタンは、画像\/グリフを 1 つだけ持ちます。 ボタンのさまざまな状態とスタイル \(押されている状態、アップ状態、ダウン状態、無効な状態、無効なダウン状態、不確定状態など\) は、その 1 つの画像\/グリフからアルゴリズムによって生成されます。 理論上は、どのような色のビットマップや DIB でも使用できます。 ボタンのさまざまな状態を生成するためのアルゴリズムは、元の画像がグレースケールの場合に最も効果的に機能します。 参考例については、MFC 標準サンプルの [CLIPART](../top/visual-cpp-samples.md) で提供されている標準ツール バー ボタンとツール バー ボタン クリップアートを参照してください。  
  
 ツール バーで使用される色は、Windows インターフェイス アプリケーション デザイン ガイドの推奨事項にも適合しています。 これらの色はハード コーディングされていないため、コントロール パネルでのユーザーによるカスタマイズに応じて動的に変化します。  
  
|アイテム|Windows COLOR 値|既定の RGB|  
|----------|---------------------|-------------|  
|ツール バーの背景|**COLOR\_BTNFACE**|RGB \(192, 192, 192\)|  
|ツール バー ボタンの上端\/左端|**COLOR\_BTNHIGHLIGHT**|RGB \(255, 255, 255\)|  
|ツール バー ボタンの下端\/右端|**COLOR\_BTNSHADOW**|RGB \(128, 128, 128\)|  
  
 また、ツール バーのビットマップ ボタンの色は、それが標準 Windows ボタン コントロールであるかのように塗り直されます。 この色の変更は、ビットマップがリソースから読み込まれたときに発生するほか、コントロール パネルでのユーザーによるカスタマイズに応じてシステム カラーの変更が行われた場合にも発生します。 ツール バーのビットマップに次の色が含まれている場合、その色は自動的に変更されるため、注意して使用する必要があります。 ビットマップの色が部分的に変更されることが好ましくない場合は、マップされた RGB 値に近い色を使用してください。 マッピングは正確な RGB 値に基づいて行われます。  
  
|RGB 値|動的にマップされた COLOR 値|  
|-----------|-----------------------|  
|RGB \(000, 000, 000\)|COLOR\_BTNTEXT|  
|RGB \(128, 128, 128\)|COLOR\_BTNSHADOW|  
|RGB \(192, 192, 192\)|COLOR\_BTNFACE|  
|RGB \(255, 255, 255\)|COLOR\_BTNHIGHLIGHT|  
  
 `CToolBar` の作成およびカスタマイズ API の詳細については、*クラス ライブラリ リファレンス*の [CToolBar](../mfc/reference/ctoolbar-class.md) クラスを参照してください。 ツール バーのカスタマイズの大部分は、ツール バーの初回表示前に行う必要があります。  
  
 カスタマイズ API を使用すると、ボタン ID、スタイル、スペーサー幅のほか、どのボタンに対してどの画像\/グリフを使用するかを調整できます。 既定では、これらの API を使用する必要はありません。  
  
## CToolBar 用の CCmdUI のサポート  
 ツール バーのボタンは、常に `ON_UPDATE_COMMAND_UI` のメカニズムを利用した方法で更新されます。 アイドル時、ツール バーはそのボタンのコマンド ID を使用して `ON_UPDATE_COMMAND_UI` ハンドラーを呼び出します。`ON_UPDATE_COMMAND_UI` は、区分線に対しては呼び出されませんが、プッシュ ボタンとチェック ボックス ボタンに対しては呼び出されます。  
  
 `ON_UPDATE_COMMAND_UI` ハンドラーは以下を呼び出すことができます。  
  
-   **Enable**: ボタンを有効または無効にします。 これはプッシュ ボタンでもチェック ボックス ボタンでも同様に機能します。  
  
-   `SetCheck`: ボタンのチェック状態を設定します。 これをツール バーのボタンに対して呼び出すと、そのボタンがチェック ボックス ボタンに変わります。`SetCheck` には、パラメーターとして 0 \(オフ\)、1 \(オン\)、または 2 \(不確定\) を指定できます。  
  
-   `SetRadio`: `SetCheck` の短縮形です。  
  
 チェック ボックス ボタンは "AUTO" チェック ボックス ボタンです。つまり、ユーザーがそのボタンを押すと、すぐにボタンの状態が変化します。 オン状態は、ダウン状態または押されている状態です。 組み込みのユーザー インターフェイスには、ボタンを "不確定" 状態に変更する方法はありません。この操作はコードを通じて実行する必要があります。  
  
 カスタマイズ API によって任意のツール バー ボタンの状態を変更できるため、ツール バー ボタンが表すコマンドの `ON_UPDATE_COMMAND_UI` ハンドラー内でこれらの状態を変更することをお勧めします。 アイドル処理により、`ON_UPDATE_COMMAND_UI` ハンドラーを使用してツール バー ボタンの状態が変更されるため、SetButtonStyle によってこれらの状態を変更した場合、その変更は次のアイドル時に失われる可能性があります。  
  
 ツール バーのボタンは、通常のボタンまたはメニュー項目と同じように **WM\_COMMAND** メッセージを送信し、通常は `ON_UPDATE_COMMAND_UI` ハンドラーが提供されるクラスと同じクラスの `ON_COMMAND` ハンドラーによって処理されます。  
  
 ツール バーのボタンには 4 つのスタイル \(TBBS\_ 値\) があり、次の状態を表示するために使用されます。  
  
-   TBBS\_CHECKED: チェック ボックスは現在、オン \(ダウン\) になっています。  
  
-   TBBS\_INDETERMINATE: チェック ボックスは現在、不確定状態になっています。  
  
-   TBBS\_DISABLED: ボタンは現在、無効になっています。  
  
-   TBBS\_PRESSED: ボタンは現在、押されています。  
  
 公式の Windows インターフェイス アプリケーション デザイン ガイドによる 6 種類のボタン スタイルは、次の TBBS 値で表されます。  
  
-   Up \= 0  
  
-   Mouse Down \(マウス ダウン\) \= TBBS\_PRESSED \(&#124; その他のスタイル\)  
  
-   Disabled \(無効\) \= TBBS\_DISABLED  
  
-   Down \(ダウン\) \= TBBS\_CHECKED  
  
-   Down Disabled \(ダウン、無効\) \= TBBS\_CHECKED &#124; TBBS\_DISABLED  
  
-   Indeterminate \(不確定\) \= TBBS\_INDETERMINATE  
  
##  <a name="_mfcnotes_cdialogbar"></a> CDialogBar  
 ダイアログ バーとは、標準の Windows コントロールが含まれるコントロール バーです。 ダイアログと同様にコントロールが含まれ、コントロール間でのタブ移動をサポートします。 また、バーを表すためにダイアログ テンプレートを使用する点もダイアログと同様です。  
  
 `CDialogBar` は、標準のプッシュ ボタン コントロールを含む印刷プレビュー ツール バーに使用されています。  
  
 `CDialogBar` は、`CFormView` と同じような方法で使用します。 ダイアログ バー用にダイアログ テンプレートを定義し、**WS\_CHILD** を除くすべてのスタイルを削除する必要があります。 ダイアログは表示することができない点に注意してください。  
  
 `CDialogBar` のコントロール通知はコントロール バーの親に送信されます \(ツール バーのボタンと同様\)。  
  
## CDialogBar 用の CCmdUI のサポート  
 ダイアログ バーのボタンは `ON_UPDATE_COMMAND_UI` ハンドラーのメカニズムを利用して更新する必要があります。 アイドル時、ダイアログ バーは 0x8000 以上の ID \(つまり、コマンド ID の範囲内\) を持つすべてのボタンのコマンド ID を使用して `ON_UPDATE_COMMAND_UI` ハンドラーを呼び出します。  
  
 `ON_UPDATE_COMMAND_UI` ハンドラーは以下を呼び出すことができます。  
  
-   Enable: ボタンを有効または無効にします。  
  
-   SetText: ボタンのテキストを変更します。  
  
 カスタマイズは、標準ウィンドウ マネージャー API を使用して行うことができます。  
  
## 参照  
 [番号順テクニカル ノート](../mfc/technical-notes-by-number.md)   
 [カテゴリ別テクニカル ノート](../mfc/technical-notes-by-category.md)