---
title: "テクニカル ノート 35: Visual C++ における複数のリソース ファイルとヘッダー ファイルの使用 | Microsoft Docs"
ms.custom: ""
ms.date: "12/03/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "vc.resources"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "リソース ファイル、複数"
  - "TN035"
ms.assetid: 1f08ce5e-a912-44cc-ac56-7dd93ad73fb6
caps.latest.revision: 13
caps.handback.revision: 9
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# テクニカル ノート 35: Visual C++ における複数のリソース ファイルとヘッダー ファイルの使用
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

> [!NOTE]
>  次のテクニカル ノートは、最初にオンライン ドキュメントの一部とされてから更新されていません。  結果として、一部のプロシージャおよびトピックが最新でないか、不正になります。  最新の情報について、オンライン ドキュメントのキーワードで関係のあるトピックを検索することをお勧めします。  
  
 このノートでは、Visual C\+\+ のリソース エディターが、単一プロジェクト内または複数のプロジェクト間で共有されている複数のリソース ファイルとヘッダー ファイルをサポートする方法と、そのサポートを活用する方法について説明します。  このノートでは、次の質問に回答します。  
  
-   単一プロジェクトを複数のリソース ファイルやヘッダー ファイルに分割するのはどのような場合ですか。また、どのような方法で分割しますか。  
  
-   2 つの .RC ファイルの間で、共通の .H ヘッダー ファイルをどのように共有しますか。  
  
-   プロジェクト リソースをどのように複数の .RC ファイルに分割しますか。  
  
-   .RC、.CPP、.H の各ファイル間のビルド依存関係をどのように管理しますか。  
  
 プロジェクトに追加のリソース ファイルを追加した場合は、追加されたファイル内のリソースを ClassWizard が認識しないことに注意してください。  
  
 このノートは、上記の質問に回答するために次のように構成されています。  
  
-   **Overview of How Visual C\+\+ Manages Resource Files and Header Files** では、Visual C\+\+ の \[インクルード ファイルの設定\] コマンドにより、同じプロジェクト内で複数のリソース ファイルとヘッダー ファイルを使用する方法の概要を示します。  
  
-   **Analysis of AppWizard\-created .RC and .H Files** では、AppWizard で作成したアプリケーションで使用される複数のリソース ファイルとヘッダー ファイルに注目します。  これらのファイルは、プロジェクトに追加する可能性のあるリソース ファイルやヘッダー ファイルの適切なモデルとして機能します。  
  
-   **Including Additional Header Files** では、複数のヘッダー ファイルをインクルードする可能性のある状況と、その作業を行う方法の詳細について説明します。  
  
-   **Sharing a Header File Between Two .RC Files** では、さまざまなプロジェクト内、または多くの場合は 1 つのプロジェクト内にある複数の .RC ファイルの間で、1 つのヘッダー ファイルを共有する方法を示します。  
  
-   **Using Multiple Resource Files in the Same Project** では、プロジェクトを複数の .RC ファイルに分割する可能性のある状況と、その作業を行う方法の詳細について説明します。  
  
-   **Enforcement of Non\-Editable Visual C\+\+ Files** では、Visual C\+\+ によるカスタム リソースの編集や、意図しない書式の再設定を確実に防止する方法について説明します。  
  
-   **Managing Symbols Shared by Multiple Visual C\+\+\-Edited .RC Files** では、複数の .RC ファイル間で同じシンボルを共有する方法と、重複する ID 数値の割り当てを防止する方法について説明します。  
  
-   **Managing Dependencies Between .RC, .CPP, and .H Files** では、リソース シンボル ファイルに依存する .CPP ファイルの不要な再コンパイルを Visual C\+\+ が回避する方法について説明します。  
  
-   **How Visual C\+\+ Manages Set Includes Information** では、Visual C\+\+ が複数の \(入れ子\) .RC ファイルと、\#include によって .RC ファイル内にインクルードされた複数のヘッダー ファイルを追跡する方法に関する技術的な詳細を提供します。  
  
 **Visual C\+\+ がリソース ファイルとヘッダー ファイルを管理する方法の概要**  
  
 Visual C\+\+ では、単一の .RC リソース ファイルとそれに対応する .H ヘッダー ファイルを、緊密に結合されたファイル ペアとして管理します。  .RC ファイル内でリソースを編集および保存すると、対応する .H ファイル内でシンボルを間接的に編集および保存することになります。  \(Visual C\+\+ の MDI ユーザー インターフェイスを使用して\) 一度に複数の .RC ファイルを開いて編集することができますが、任意の .RC ファイルを対象として、ただ 1 つの対応するヘッダー ファイルを間接的に編集していることになります。  
  
 **\[シンボル用のヘッダー ファイル\]**  
  
 既定では、リソース ファイル \(たとえば、MYAPP.RC\) の名前にかかわりなく、Visual C\+\+ は対応するヘッダー ファイルに必ず RESOURCE.H という名前を付けます。  Visual C\+\+ の **\[表示\]** メニューの **\[リソース ファイルのインクルード\]** コマンドを使用して、**\[インクルード ファイルの設定\]** ダイアログ ボックス内の \[シンボル用のヘッダー ファイル\] でファイル名を更新することにより、このヘッダー ファイルの名前を変更できます。  
  
 **\[読み取り専用ヘッダー ファイル\]**  
  
 Visual C\+\+ はどの特定の .RC ファイルに対しても 1 つのヘッダー ファイルのみを編集しますが、Visual C\+\+ では追加の読み取り専用ヘッダー ファイル内で定義されているシンボルへの参照をサポートします。  Visual C\+\+ の **\[表示\]** メニューの **\[リソース ファイルのインクルード\]** コマンドを使用し、\[読み取り専用ヘッダー ファイル\] として、任意の数の追加の読み取り専用ヘッダー ファイルを指定することができます。  "読み取り専用" という制限は .RC ファイル内で新しいリソースを追加するときに、読み取り専用ヘッダー ファイル内で定義されたシンボルを使用できること、ただし、リソースを削除した場合でも、シンボルは引き続き読み取り専用ヘッダー ファイル内で定義されたままになることを意味します。  読み取り専用シンボルに対して割り当てられた数値を変更することはできません。  
  
 **\[コンパイル時に追加するファイル\]**  
  
 Visual C\+\+ ではリソース ファイルの入れ子、つまり .RC ファイルの中で \#include を使用し、他の .RC ファイルをインクルードする方法をサポートしています。  Visual C\+\+ を使用して特定の .RC ファイルを編集すると、\#include によってインクルードされたファイル内のどのリソースも表示されません。  ただし、その .RC ファイルをコンパイルするときに、\#include によってインクルードされたファイルもコンパイルされます。  Visual C\+\+ の **\[表示\]** メニューの **\[リソース ファイルのインクルード\]** コマンドを使用し、\[コンパイル時に追加するファイル\] として、任意の数のインクルードされた .RC ファイルを指定することができます。  
  
 \[コンパイル時に追加するファイル\] として指定されて*いない*他の .RC ファイルをインクルードした .RC ファイルを Visual C\+\+ に読み込むときに、何が起こるかに注意してください。  この状況は、以前にテキスト エディターを使用して手動で保守していた .RC ファイルを、Visual C\+\+ に読み込む場合に発生する可能性があります。  Visual C\+\+ は インクルードされた .RC ファイルを読み取る場合は、インクルードされたリソースを親 .RC ファイルにマージします。  親 .RC ファイルを保存するときに、\#include ステートメントは実際には、インクルードされたリソースで置き換えられます。  このマージが発生することを望まない場合は、親 .RC ファイルを Visual C\+\+ で読み取る*前に*、親 .RC ファイルから \#include ステートメントを削除する必要があります。その後、Visual C\+\+ を使用して、\[コンパイル時に追加するファイル\] として、同じ \#include ステートメントをもう一度追加します。  
  
 Visual C\+\+ は、\#include ディレクティブ *および* TEXTINCLUDE リソースを使用して、1 つの .RC ファイル内に、上記の \[インクルード ファイルの設定\] の 3 種類の情報 \(\[シンボル用のヘッダー ファイル\]、\[読み取り専用ヘッダー ファイル\]、および \[コンパイル時に追加するファイル\]\) を保存します。  TEXTINCLUDE リソース、および実装の詳細は、開発者が通常取り扱う必要はありませんが、["How Visual C\+\+ Manages Set Includes Information \(Visual C\+\+ が &#91;インクルード ファイルの設定&#93; 情報を管理する方法\)"](#_mfcnotes_tn035_set_includes)に掲載されています。  
  
 **AppWizard で作成した .RC ファイルと .H ファイルの分析**  
  
 AppWizard が生成したアプリケーション コードを調べると、Visual C\+\+ が複数のリソース ファイルとヘッダー ファイルを管理する方法を把握できます。  以下で検討するコードは、既定のオプションを使用して AppWizard で生成した MYAPP アプリケーションから抜粋したものです。  
  
 AppWizard で作成したアプリケーションは、次の図に要約するように、複数のリソース ファイルと複数のヘッダー ファイルを使用します。  
  
```  
RESOURCE.H     AFXRES.H                      
       \       /                                
        \     /                                  
       MYAPP.RC                                 
           |                                  
           |                                
     RES\MYAPP.RC2    
     AFXRES.RC                     
     AFXPRINT.RC                   
```  
  
 Visual C\+\+ の \[ファイル\] \- \[インクルード ファイルの設定\] コマンドを使用して、これら複数のファイルの関係を表示できます。  
  
 MYAPP.RC  
 Visual C\+\+ を使用して編集する、アプリケーションのリソース ファイル。  
  
 RESOURCE.H は、アプリケーション固有のヘッダー ファイルです。  Visual C\+\+ のヘッダー ファイルの既定の名前付けに整合した方法で、このファイルに対して AppWizard によって必ず RESOURCE.H という名前が付けられます。  このヘッダー ファイルに対応する \#include は、リソース ファイル \(MYAPP.RC\) 内の最初のステートメントです。  
  
```  
//Microsoft Visual C++ generated resource script  
//  
#include "resource.h"  
```  
  
 RES\\MYAPP.RC2  
 Visual C\+\+ の編集対象にならないが、最後にコンパイルされる .EXE ファイルに含まれることになるリソースが格納されています。  Visual C\+\+ は \(このリリースの新しい機能である\) バージョン リソースを含め、標準のリソースすべてを編集できるため、AppWizard は既定ではこのようなリソースを作成しません。  開発者が独自のカスタム形式リソースをこのファイルに追加しようとする場合は、AppWizard によって空のファイルが生成されます。  
  
 カスタム形式リソースを使用する場合は、そのリソースを RES\\MYAPP.RC2 に追加し、Visual C\+\+ のテキスト エディターを使用して編集することができます。  
  
 AFXRES.RC と AFXPRINT.RC には、フレームワークの一部の機能で必要とされる標準的なリソースが含まれます。  RES\\MYAPP.RC2 と同様に、フレームワークによって提供されるこれらの 2 つは MYAPP.RC の最後にインクルードされるリソース ファイルです。またこれらは、\[インクルード ファイルの設定\] ダイアログ ボックスの \[コンパイル時に追加するファイル\] で指定されます。  したがって、Visual C\+\+ で MYAPP.RC を編集するときに、これらのフレームワーク リソースを直接表示または編集することはありませんが、これらはアプリケーションのバイナリ .RES ファイルと最終的な .EXE ファイルにコンパイルされます。  これらを変更する手順を含め、標準的なフレームワーク リソースの詳細については、["Technical Note 23 \(テクニカル ノート 23\)"](../mfc/tn023-standard-mfc-resources.md) を参照してください。  
  
 AFXRES.H は、フレームワークによって使用され、特に AFXRES.RC 内で使用される、`ID_FILE_NEW` のような標準的なシンボルを定義します。  また、AFXRES.H 内の \#include で指定されている WINRES.H には、WINDOWS.H のサブセットが含まれていて、これらは AFXRES.RC と同様、Visual C\+\+ によって生成される .RC ファイルで必要とされるものです。  AFXRES.H 内で定義されたシンボルは、アプリケーションのリソース ファイル \(MYAPP.RC\) を編集するときに使用できます。  たとえば、`ID_FILE_NEW` は MYAPP.RC 内のメニュー リソースにある File New メニュー項目に関連して使用されます。  フレームワークで定義されたこれらのシンボルを変更または削除することはできません。  
  
 **追加のヘッダー ファイルのインクルード**  
  
 AppWizard で作成したアプリケーションには、RESOURCE.H、および AFXRES.H という 2 つのヘッダー ファイルのみが含まれています。  RESOURCE.H のみがアプリケーション固有です。  次の状況では、追加の読み取り専用なヘッダー ファイルをインクルードする必要が生じることがあります。  
  
 ヘッダー ファイルは、外部ソースから提供することがあります。または、複数のプロジェクト間でヘッダー ファイルを共有するか、同じプロジェクトの複数の部分で共有することもあります。  
  
 ヘッダー ファイルには形式とコメントがあり、そのファイルを保存するときに、Visual C\+\+ がこれらに変更を加えるか除外することは望ましくありません。  たとえば、次のようにシンボル算術演算を使用する \#define を保持したいとします。  
  
```  
#define RED 0  
#define BLUE 1  
#define GREEN 2  
#define ID_COLOR_BUTTON 1001  
#define ID_RED_BUTTON (ID_COLOR_BUTTON + RED)  
#define ID_BLUE_BUTTON (ID_COLOR_BUTTON + BLUE)  
#define ID_GREEN_BUTTON (ID_COLOR_BUTTON + GREEN)  
```  
  
 **\[リソース ファイルのインクルード\]** コマンドを使用し、次のように \#include ステートメントを 2 番目の \[読み取り専用ヘッダー ファイル\] として指定することにより、追加の読み取り専用ヘッダー ファイルをインクルードすることができます。  
  
```  
#include "afxres.h"  
#include "second.h"  
```  
  
 ファイル関係の新しい図は次のようになります。  
  
```  
               AFXRES.H         
RESOURCE.H     SECOND.H                      
      \       /                                
       \     /                                  
      MYAPP.RC     
          |                                  
          |                                
    RES\MYAPP.RC2    
    AFXRES.RC                     
    AFXPRINT.RC                   
```  
  
 **2 つの .RC ファイル間でのヘッダー ファイルの共有**  
  
 異なるプロジェクト内、または多くの状況では同じプロジェクト内にある、2 つの .RC ファイル間で 1 つのヘッダー ファイルを共有したいと考えることがあります。  この作業を行うには、既に説明した \[読み取り専用ヘッダー ファイル\] の手法を両方の .RC ファイルに適用します。  2 つの .RC ファイルが別のアプリケーション \(別のプロジェクト\) に対応している場合は、結果は次の図に示すとおりです。  
  
```  
     RESOURCE.H   AFXRES.H   RESOURCE.H    
    (for MYAPP1)  SECOND.H   (for MYAPP2)               
          \       /     \       /             
           \     /       \     /               
          MYAPP1.RC      MYAPP2.RC                   
           /    \        /     \                     
          /      \      /       \              
RES\MYAPP1.RC2  AFXRES.RC     RES\MYAPP2.RC2                
                AFXPRINT.RC                   
```  
  
 2 番目のヘッダー ファイルが、同じアプリケーション \(プロジェクト\) 内の 2 つの .RC ファイルによって共有される状況は、後で説明します。  
  
 **同じプロジェクト内での複数のリソース ファイルの使用**  
  
 Visual C\+\+ およびリソース コンパイラは、1 つの .RC ファイル内で \#include を使用して別の .RC ファイルをインクルードする方法で、同じプロジェクト内で複数の .RC ファイルをサポートします。  複数の入れ子も許可されます。  プロジェクトのリソースを複数の .RC ファイルに分割するさまざまな理由があります。  
  
-   リソース ファイルを複数の .RC ファイルに分割した場合は、複数のプロジェクト チーム メンバーの間で多数のリソースを容易に管理できるようになります。  ファイルのチェックアウトおよび変更のチェックインの目的でソース管理パッケージを使用する場合は、リソースを複数の .RC ファイルに分割すると、リソースに対する変更の管理全体をより詳細に制御できるようになります。  
  
-   \#ifdef、\#endif、\#define のようなプリプロセッサ ディレクティブを使用する場合は、リソースの一部を対象として、リソース コンパイラによってコンパイルされる読み取り専用リソースの中にそれらを分離する必要があります。  
  
-   Visual C\+\+ の中で、複数のコンポーネント .RC ファイルの読み込みと保存は、1 つの複合 .RC ファイルより高速に実行されます。  
  
-   テキスト エディターを使用して、人間が認識できる形式のリソースを維持することを希望する場合は、Visual C\+\+ で編集する .RC ファイルとは別の .RC ファイルを用意し、その中で維持する必要があります。  
  
-   ユーザー定義のリソースを、別の特殊なデータ エディターで解釈できるバイナリまたはテキスト形式で保持する必要がある場合は、別の .RC ファイルでそのリソースを維持する必要があります。その結果、Visual C\+\+ が形式を 16 進データに変更することはありません。  MFC Advanced Concepts サンプル [SPEAKN](../top/visual-cpp-samples.md) 内の WAV \(サウンド\) ファイル リソースは適切な例です。  
  
 \[インクルード ファイルの設定\] ダイアログ ボックス内の \[コンパイル時に追加するファイル\] で、SECOND.RC の \#include を指定できます。  
  
```  
#include "res\myapp.rc2"  // non-Visual C++ edited resources  
#include "second.rc"  // THE SECOND .RC FILE  
  
#include "afxres.rc"  // Standard components  
#include "afxprint.rc"  // printing/print preview resources  
```  
  
 結果は次の図のようになります。  
  
```  
RESOURCE.H     AFXRES.H                      
       \       /                                
        \     /                                  
       MYAPP.RC  
           |                                  
           |                                
     RES\MYAPP.RC2  
     SECOND.RC    
     AFXRES.RC                     
     AFXPRINT.RC                   
```  
  
 \[コンパイル時に追加するファイル\] を使用して、Visual C\+\+ で編集可能なリソースと編集不可能なリソースを複数の .RC ファイルに編成することができます。ここで、"マスター" の MYAPP.RC は、他の .RC ファイルの \#include を行うだけで、それ以外は何もしません。  Visual C\+\+ プロジェクト .MAK ファイルを使用する場合は、プロジェクト内に "マスター" .RC ファイルをインクルードする必要があります。その結果、その中でインクルードされているすべてのリソースがアプリケーションにコンパイルされます。  
  
 **編集不可能な Visual C\+\+ ファイルの適用**  
  
 AppWizard で作成した RES\\MYAPP.RC2 ファイルは、Visual C\+\+ で誤って読み取り、形式情報を失って書き戻すことを*避ける*必要があるリソースを含むファイルの例です。  このような事態を防止するには、RES\\MYAPP.RC2 ファイルの先頭に次の行を記述します。  
  
```  
#ifdef APSTUDIO_INVOKED  
    #error this file is not editable by Visual C++  
#endif //APSTUDIO_INVOKED  
```  
  
 Visual C\+\+ は .RC ファイルをコンパイルするときに、**APSTUDIO\_INVOKED**、および **RC\_INVOKED** を定義します。  仮に AppWizard で作成したファイル構造が破損していて、Visual C\+\+ が上記の \#error 行を読み取った場合は、Visual C\+\+ は致命的なエラーを報告し、.RC ファイルの読み取りを中止します。  
  
 **Visual C\+\+ で編集した複数の .RC ファイルで共有されるシンボルの管理**  
  
 リソースを複数の .RC ファイルに分割し、それらを Visual C\+\+ で個別に編集する場合は、2 つの問題が生じます。  
  
-   複数の .RC ファイル間で同じシンボルを共有したいと考えることがあります。  
  
-   個別のリソース \(シンボル\) に同じ ID 数値を割り当てることを避けるために、Visual C\+\+ を支援する必要があります。  
  
 次の図に、最初の問題に対処するための .RC ファイルと .H ファイルの構成を示します。  
  
```  
              MYAPP.RC  
             /         \  
            /           \  
MYSTRS.H   / MYSHARED.H  \  MYMENUS.H  
     \    /    /      \   \    \  
      \  /    /        \   \    \  
   MYSTRS.RC           MYMENUS.RC  
```  
  
 この例では、文字列リソースを 1 つのリソース ファイル、MYSTRS.RC に保存し、メニューを別のファイル、MYMENUS.RC で保持します。  コマンドなどに対応する一部のシンボルは、2 つのファイル間で共有する必要が生じることがあります。  たとえば、ID\_TOOLS\_SPELL は、\[ツール\] メニューの \[スペル\] 項目に対応するメニュー コマンド ID である可能性があります。または、これは、アプリケーションのメイン ウィンドウのステータス バー内で、フレームワークによって表示されるコマンド プロンプトの文字列 ID である可能性もあります。  
  
 ID\_TOOLS\_SPELL シンボルは、共有ヘッダー ファイル、MYSHARED.H 内で保持されます。  開発者はテキスト エディターを使用し、この共有ヘッダー ファイルを手動で保守します。Visual C\+\+ がこのファイルを直接編集することはありません。  2 つのリソース ファイル MYSTRS.RC と MYMENUS.RC の中で、前述のように **\[リソース ファイルのインクルード\]** コマンドを使用して、MYSHARED.H に対する \[読み取り専用のヘッダー ファイル\] の中で \#include MYAPP.RC を指定します。  
  
 シンボルを使用してリソースを識別しようとする前に、どのシンボルを共有する予定なのか予測すると便利です。  シンボルを共有ヘッダー ファイルに追加します。.RC ファイルに対応する \[読み取り専用のヘッダー ファイル\] の中でまだ共有ヘッダー ファイルをインクルードしていない場合は、そのシンボルを使用する前に、\#include を指定します。  シンボルをこの方法で共有することを想定していない場合は、たとえばシンボルを MYSTRS.RC 内で使用する前に、シンボルに対応する \#define ステートメントを \(テキスト エディターを使用して\) 手動で MYMENUS.H から MYSHARED.H に移動する必要が生じます。  
  
 複数の .RC ファイル内でシンボルを管理する場合も、個別のリソース \(シンボル\) に対して同じ ID 数値を割り当てることを防止するために、Visual C\+\+ を支援する必要があります。  特定の .RC ファイルに対して、Visual C\+\+ は 4 つの ID ドメインのそれぞれで、インクリメンタル形式で ID を割り当てます。  複数の編集セッションの間も、Visual C\+\+ は .RC ファイルに対応するシンボル ヘッダー ファイルの各ドメインで自らが最後に割り当てた ID を追跡しています。  次に、空の \(新しい\) .RC ファイルに対応する APS\_NEXT の値を示します。  
  
```  
#define _APS_NEXT_RESOURCE_VALUE  101  
#define _APS_NEXT_COMMAND_VALUE   40001  
#define _APS_NEXT_CONTROL_VALUE   1000  
#define _APS_NEXT_SYMED_VALUE     101  
```  
  
 **\_APS\_NEXT\_RESOURCE\_VALUE** は、ダイアログ リソース、メニュー リソースなどを対象として使用する次のシンボル値です。  リソース シンボル値の有効な値の範囲は 1 ～ 0x6FFF です。  
  
 **\_APS\_NEXT\_COMMAND\_VALUE** は、コマンド ID を対象として使用する次のシンボル値です。  コマンド シンボル値の有効な値の範囲は 0x8000 ～ xDFFF です。  
  
 **\_APS\_NEXT\_COMMAND\_VALUE** は、ダイアログ コントロールを対象として使用する次のシンボル値です。  ダイアログ コントロール値の有効な値の範囲は 8 ～ 0xDFFF です。  
  
 **\_APS\_NEXT\_SYMED\_VALUE** は、シンボル ブラウザー内で \[新規\] コマンドを使用して手動でシンボル値を割り当てるときに発行される次のシンボル値です。  
  
 Visual C\+\+ は、新しい .RC ファイルを作成するときに、最小の有効な値より少し大きい値を使用して割り当てを開始します。  AppWizard も、これらの値を、MFC アプリケーションに適切な値より少し大きい値に初期化します。  ID の値範囲の詳細については、["Technical Note 20 \(テクニカル ノート 20\)"](../mfc/tn020-id-naming-and-numbering-conventions.md) を参照してください。  
  
 これで、同じプロジェクト内で新しいリソース ファイルを作成するたびに、Visual C\+\+ は **\_APS\_NEXT\_** の同じ値を定義します。  これは、たとえば 2 つの異なる .RC ファイルの中で複数のダイアログを追加する場合に、異なるダイアログに対して \#define の同じ値が割り当てられる可能性が非常に高いことを意味します。  たとえば、最初の .RC ファイル内の IDD\_MY\_DLG1 は、2 番目の .RC ファイル内にあるIDD\_MY\_DLG2 と同じ番号 101 を割り当てられる可能性があります。  
  
 これを回避するには、各 .RC ファイル内の 4 つの ID ドメインのそれぞれで、個別の数値範囲を予約する必要があります。  この作業を行うには、リソースの追加を開始する前に、各 .RC ファイル内で **\_APS\_NEXT** の値を手動で更新します。  たとえば、最初の .RC ファイルが既定の **\_APS\_NEXT** の値を使用する場合は、開発者は 2 番目の .RC ファイルに対して **\_APS\_NEXT** の次の値を割り当てることが考えられます。  
  
```  
#define _APS_NEXT_RESOURCE_VALUE  2000  
#define _APS_NEXT_COMMAND_VALUE   42000  
#define _APS_NEXT_CONTROL_VALUE   2000  
#define _APS_NEXT_SYMED_VALUE     2000  
```  
  
 もちろん、Visual C\+\+ が最初の .RC ファイル内で多数の ID を割り当て、その結果、2 番目の .RC ファイル用に予約した ID 数値との重複が始まる可能性はあります。  この現象が発生しないように、十分に大きい範囲を予約する必要があります。  
  
 **.RC、.CPP、.H ファイル間の依存関係の管理**  
  
 Visual C\+\+ は .RC ファイルを保存するときに、シンボルに対する変更を、対応する RESOURCE.H ファイルに保存します。  .RC ファイル内のリソースを参照するあらゆる .CPP ファイルは、RESOURCE.H ファイルの \#include を行う必要があります。これは通常、プロジェクトのマスター ヘッダー ファイル内で行うことになります。  この結果、ソース ファイル内でヘッダーの依存関係をスキャンする開発環境の内部プロジェクト管理が原因で、望ましくない副作用につながります。  Visual C\+\+ 内で新しいシンボルを追加するたびに、RESOURCE.H の \#include を行うすべての .CPP ファイルを再コンパイルする必要が生じます。  
  
 Visual C\+\+ では、RESOURCE.H ファイルの最初の行として次のコメントを含めることにより、RESOURCE.H の依存関係を回避できます。  
  
```  
//{{NO_DEPENDENCIES}}  
```  
  
 開発環境では RESOURCE.H に対する変更を無視することによってこのコメントを解釈し、依存先の .CPP ファイルの再コンパイルを不要にします。  
  
 Visual C\+\+ は .RC ファイルを保存するときに必ず、.RC ファイルに\/\/{{NO\_DEPENDENCIES}} コメント行を追加します。  特定の状況では、RESOURCE.H に対するビルド依存関係を回避することが原因で、リンク時に検出されない実行時エラーが発生する可能性があります。  たとえば、再コンパイルされないリソースを .CPP ファイルが参照している状況で、シンボル ブラウザーを使用して、リソースのシンボルに対して割り当てられる数値を変更する場合は、そのリソースを正しく見つけることができず、アプリケーションの実行時にリソースが読み込まれません。  このような場合は、RESOURCE.H 内でのシンボル変更の影響を受けることがわかっているすべての .CPP ファイルを明示的に再コンパイルするか、**\[すべてリビルド\]** を選択する必要があります。  特定のリソース グループのシンボル値を頻繁に変更する必要がある場合は、前述のセクション「[追加のヘッダー ファイルのインクルード](#_mfcnotes_tn035_including)」で説明したように、それらのシンボルを個別の読み取り専用ヘッダー ファイルに分割する方法が、多くの状況で利便性と安全性が向上するものと考えられます。  
  
 **Visual C\+\+ による \[インクルード ファイルの設定\] 情報の管理方法**  
  
 前述のように、\[ファイル\] メニューの \[インクルード ファイルの設定\] コマンドで 3 種類の情報を指定できます。  
  
-   \[シンボル用のヘッダー ファイル\]  
  
-   \[読み取り専用ヘッダー ファイル\]  
  
-   \[コンパイル時に追加するファイル\]  
  
 次に、Visual C\+\+ がこれらの情報を .RC ファイル内で保持する方法について説明します。  Visual C\+\+ を使用するうえでこの情報は必須ではありませんが、\[インクルード ファイルの設定\] に関する理解を深め、より自信を持ってこの機能を使用できるようになる可能性があります。  
  
 \[インクルード ファイルの設定\] の上記の 3 種類の情報それぞれは、.RC ファイル内に 2 つの形式で格納されます。\(1\) \#include、またはリソース コンパイラで解釈可能な他のディレクティブ。および、\(2\) Visual C\+\+ でのみ解釈買おうな特殊な TEXTINCLUDE リソース。  
  
 TEXTINCLUDE リソースの目的は、Visual C\+\+ の **\[インクルード ファイルの設定\]** ダイアログ ボックス内で容易に表現できる形式で、\[インクルード ファイルの設定\] 情報を安全に格納することです。  TEXTINCLUDE は、Visual C\+\+ によって定義されている*リソースの種類*です。  Visual C\+\+ は、リソース ID 番号 1、2、および 3 を持つ、3 つの特定の TEXTINCLUDE リソースを認識します。  
  
|TEXTINCLUDE のリソース ID|\[インクルード ファイルの設定\] 情報の種類|  
|--------------------------|------------------------------|  
|1|\[シンボル用のヘッダー ファイル\]|  
|2|\[読み取り専用ヘッダー ファイル\]|  
|3|\[コンパイル時に追加するファイル\]|  
  
 \[インクルード ファイルの設定\] 情報のそれぞれは、以下で説明するように、AppWizard で作成した既定の MYAPP.RC および RESOURCE.H ファイルによって表現されます。  BEGIN および END ブロックの間にある追加の \\0 および "" トークンは、0 で終端された文字列と二重引用符のそれぞれを指定する RC の構文にとって必須です。  
  
## \[シンボル用のヘッダー ファイル\]  
 リソース コンパイラによって解釈される \[シンボル用のヘッダー ファイル\] 情報の形式は、単純な \#include ステートメントです。  
  
```  
#include "resource.h"  
```  
  
 対応する TEXTINCLUDE リソースは次のとおりです。  
  
```  
1 TEXTINCLUDE DISCARDABLE  
BEGIN  
   "resource.h\0"  
END  
```  
  
## \[読み取り専用ヘッダー ファイル\]  
 \[読み取り専用ヘッダー ファイル\] は、リソース コンパイラによる解釈が可能な次の形式で、MYAPP.RC の先頭でインクルードされます。  
  
```  
#include "afxres.h"  
```  
  
 対応する TEXTINCLUDE リソースは次のとおりです。  
  
```  
2 TEXTINCLUDE DISCARDABLE  
BEGIN  
   "#include ""afxres.h""\r\n"  
   "\0"  
END  
```  
  
## \[コンパイル時に追加するファイル\]  
 \[コンパイル時に追加するファイル\] は、リソース コンパイラによる解釈が可能な次の形式で、MYAPP.RC の最後でインクルードされます。  
  
```  
#ifndef APSTUDIO_INVOKED  
///////////////////////  
//  
// From TEXTINCLUDE 3  
//  
#include "res\myapp.rc2"  // non-Visual C++ edited resources  
  
#include "afxres.rc"  // Standard components  
#include "afxprint.rc"  // printing/print preview resources  
#endif  // not APSTUDIO_INVOKED  
```  
  
 \#ifndef APSTUDIO\_INVOKED ディレクティブは、\[コンパイル時に追加するファイル\] をスキップするように Visual C\+\+ に指示します。  
  
 対応する TEXTINCLUDE リソースは次のとおりです。  
  
```  
3 TEXTINCLUDE DISCARDABLE  
BEGIN  
"#include ""res\myapp.rc2""  // non-Visual C++ edited resources\r\n"  
"\r\n"  
"#include ""afxres.rc""  // Standard components\r\n"  
"#include ""afxprint.rc""  // printing/print preview resources\r\n"  
"\0"  
END  
```  
  
## 参照  
 [番号順テクニカル ノート](../mfc/technical-notes-by-number.md)   
 [カテゴリ別テクニカル ノート](../mfc/technical-notes-by-category.md)