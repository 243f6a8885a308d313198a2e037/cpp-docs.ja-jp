---
title: 'TN021: コマンドし、メッセージのルーティング |Microsoft ドキュメント'
ms.custom: ''
ms.date: 06/28/2018
ms.technology:
- cpp-mfc
ms.topic: conceptual
f1_keywords:
- vc.routing
dev_langs:
- C++
helpviewer_keywords:
- TN021
- command routing [MFC], technical note TN021
- Windows messages [MFC], routing
ms.assetid: b5952c8b-123e-406c-a36d-a6ac7c6df307
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: e31a35878564fc09fa6c045566811a3ff9e4b0ef
ms.sourcegitcommit: 208d445fd7ea202de1d372d3f468e784e77bd666
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/29/2018
ms.locfileid: "37122018"
---
# <a name="tn021-command-and-message-routing"></a>テクニカル ノート 21: コマンドとメッセージのルーティング

> [!NOTE]
>  次のテクニカル ノートは、最初にオンライン ドキュメントの一部とされてから更新されていません。 結果として、一部のプロシージャおよびトピックが最新でないか、不正になります。 最新の情報について、オンライン ドキュメントのキーワードで関係のあるトピックを検索することをお勧めします。

ここでは、コマンドのルーティングとディスパッチ アーキテクチャに加え、全般的なウィンドウのメッセージのルーティングでの高度なトピックについて説明します。

参照してください Visual C 全般の詳細については、ここで説明されているアーキテクチャで特に違い Windows メッセージ、コントロールの通知、およびコマンド。 このメモには、印刷されたドキュメントで説明されている問題に精通して非常に高度なトピックにのみ対応が前提とします。

## <a name="command-routing-and-dispatch-mfc-10-functionality-evolves-to-mfc-20-architecture"></a>コマンド ルーティングとディスパッチ MFC 1.0 MFC 2.0 への機能が進化アーキテクチャ

Windows には、メニュー コマンド、アクセラレータ キーおよびダイアログ コントロールの通知の通知を提供するオーバー ロード WM_COMMAND メッセージがあります。

MFC 1.0 上に構築されたを少しにより、コマンド ハンドラー (たとえば、"OnFileNew")、`CWnd`特定 WM_COMMAND への応答で呼び出されるクラスを派生します。 これは、は、メッセージ マップと呼ばれるデータ構造と共に接着され、コマンド領域の非常に効率的なメカニズムになります。

MFC 1.0 では、コマンド メッセージからのコントロールの通知を分離するための追加機能も提供されます。 コマンドがコマンド ID とも呼ばれる、16 ビットの ID によって表される コマンドを通常どおり起動、 `CFrameWnd` (つまり、メニューを選択またはアクセラレータ) し、さまざまな他のウィンドウに送られます。

MFC 1.0 では、マルチ ドキュメント インターフェイス (MDI) の実装の制限の意味でのコマンド ルーティングを使用します。 (MDI フレーム ウィンドウは、アクティブな MDI 子ウィンドウにコマンドを委任します)。

この機能は一般化され、さまざまなオブジェクト (ウィンドウ オブジェクトだけでなく) で処理するコマンドを許可するには MFC 2.0 で拡張します。 形式的を提供し、ルーティングの拡張性に優れたアーキテクチャがメッセージしコマンド ターゲットのルーティングだけでなく、コマンドの処理で、コマンドの現在の可用性を反映するために UI オブジェクト (メニュー項目やツールバーのボタン) などの更新に対しても再利用.

## <a name="command-ids"></a>コマンド ID

コマンドのルーティングとバインド プロセスの詳細については、Visual C を参照してください。 [テクニカル ノート 20](../mfc/tn020-id-naming-and-numbering-conventions.md) ID の名前付けに関する情報が含まれています。

コマンド Id の一般的なプレフィックス id「_」を使用します。 コマンド Id は > = 0x8000 します。 メッセージ行やステータス バーはコマンドの説明文字列を表示はコマンド ID と同じ Id を持つ STRINGTABLE リソースがあるかどうか

アプリケーションのリソースなどのコマンド ID は、いくつかの場所に表示されます。

-   STRINGTABLE リソースを 1 つでは、メッセージ行プロンプトと同じ ID を持ちます。

-   で多くのメニュー リソースを同じコマンドを呼び出すメニュー項目にアタッチされています。

-   (詳細) GOSUB コマンドを実行するダイアログ ボタンをクリックします。

アプリケーションのソース コードでは、コマンド ID はいくつかの場所に表示されます。

-   リソース。H (またはその他のメイン シンボル ヘッダー ファイル) をアプリケーションに固有のコマンド Id を定義します。

-   おそらく ID 配列にツールバーを作成するために使用します。

-   ON_COMMAND マクロではします。

-   おそらくで an ON_UPDATE_COMMAND_UI マクロです。

コマンド Id を必要とする MFC での唯一の実装になっている、> = 0x8000 は GOSUB ダイアログ]/[コマンドの実装です。

## <a name="gosub-commands-using-command-architecture-in-dialogs"></a>ダイアログ ボックスでコマンド アーキテクチャを使用して、GOSUB コマンド

フレーム ウィンドウ、メニュー項目、ツール バー ボタン、ダイアログ バーのボタン、その他のコントロール バー、および他のユーザー インターフェイス要素をオン デマンドおよびルートのコマンドを更新したり、主にコントロール Id ルーティングおよび有効にするコマンドのコマンドのアーキテクチャの動作します。コマンド ターゲット (通常はメイン フレーム ウィンドウ) です。 ターゲットとするメイン コマンドは、必要に応じてその他のコマンド ターゲット オブジェクトにコマンドまたはコントロールの通知をルーティングする可能性があります。

ダイアログ ボックス (モーダルまたはモードレス) を活用できますコマンド アーキテクチャの機能の一部に、適切なコマンドの id です。 ダイアログ コントロールのコントロール ID を割り当てる場合 サポート ダイアログとは、自動追加コードを記述する必要があります。

これらすべての機能が正しく動作では、コマンド Id される必要があります > 0x8000 を = です。 共有コマンドがする必要がありますので、多数のダイアログは、同じフレームに送られますでした、> 0x8000、中に、特定のダイアログで非共有 Idc 必要があります < 0x7FFF を = です。

通常のボタンを配置するには該当するコマンド ID に設定 ボタンの IDC で標準のモーダル ダイアログ ボックス ユーザーがボタンを選択すると、ダイアログ ボックス (通常はメイン フレーム ウィンドウ) の所有者は、他のコマンドと同じようにコマンドを取得します。 これは、ように設定は通常使用されているため他のダイアログ ボックス (最初のダイアログ ボックスの GOSUB) を呼び出すこと、GOSUB コマンドが呼び出されます。

関数を呼び出すこともできます`CWnd::UpdateDialogControls`ダイアログで、メイン フレーム ウィンドウのアドレスを渡します。 この関数を有効にするにまたはフレーム内にコマンド ハンドラーがあるかどうかに基づいて、ダイアログ コントロールを無効にします。 この関数は自動的にするためのアプリケーションのアイドル ループなどでのコントロール バーが、この機能を適用する標準のダイアログ ボックスの直接呼び出す必要があります。

## <a name="when-onupdatecommandui-is-called"></a>ON_UPDATE_COMMAND_UI が呼び出された場合

常に、有効になっているチェック、プログラムのすべてのメニュー項目の状態を維持すると、計算コストが高い問題があることができます。 一般的な手法は、ユーザーがポップアップを選択した場合にのみ有効にする/メニュー項目をチェック. MFC 2.0 実装`CFrameWnd`ポインター メッセージを処理およびコマンド ルーティングのアーキテクチャを使用して ON_UPDATE_COMMAND_UI ハンドラー メニュー項目の状態を決定します。

`CFrameWnd` また、現在のメニュー、ステータス バー (メッセージ行とも呼ばれます) で選択した項目を記述する WM_ENTERIDLE メッセージを処理します。

アプリケーションのメニュー構造を Visual C で編集は潜在的なコマンドを表すために使用されます。 ON_UPDATE_COMMAND_UI ハンドラーでは、状態や、メニューのテキストを変更したり、(ファイル MRU 一覧 OLE 動詞のポップアップ メニューなど) 高度な使用方法については、実際に構造を変更、メニューのメニューが描画される前にすることができます。

ツールバー (およびその他のコントロール バー) ON_UPDATE_COMMAND_UI 処理の同じ並べ替えを行うアプリケーションがそのアイドル ループに入ったとき。 参照してください、*クラス ライブラリ リファレンス*と[テクニカル ノート 31](../mfc/tn031-control-bars.md)詳細については、コントロール バーです。

## <a name="nested-pop-up-menus"></a>入れ子になったポップアップ メニュー

入れ子になったメニュー構造を使用している場合、ポップアップ メニューの最初のメニュー項目に対するが 2 つの異なるケースと呼ばれることがわかります。

最初に、ポップアップ メニュー自体に対して呼び出されます。 これは、機能は、ポップアップ メニュー Id がないと、ポップアップ メニューの最初のメニュー項目の ID を使用して全体のポップアップ メニューを参照しているため必要です。 ここで、*コマンドを示して*のメンバー変数、`CCmdUI`オブジェクトが NULL になり、ポップアップ メニューをポイントします。

次に、ポップアップ メニューのメニュー項目は、描画される直前に呼び出されます。 ここで、この ID は最初のメニュー項目と*コマンドを示して*のメンバー変数、`CCmdUI`オブジェクトは NULL になります。

これにより、そのメニュー項目から個別のポップアップ メニューを有効にすることができますが、一部のメニュー認識するコードを記述することが必要です。 たとえば、次の構造の入れ子になったメニュー: で

```Output
File>
    New>
    Sheet (ID_NEW_SHEET)
    Chart (ID_NEW_CHART)
```

ID_NEW_SHEET と ID_NEW_CHART のコマンドを個別に有効になっているか無効にできます。 **新規**2 つのいずれかが有効な場合、ポップアップ メニューを有効にする必要があります。

ID_NEW_SHEET (ポップアップの最初のコマンド) のコマンド ハンドラーは、ようになります。

```cpp
void CMyApp::OnUpdateNewSheet(CCmdUI* pCmdUI)
{
    if (pCmdUI->m_pSubMenu != NULL)
    {
        // enable entire pop-up for "New" sheet and chart
        BOOL bEnable = m_bCanCreateSheet || m_bCanCreateChart;
        // CCmdUI::Enable is a no-op for this case, so we
        // must do what it would have done.
        pCmdUI->m_pMenu->EnableMenuItem(pCmdUI->m_nIndex,
            MF_BYPOSITION | 
            (bEnable  MF_ENABLED : (MF_DISABLED | MF_GRAYED)));

        return;
    }
    // otherwise just the New Sheet command
    pCmdUI->Enable(m_bCanCreateSheet);
}
```

ID_NEW_CHART のコマンド ハンドラーは、通常の更新コマンド ハンドラーと以下のような外観になります。

```cpp
void CMyApp::OnUpdateNewChart(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_bCanCreateChart);
}
```

## <a name="oncommand-and-onbnclicked"></a>ON_COMMAND と ON_BN_CLICKED

メッセージ マップ マクロ**ON_COMMAND**と**ON_BN_CLICKED**は同じです。 MFC のコマンドとコントロール通知ルーティング機構は、のみをルーティングするのに場所を決定するのにコマンド ID を使用します。 ゼロの通知コードの通知を制御 (**BN_CLICKED**) はコマンドとして解釈されます。

> [!NOTE]
> 実際には、すべてのコントロールの通知メッセージは、コマンド ハンドラーのチェーンを移動します。 たとえばは、コントロール通知ハンドラーを記述するための技術的に可能**EN_CHANGE**ドキュメント クラスにします。 これが一般的にこの機能の実際のアプリケーションは、いくつか、ClassWizard では、機能はサポートされていないと機能の使用、脆弱なコードです。

## <a name="disabling-the-automatic-disabling-of-button-controls"></a>自動の無効化、ボタン コントロールを無効にします。

ダイアログ バーのボタン コントロールを配置することも where を使用してダイアログ ボックスでを呼び出す場合**ダイアログ**、ユーザー自身で、指定されていないそのボタンが表示されます**ON_COMMAND**または**ON_UPDATE_COMMAND_UI**ハンドラーが自動的に無効になりますが、フレームワークによってです。 場合によっては、ハンドラーを持つ必要はありませんが、ボタンがオンのままにします。 これを実現する最も簡単な方法は、(で簡単に実行 ClassWizard) ダミー コマンド ハンドラーを追加し、これには影響しません。

## <a name="window-message-routing"></a>ウィンドウ メッセージのルーティング

次の MFC クラスと Windows メッセージのルーティングおよびその他のトピックに及ぼす影響にいくつかのより高度なトピックについて説明します。 ここにある情報が簡単に説明されているのみです。 参照してください、*クラス ライブラリ リファレンス*のパブリック Api の詳細。 実装の詳細について詳しくは、MFC ライブラリ ソース コードを参照してください。

参照してください[テクニカル ノート 17:](../mfc/tn017-destroying-window-objects.md)詳細ウィンドウのクリーンアップについては、すべての非常に重要なトピック**CWnd**-クラスを派生します。

## <a name="cwnd-issues"></a>CWnd の問題

このメンバー関数は実装**CWnd::OnChildNotify**フックまたはそれ以外の場合に通知するメッセージ、コマンド、およびコントロールの子ウィンドウ (コントロールとも呼ばれます) の強力で拡張可能なアーキテクチャを提供その親 (または「所有者」) に移動するための通知です。 場合、子ウィンドウ (/制御)、C++ は、 **CWnd**仮想関数をオブジェクト自体、 **OnChildNotify**パラメーターを使用して、元のメッセージから最初に呼び出されます (つまり、 **MSG**構造体)。 子ウィンドウは、メッセージをそのまま、食べること、または (まれな) の親のメッセージを変更できます。

既定値**CWnd**実装は、次のメッセージを処理しを使用して、 **OnChildNotify**フック子を (コントロール) に windows メッセージを最初のアクセスを許可します。

- **よう**と**WM_DRAWITEM** (の自己描画)

- **WM_COMPAREITEM**と**WM_DELETEITEM** (の自己描画)

- **兄弟**と**WM_VSCROLL**

- **WM_CTLCOLOR**

- **WM_PARENTNOTIFY**

表示されます、 **OnChildNotify**フックが自己描画メッセージにオーナー描画メッセージを変更するためです。

加え、 **OnChildNotify**フック、スクロール メッセージがある動作をさらにルーティングします。 スクロール バーとのソースの詳細については以下をご覧ください**兄弟**と**WM_VSCROLL**メッセージ。

## <a name="cframewnd-issues"></a>CFrameWnd の問題

**CFrameWnd**コマンド ルーティングおよびユーザー インターフェイスのほとんどを提供するクラスの実装を更新します。 これは主に、アプリケーションのメイン フレーム ウィンドウの使用 (**:m_pmainwnd**) がすべてのフレーム ウィンドウに適用されます。

メイン フレーム ウィンドウ、メニュー バーで、ウィンドウ、ステータス バーの親であるか、メッセージの行。 コマンド ルーティングの上の説明を参照してください、**ポインター。**

**CFrameWnd**クラスは、アクティブなビューの管理を提供します。 アクティブ ビューは、次のメッセージがルーティングします。

- すべてのコマンド メッセージ (アクティブなビューは、それらへの最初のアクセスを取得)。

- **兄弟**と**WM_VSCROLL**兄弟からのメッセージのスクロール バー (下記参照)。

- **WM_ACTIVATE** (および**WM_MDIACTIVATE** MDI の) 仮想関数への呼び出しに**CView::OnActivateView**です。

## <a name="cmdiframewndcmdichildwnd-issues"></a>CMDIFrameWnd/CMDIChildWnd の問題

両方の MDI フレーム ウィンドウ クラスから派生**CFrameWnd**したがって両方に対応可能なコマンド ルーティングの同じ並べ替えおよびで提供されるユーザー インターフェイス更新**CFrameWnd**です。 一般的な MDI アプリケーションでは、メイン フレーム ウィンドウのみ (つまり、 **CMDIFrameWnd**オブジェクト)、メニュー バーとステータス バーを保持しているため、およびコマンド ルーティングの実装の主なソース。

一般的なルーティング スキームは、アクティブな MDI 子ウィンドウがコマンドの最初のアクセスを取得します。 既定値**PreTranslateMessage**関数は、両方の MDI 子ウィンドウのアクセラレータ テーブルを (最初) 処理と MDI フレーム (秒)、標準的な MDI システム コマンド アクセラレータ通常によって処理されるだけでなく**TranslateMDISysAccel** (最後に)。

## <a name="scroll-bar-issues"></a>スクロール バーの問題

スクロール メッセージを処理するときに (**兄弟**/**OnHScroll**や**WM_VSCROLL**/**OnVScroll**)、スクロール バーのメッセージが送信元に依存しないハンドラー コードを記述しようとする必要があります。 これはなく一般的な Windows 問題である、スクロール メッセージできます true スクロール バー コントロールからから**WS_HSCROLL**/**WS_VSCROLL**スクロール バーのスクロール バー コントロールではありません。

MFC の拡張を子または兄弟スクロールされるウィンドウのスクロール バー コントロールを許可する (実際には、スクロール バーとスクロールされるウィンドウの親/子リレーションシップ何でもかまいません)。 これは、分割ウィンドウで共有のスクロール バーをにとって特に重要です。 参照してください[テクニカル ノート 29:](../mfc/tn029-splitter-windows.md)の実装の詳細**CSplitterWnd**で詳細を含むスクロール バーの問題を共有します。

側ノートでは、2 つ**CWnd**で指定されたスクロール バー スタイル作成時、派生クラスをトラップし、Windows には渡されません。 作成ルーチンに渡される**WS_HSCROLL**と**WS_VSCROLL**個別に設定できますは作成を変更することはできません。 もちろん、テストや、自分で作成した、ウィンドウの WS_SCROLL スタイルのビットを設定する必要があります直接。

**CMDIFrameWnd**スクロール バーのスタイルに渡す**作成**または**LoadFrame** MDICLIENT の作成に使用します。 スクロール バーのスタイルの両方で、スクロール可能な MDICLIENT 領域 (と同様に、Windows プログラム マネージャー) を設定することを確認する必要がある場合 (**WS_HSCROLL** &#124; **WS_VSCROLL**)、を作成するために使用したスタイルの**CMDIFrameWnd**です。

**CSplitterWnd**スプリッター地域の特別な共有のスクロール バーにスクロール バーのスタイルを適用します。 静的分割ウィンドウでは、通常は、どちらのスクロール バー スタイルを設定します。 動的分割ウィンドウについては、スクロール バー スタイル設定、分割方向、つまり、通常必要が**WS_HSCROLL** 、行を分割することができる場合**WS_VSCROLL**列を分割する場合。

## <a name="see-also"></a>関連項目

[番号順テクニカル ノート](../mfc/technical-notes-by-number.md)  
[カテゴリ別テクニカル ノート](../mfc/technical-notes-by-category.md)  
