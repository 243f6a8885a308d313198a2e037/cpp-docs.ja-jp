---
title: "テクニカル ノート 58: MFC のモジュール状態の実装 | Microsoft Docs"
ms.custom: ""
ms.date: "12/03/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "vc.mfc.implementation"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "DLL [C++], モジュールの状態"
  - "MFC [C++], 管理 (状態データを)"
  - "モジュールの状態 [C++], 管理 (状態データを)"
  - "モジュールの状態 [C++], 切り替え"
  - "プロセス状態 [C++]"
  - "スレッド状態 [C++]"
  - "TN058"
ms.assetid: 72f5b36f-b3da-4009-a144-24258dcd2b2f
caps.latest.revision: 11
caps.handback.revision: 7
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# テクニカル ノート 58: MFC のモジュール状態の実装
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

> [!NOTE]
>  次のテクニカル ノートは、最初にオンライン ドキュメントの一部とされてから更新されていません。  結果として、一部のプロシージャおよびトピックが最新でないか、不正になります。  最新の情報について、オンライン ドキュメントのキーワードで関係のあるトピックを検索することをお勧めします。  
  
 このテクニカル ノートは「MFC のモジュール状態の実装」の構造について説明します。  モジュール状態実装について理解している DLL です \(または OLE インプロセス サーバー\) から共有 MFC DLL を使用する場合に重要です。  
  
 この説明を読む前に、「 [Creating New ドキュメント、ウィンドウとビュー](../Topic/Creating%20New%20Documents,%20Windows,%20and%20Views.md)の MFC モジュールの状態データの管理」を参照してください。  ここでは、このトピックの重要な使用法についての概要情報が含まれます。  
  
## 概要  
 3 種類の MFC ステータス情報があります: モジュール状態、プロセス状態とスレッド状態。  、これらの状態の型を組み合わせることができます。  たとえば、MFC のハンドルのマップはモジュールの両方のローカル ファイルおよびスレッド ローカルです。  これは、2 種類のモジュールがスレッドのバリアント マップを持たせることができます。  
  
 プロセス状態とスレッド状態は似ています。  これらのデータ項目は、グローバル変数が、適切な Win32s サポートまたは適切なマルチスレッド サポートの特定のプロセスまたはスレッドに固有であることが必要です。  カテゴリに指定されたデータ項目が適合するかは、プロセスとスレッドの境界に関連する項目とその目的のセマンティクスによって異なります。  
  
 モジュール状態は、ローカル ユーザーがプロセスまたはスレッド ローカルのグローバル状態を実際に含めるか、提供できます。一意です。  また、すぐに切り替えることができます。  
  
## モジュール状態の切り替え  
 各スレッドは、「および」または「実行中」のモジュール状態へのポインターが格納されます \(予想どおり、ポインターは MFC スレッド ローカルの状態の一部です。  このポインターは、アプリケーションへのコールバック OLE コントロールまたは DLL、または OLE コントロールを呼び出すアプリケーションなど、実行中のスレッドがモジュール境界を渡すときに変更されます。  
  
 現在のモジュール状態を **AfxSetModuleState**を呼び出してで切り替え。  ほとんどの場合、API を直接取扱いません。  MFC は、多くの場合、ユーザーには呼び出します。WinMain、OLE エントリ ポイント、**AfxWndProc**など\)。これは、特別な **WndProc**へのモジュール状態が現在かわかっている静的にリンクして作成するすべてのコンポーネントで、特別な `WinMain` されます \(または `DllMain`\)。  MFC\\SRC ディレクトリの DLLMODUL.CPP または APPMODUL.CPP を参照して、このコードを参照できます。  
  
 これはモジュール状態を設定し、次に設定することです。  ほとんどの場合、独自のモジュール状態を「Enter キーを現在のスケジューラとして」場合の後、元のコンテキストの戻る「ポップ鳴らしてを付けます。  これは、マクロ [AFX\_MANAGE\_STATE](../Topic/AFX_MANAGE_STATE.md) および特別なクラス **AFX\_MAINTAIN\_STATE**で行われます。  
  
 `CCmdTarget` を サポートするモジュール状態の切り替えのための特別な機能があります。  特に、`CCmdTarget` は OLE オートメーション、OLE COM のエントリ ポイントに使用するルート クラスです。  システムに公開されるそのほかのエントリ ポイントのようにこれらのエントリ ポイントは正しいモジュール状態を設定する必要があります。  特定の `CCmdTarget` はどのように「正しい」モジュール状態が必要であることがわかっているか。  答えが後で呼び出されたときに呼び出すことができる」値は、現在のモジュール状態を設定するには、「現在の」モジュール状態は、ユーザー定義の作成時に何を「記録」することです。  その結果、`CCmdTarget` の特定のオブジェクトが関連付けられているモジュール状態は、オブジェクトが作成された場合には、現在のモジュール状態です。  インプロセス サーバーを読み込み、オブジェクトを作成し、そのメソッドを呼び出す簡単な例を示します。  
  
1.  DLL は **LoadLibrary**を使用して OLE で読み込まれます。  
  
2.  **RawDllMain** は 最初に呼び出されます。  これは、DLL の既知の静的なモジュール状態にモジュール状態を設定します。  したがって **RawDllMain** は DLL に静的にリンクされます。  
  
3.  このオブジェクトに関連付けられたクラス ファクトリのコンストラクターが呼び出されます。  `COleObjectFactory` は `CCmdTarget` から派生され、そのモジュール状態にインスタンス化されたまたはその結果、保存されています。  これは重要です。オブジェクトを作成するためのクラス ファクトリを求められたら、現在のモジュール状態を行うか、習得できます。  
  
4.  `DllGetClassObject` は クラス ファクトリを取得します。  MFC はこのモジュールを返します。に関連付けられたクラス ファクトリの一覧で検索します。  
  
5.  **COleObjectFactory::XClassFactory2::CreateInstance** が 呼び出されます。  オブジェクトを作成し、手順 3 `COleObjectFactory` \(がインスタンス化されたとき\) 1 で行われた現在のモジュール状態を、この関数によってモジュール状態に戻すこと。  これは [METHOD\_PROLOGUE](../Topic/METHOD_PROLOGUE.md)内に表示されます。  
  
6.  オブジェクトが作成されると、`CCmdTarget` クラスから派生したものであり、同じように保持するモジュール状態がアクティブだった `COleObjectFactory` は、この新しいオブジェクトを作成します。  次に、オブジェクトが呼び出されるたびにに切り替えるかのモジュール状態習得できます。  
  
7.  クライアントの呼び出し `CoCreateInstance` の呼び出しから受け取った OLE COM オブジェクトの関数。  オブジェクトが呼び出されると、`COleObjectFactory` ようにモジュール状態を切り替えるには `METHOD_PROLOGUE` を使用します。  
  
 参照できるようにモジュール状態はオブジェクトからオブジェクトに対するこれらの作成時に反映されます。  これが重要モジュール状態に適切に設定されることになります。  これが設定されていない場合、または COM DLL を呼び出している、または所有されたリソースが見つからないことがあります。そのほかの悲惨な形で失敗することがありますオブジェクトを MFC アプリケーションと不完全にやり取りする可能性がある。  
  
 特定の種類の DLL が、特に「の」MFC 拡張 DLL **RawDllMain** モジュール状態の切り替えことに注意してください。実際には、通常 **RawDllMain**できません\)。  これは」実際に使用するアプリケーションの場合と同様に、ユーザーが「実行するためです。  これらは、実行されている場合は、そのアプリケーションのグローバル状態を変更することが目的です。アプリケーションの一部です。  
  
 OLE コントロールやそのほかの DLL は大きく異なります。  これらは、呼び出し元のアプリケーションの状態を変更しない; これらの呼び出し元のアプリケーションは、MFC アプリケーションでなく、ため、変更する状態ではないそうでない場合があります。  これはモジュール状態の切り替えが利用された理由です。  
  
 DLL のダイアログ ボックスを起動する 1 種類のような DLL からエクスポートされた関数の場合、関数の先頭に次のコードを追加する必要があります:  
  
```  
AFX_MANAGE_STATE(AfxGetStaticModuleState( ))  
```  
  
 これは、現在のスコープを閉じるまでの [AfxGetStaticModuleState](../Topic/AfxGetStaticModuleState.md) から返される状態を使用して、現在のモジュール状態を交換します。  
  
 DLL のリソースに問題が `AFX_MODULE_STATE` マクロが使用されていない場合に発生します。  既定で、MFC はリソース テンプレートを読み込むメイン アプリケーションのリソース ハンドルを使用します。  このテンプレートは、DLL に実際に格納されます。  根本原因は、MFC のモジュール状態情報を `AFX_MODULE_STATE` マクロで切替えられなかったことです。  リソース ハンドルは、MFC のモジュール状態を復元します。  モジュール状態の切り替えと、誤ったリソース ハンドルを使用します。  
  
 `AFX_MODULE_STATE` は DLL 内の関数に配置する必要はありません。  たとえば、`InitInstance` は `AFX_MODULE_STATE` せずにアプリケーションの MFC コードで MFC が `InitInstance` の前に自動的にモジュール状態にし、`InitInstance` が戻った後に切り替えるように呼び出すことができます。  これはすべてのメッセージ マップ ハンドラーにも当てはまります。  レギュラー DLL にメッセージをルーティングする前に自動的にモジュール状態を切り替える特別なマスターのウィンドウ プロシージャがあります。  
  
## ローカル データ プロセス  
 プロセス ローカル データは Win32s DLL モデルの問題がなければ、そのような重要なものではありません。  Win32s で複数のアプリケーションが読み込まれても、DLL のすべてのグローバル共有データ。  これは、DLL が DLL に接続する各プロセスのデータ領域のコピーを取得する「real」Win32 DLL データ モデルと大差います。  複雑さに追加するには、Win32s DLL のヒープに割り当てられたデータ \(少なくとも所有権がない限り\) で実際プロセス固有です。  次のコードやデータを検討する:  
  
```  
static CString strGlobal; // at file scope  
  
__declspec(dllexport)   
void SetGlobalString(LPCTSTR lpsz)  
{  
   strGlobal = lpsz;  
}  
  
__declspec(dllexport)  
void GetGlobalString(LPCTSTR lpsz, size_t cb)  
{  
   StringCbCopy(lpsz, cb, strGlobal);  
}  
```  
  
 上のコードは DLL であり、この DLL にある場合の動作が検討は 2 個のプロセス A および B \(これは、実際には同じアプリケーションの 2 種類のインスタンスであることができます\) によって読み込まれます。  呼び出し `SetGlobalString("Hello from A")`。  そのため、メモリはプロセス A.のコンテキストで `CString` データに割り当てられます。  `CString` 自体はグローバルで、A および B.の両方から参照できることに注意してください。  ここでは `GetGlobalString(sz, sizeof(sz))`B を呼び出します。  B が設定されているデータを参照できます。  これは、Win32 のように Win32s がプロセス間に保護されていないためです。  これは、最初に問題が; 多くの場合、アプリケーションによって所有されると見なされる 1 アプリケーションの影響のグローバル データを持つことはお勧めしません。  
  
 同様に、追加の問題があります。  A が存在することを前提としています。  A が表示されたら、'`strGlobal`' の文字列によって使用されるメモリはシステムで使用できるようになります。つまり、プロセス A によってすべてに割り当てられたメモリ オペレーティング システムによって自動的によって解放。  これは `CString` のデストラクターが呼び出されるため放されません; これはまだ呼び出されていません。  これが割り当てたアプリケーションはシーンを離れたためだけによって解放。  これで、B が `GetGlobalString(sz, sizeof(sz))`を呼び出す場合は、有効なデータを受け付けない場合があります。  他のアプリケーションでは、そのほかの要因について、そのメモリを消費する場合があります。  
  
 明確に問題があります。  MFC Version 3.x はスレッド ローカル ストレージ \(TLS\) という手法を使用します。  呼び出されませんが、MFC Version 3.x プロセスはローカル ストレージのインデックスとして Win32s で実際に機能する TLS のインデックスを割り当てます。は次に基づいて、すべてのデータを TLS のインデックス"を参照してください。  これは、Win32 でスレッド ローカル データを格納するために使用した TLS のインデックスに似ています \(このトピックの詳細については、次を参照してください。  これにより、MFC DLL がプロセスごとの 2 個以上の TLS のインデックスを使用します。  多くの読み込みを OLE コントロール DLL \(OCXs\) 説明すると、すぐに TLS のインデックスを使い果たします \(使用できる 64 のみが含まれます。  また、MFC は単一の構造の 1 か所でこのデータをすべて配置する必要があります。  これは非常に拡張可能で、TLS のインデックスの使用に関しては適切ではありません。  
  
 MFC 4.x は、プロセス ローカル必要のあるデータの「ラップする」ことができる一連のクラス テンプレートを指定します。  たとえば、上記の問題は記述して変更する:  
  
```  
struct CMyGlobalData : public CNoTrackObject  
{  
   CString strGlobal;  
};  
CProcessLocal<CMyGlobalData> globalData;  
  
__declspec(dllexport)   
void SetGlobalString(LPCTSTR lpsz)  
{  
   globalData->strGlobal = lpsz;  
}  
  
__declspec(dllexport)  
void GetGlobalString(LPCTSTR lpsz, size_t cb)  
{  
   StringCbCopy(lpsz, cb, globalData->strGlobal);  
}  
```  
  
 MFC は手順 2 でこれを実装します。  まず、多くの DLL がある場合でも、プロセスごとに 2 回の TLS のインデックスだけを使用する **Tls\*** Win32 API \(**TlsAlloc**、**TlsSetValue**、**TlsGetValue**など\) の先頭にレイヤーがあります。  第 2 に、`CProcessLocal` のテンプレートはこのデータにアクセスするために使用されます。  これは、"\> 上で参照する直感的な構文を有効にするには、オペレータをオーバーライドします。  `CProcessLocal` によってラップされるすべてのオブジェクトは `CNoTrackObject`から派生されなければなりません。  `CNoTrackObject` は、プロセスが終了すると、MFC が自動的にローカル プロセス オブジェクトを破棄できる低レベルのアロケーター \(**LocalAlloc**\/**LocalFree**\) と仮想デストラクターを受け取るように提供します。  このようなオブジェクトは追加クリーンアップが必要な場合、カスタム デストラクターを持つことができます。  上の例では `CString` の埋め込まれたなオブジェクトを破棄するために、コンパイラは既定のデストラクターを生成するので、1 を必要としません。  
  
 この方法に他の興味深い利点があります。  だけでなく、`CProcessLocal` のすべてのオブジェクトは必要になるまで、組み立てられません自動的に破棄されます。  `CProcessLocal::operator->` が 呼び出されると、すぐにインスタンス化し、最初に関連するオブジェクトを示します。  上の例では、'`strGlobal`' の文字列が **SetGlobalString** まで最初に構築または **GetGlobalString** が呼び出されます。そのを意味します。  これにより、DLL の起動時間を短縮することができます。  
  
## Thread Local データ  
 データが特定のスレッドに固有であるローカル データとプロセス、スレッド ローカル データと同様に使用されます。  つまり、データ アクセスを各スレッドのデータの個別のインスタンスが必要です。  これは豊富な同期機構の代わりに何度も使用できます。  データが複数のスレッドで共有する必要がない場合は、このような機能は、高、不要になります。  これは `CString` オブジェクトを持っていることを前提とします \(上の例のようになります。  これは `CThreadLocal` のテンプレートをラップすることによってスレッド ローカルにしています:  
  
```  
struct CMyThreadData : public CNoTrackObject  
{  
   CString strThread;  
};  
CThreadLocal<CMyThreadData> threadData;  
  
void MakeRandomString()  
{  
   // a kind of card shuffle (not a great one)  
   CString& str = threadData->strThread;  
   str.Empty();  
   while (str.GetLength() != 52)  
   {  
      unsigned int randomNumber;  
      errno_t randErr;  
      randErr = rand_s( &randomNumber );  
      if ( randErr == 0 )  
      {  
         TCHAR ch = randomNumber % 52 + 1;  
         if (str.Find(ch) < 0)  
            str += ch; // not found, add it  
      }  
   }  
}  
```  
  
 `MakeRandomString` が 2 種類のスレッドから呼び出された場合、それぞれが他に影響を与えずに、さまざまな方法で文字列「混ぜます」。  これは、スレッドごとに `strThread` のインスタンスは、1 種類のグローバル インスタンスではなく、実際にあるためです。  
  
 ループの反復ごとの代わりに `CString` アドレスを一度に取得するために参照が一度がどのように使用されるかに注目してください。  ループのコードは、'`str`' どこでも使用されます `threadData->strThread` 書き込まれた可能性がある、コードは実行に非常に時間がかかります。  このような参照はループで実行されるデータへの参照をキャッシュします。  
  
 `CThreadLocal` クラス テンプレートは `CProcessLocal` を実装して、同じ手法を使用してと同じ機能。  
  
## 参照  
 [番号順テクニカル ノート](../mfc/technical-notes-by-number.md)   
 [カテゴリ別テクニカル ノート](../mfc/technical-notes-by-category.md)