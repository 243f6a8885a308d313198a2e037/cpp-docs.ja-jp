---
title: "混在アセンブリの初期化 |Microsoft ドキュメント"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
helpviewer_keywords:
- mixed assemblies [C++], loader lock
- loader lock [C++]
- initializing mixed assemblies
- deadlocks [C++]
- .cctor [C++]
- custom locales [C++]
- mixed assemblies [C++], initilizing
ms.assetid: bfab7d9e-f323-4404-bcb8-712b15f831eb
caps.latest.revision: "24"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- cplusplus
- dotnet
ms.openlocfilehash: e7d192387131ff0eaa04fc366254d7f78a73dd52
ms.sourcegitcommit: 54035dce0992ba5dce0323d67f86301f994ff3db
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/03/2018
---
# <a name="initialization-of-mixed-assemblies"></a>混在アセンブリの初期化
Visual Studio 2005 より前の Dll がコンパイルされて、 **/clr**コンパイラ オプションが非確定的にデッドロック読み込まれるときです。 この問題には、混在 DLL の読み込みまたはローダー ロックの問題が呼び出されました。 混在モード DLL の読み込みプロセスで、このような確定的でない場合の問題はほとんどなくなりました。 ただし、ローダー ロックが (確定的に) 発生する可能性のあるシナリオはいくつか残っています。
  
 [DllMain](http://msdn.microsoft.com/library/windows/desktop/ms682583) 内のコードは、CLR にはアクセスできません。 つまり、 `DllMain` は、直接的にも間接的にもマネージ関数を呼び出すことができません。 `DllMain`ではマネージ コードを宣言または実装しないでください。また、 `DllMain`内では、ガベージ コレクションや自動ライブラリ読み込みは行われません。  
  
> [!NOTE]
>  Visual C++ 2003 では、デッドロックの発生を最小限に抑える一方で、DLL を簡単に初期化できるように、_vcclrit.h が用意されていました。 しかし、_vcclrit.h を使用する必要はなくなりました。使用すると、使用が推奨されていないことを示す警告がコンパイル中に表示されます。 そのため、「 [Removing Deprecated Header File _vcclrit.h](http://msdn.microsoft.com/en-us/7881993e-431d-43e9-8c6d-0d2285a4882d)」に記載されている手順に従って、このファイルへの依存関係を削除することをお勧めします。 この他に、_vcclrit.h をインクルードする前に `_CRT_VCCLRIT_NO_DEPRECATE` を定義して警告が表示されないようにしたり、単にこの警告を無視したりする方法もありますが、理想的な解決策とはいえません。  
  
## <a name="causes-of-loader-lock"></a>ローダー ロックの原因  
 .NET プラットフォームの導入に伴い、実行モジュール (EXE または DLL) を読み込むためのメカニズムが 2 つになりました。1 つは、Windows 向けで、アンマネージ モジュールに使用されます。もう 1 つは、.NET 共通言語ランタイム (CLR: Common Language Runtime) 向けで、.NET アセンブリを読み込みます。 混在モード DLL 読み込み時の問題は、Microsoft Windows OS ローダーを中心に発生します。  
  
 .NET のコンストラクトだけを含むアセンブリをプロセスに読み込んだ場合、CLR ローダーは、必要なすべての読み込みタスクおよび初期化タスクを自分で実行できます。 しかし、混在アセンブリの場合は、ネイティブ コードやデータが含まれている可能性があるため、Windows ローダーも使用する必要があります。  
  
 Windows ローダーは、DLL が初期化されるまで、その DLL 内のコードやデータにコードがアクセスできないようにします。また、DLL が一部しか初期化されていない間は、コードが DLL を重複して読み込むことができないようにします。 そのため、Windows ローダーでは、モジュールの初期化中に安全ではないアクセスを防止する、プロセス グローバルのクリティカル セクション (多くの場合 "ローダー ロック" と呼ばれています) が使用されます。 結果として、読み込みプロセスでは、典型的な多くのデッドロックのシナリオが発生しやすくなります。 混在アセンブリの場合、次の 2 つのシナリオで、デッドロックの危険性が高くなります。  
  
-   最初のシナリオでは、 `DllMain` または静的初期化子などでローダー ロックが保持されている場合に、Microsoft Intermediate Language (MSIL) にコンパイルされた関数を実行しようとすると、デッドロックが発生します。 ここで、MSIL 関数が、読み込まれていないアセンブリ内の型を参照する場合を考えてみてください。 CLR は、そのアセンブリを自動的に読み込もうとします。これにより、Windows ローダーはローダー ロックをブロックすることが必要になる場合があります。 呼び出しシーケンスのより早い時点でコードが既にローダー ロックを保持しているため、デッドロックが発生します。 ただし、ローダー ロック中に MSIL を実行しても、必ずデッドロックが発生するわけではありません。そのために、このシナリオを診断して修復することが困難になります。 参照されている型の DLL にネイティブ コンストラクトが含まれておらず、そのすべての依存関係にネイティブ コンストラクトが含まれていない場合など、状況によっては、Windows ローダーは参照されている型の .NET アセンブリを読み込む必要がありません。 さらに、必要なアセンブリやその混在するネイティブまたは .NET の依存関係は、既に他のコードによって読み込まれている可能性があります。 その結果、デッドロックの発生を予測することが難しくなります。また、デッドロック状態が、対象となるコンピューターの構成によって異なる場合もあります。  
  
-   2 番目のシナリオでは、.NET Framework Version 1.0 および 1.1 の DLL を読み込むときに、CLR はローダー ロックが保持されていないと想定し、ローダー ロックの状況下では無効な処理をいくつか実行しました。 ローダー ロックが保持されていないという想定は、純粋な .NET DLL に対しては妥当な想定ですが、混在モード DLL はネイティブな初期化ルーチンを実行するため、ネイティブな Windows ローダーが必要となり、その結果、ローダー ロックが発生します。 したがって、開発者が DLL の初期化中に MSIL 関数を実行しない場合でも、.NET Framework Version 1.0 および 1.1 では、デッドロックが確定的でない場合にデッドロックが発生する可能性がわずかに残っていました。  
  
 混在モード DLL の読み込みプロセスで、このような確定的でない場合の問題はなくなりました。 これは、以下の変更によって実現されました。  
  
-   CLR が、混在モード DLL の読み込み時に誤った想定を行わなくなりました。  
  
-   アンマネージ初期化とマネージ初期化が、2 つの独立した段階で実行されます。 最初にアンマネージ初期化が DllMain によって実行され、その後、.NET でサポートされている *.cctor*というコンストラクトによってマネージ初期化が実行されます。 後者は、 **/Zl** または **/NODEFAULTLIB** を使用している場合を除いて、ユーザーが意識する必要はありません。 詳細については、「[/NODEFAULTLIB (Ignore Libraries)](../build/reference/nodefaultlib-ignore-libraries.md) 」と「 [/Zl (Omit Default Library Name)](../build/reference/zl-omit-default-library-name.md) 」を参照してください。  
  
 ローダー ロックは依然として発生することがありますが、再現性があり、検出されるようになりました。 DllMain に MSIL 命令が含まれている場合、コンパイラは、 [Compiler Warning (level 1) C4747](../error-messages/compiler-warnings/compiler-warning-level-1-c4747.md)という警告を生成します。 さらに、ローダー ロックの状況下で MSIL が実行されようとしている場合、CRT または CLR は検出とレポートを試みます。 CRT による検出の結果、実行時の診断として C ランタイム エラー R6033 が発生します。  
  
 このドキュメントの残りの部分では、MSIL がローダー ロックの状況で実行できる他のシナリオ、各シナリオでの問題に対する解決策、デバッグ技術について説明します。  
  
## <a name="scenarios-and-workarounds"></a>シナリオと回避策  
 ローダー ロックが発生している場合でも、ユーザー コードが MSIL を実行できる状況がいくつかあります。 開発者は、そのような状況のそれぞれについて、ユーザー コードの実装が MSIL 命令を実行しないようにする必要があります。 以下では、最も一般的な事例で問題を解決する方法を考えつつ、すべての可能性について説明します。  
  
-   `DllMain`  
  
-   静的初期化子  
  
-   起動に影響を与える、ユーザーが指定した関数  
  
-   カスタム ロケール  
  
### <a name="dllmain"></a>DllMain  
 `DllMain` 関数は、DLL 用のユーザー定義のエントリ ポイントです。 ユーザーがそれ以外の関数を指定しない限り、プロセスやスレッドを DLL にアタッチするか、プロセスやスレッドを DLL からデタッチするたびに、 `DllMain` が呼び出されます。 この呼び出しは、ローダー ロックが保持されているときに行われる可能性もあるため、ユーザー指定の `DllMain` 関数は MSIL にコンパイルしないでください。 さらに、コール ツリー内で `DllMain` をルートにしている関数も、MSIL にコンパイルできません。 この問題を解決するには、 `DllMain` が定義されているコード ブロックを、#pragma `unmanaged`で修飾する必要があります。 `DllMain` によって呼び出されるすべての関数にも、同じ処理を行う必要があります。  
  
 このような関数で、他の呼び出しコンテキスト用に MSIL 実装を必要とする関数を呼び出す必要がある場合には、同じ関数の .NET バージョンとネイティブ バージョンを重複して作成する方法を使用できます。  
  
 また、 `DllMain` が不要な場合またはローダー ロックの状況でこれを実行する必要がない場合は、ユーザー指定の `DllMain` の実装を削除できます。そうすることで、問題が発生しなくなります。  
  
 DllMain で直接 MSIL を実行しようとすると、 [Compiler Warning (level 1) C4747](../error-messages/compiler-warnings/compiler-warning-level-1-c4747.md) が発生します。 ただし、コンパイラは、DllMain が別のモジュール内の関数を呼び出し、その関数が MSIL を実行するような事例は検出できません。  
  
 このシナリオの詳細については、「診断に対する障害」を参照してください。  
  
### <a name="initializing-static-objects"></a>静的オブジェクトの初期化  
 静的オブジェクトを初期化すると、動的初期化子が必要な場合にデッドロックが発生することがあります。 コンパイル時に認識される値に静的変数が割り当てられる場合など、単純な事例では動的な初期化が不要なため、デッドロックの危険性はありません。 ただし、関数呼び出し、コンストラクター呼び出し、またはコンパイル時に評価できない式によって初期化される静的変数は、モジュールの初期化中にコードを実行する必要があります。  
  
 動的な初期化を必要とする静的初期化子の例 (関数呼び出し、オブジェクト構築、およびポインター初期化) を次のコードに示します。 これらの例は静的ではありませんが、グローバル スコープで定義されることが想定されるため、同じ結果になります。  
  
```  
// dynamic initializer function generated  
int a = init();  
CObject o(arg1, arg2);    
CObject* op = new CObject(arg1, arg2);  
```  
  
 このデッドロックの危険性は、該当モジュールが **/clr** を指定してコンパイルされているかどうかと MSIL が実行されるかどうかによって決まります。 具体的には、静的変数を **/clr** を指定せずにコンパイルする場合 (または静的変数が #pragma `unmanaged` ブロックに存在する場合) に、その変数の初期化に必要な動的初期化子によって MSIL 命令が実行されると、デッドロックが発生することがあります。 この原因は、 **/clr**を指定せずにコンパイルされたモジュールでは、DllMain によって静的変数の初期化が実行されることにあります。 これに対して、 **/clr** を指定してコンパイルされた静的変数は、アンマネージ初期化段階が完了してローダー ロックが解除された後に、.cctor によって初期化されます。  
  
 静的変数の動的な初期化が原因で発生するデッドロックに対する解決策は多数あります (問題解決にかかる時間が短い順に記載しています)。  
  
-   静的変数を含むソース ファイルは、 **/clr**を指定してコンパイルします。  
  
-   静的変数によって呼び出されるすべての関数は、#pragma `unmanaged` ディレクティブを使用してネイティブ コードにコンパイルします。  
  
-   静的変数が依存するコードを手動で複製して、.NET バージョンとネイティブ バージョンを作成し、それぞれに異なる名前を指定します。 その後、開発者は、ネイティブな静的初期化子からネイティブ バージョンを呼び出し、それ以外の場所から .NET バージョンを呼び出します。  
  
### <a name="user-supplied-functions-affecting-startup"></a>起動に影響を与える、ユーザーが指定した関数  
 起動時の初期化でライブラリが依存する、ユーザー指定の関数がいくつかあります。 たとえば、グローバルになど、C++ の演算子のオーバー ロード、`new`と`delete`演算子、ユーザー指定のバージョンは、使用、すべての場所の C++ 標準ライブラリの初期化と破棄などです。 その結果、C++ 標準ライブラリ、およびユーザー指定の静的初期化子はこれらの演算子の任意のユーザー指定のバージョンを呼び出します。  
  
 ユーザー指定バージョンが MSIL にコンパイルされると、これらの初期化子は、ローダー ロックが保持されているときに MSIL 命令を実行しようとします。 ユーザー指定の malloc でも、同じ結果になります。 この問題を解決するには、これらのオーバーロードまたはユーザー指定定義を、#pragma `unmanaged` ディレクティブを使用してネイティブ コードとして実装する必要があります。  
  
 このシナリオの詳細については、「診断に対する障害」を参照してください。  
  
### <a name="custom-locales"></a>カスタム ロケール  
 ユーザーがグローバルなカスタム ロケールを指定すると、このロケールは、今後、すべての入出力ストリームの初期化に使用されます。静的に初期化されるストリームも対象になります。 このグローバルなロケール オブジェクトを MSIL にコンパイルすると、MSIL にコンパイルされたロケール オブジェクト メンバー関数が、ローダー ロックが保持されているときに呼び出されることがあります。  
  
 この問題を解決するためのオプションが 3 つあります。  
  
 グローバル入出力ストリームの定義をすべて含むソース ファイルを、 **/clr** オプションを使用してコンパイルします。 これにより、ローダー ロックの状態では静的初期化子が実行されなくなります。  
  
 カスタム ロケールの関数定義は、#pragma `unmanaged` ディレクティブを使用することによって、ネイティブ コードにコンパイルできます。  
  
 ローダー ロックが解除されるまで、カスタム ロケールをグローバル ロケールとして設定しないようにします。 その後、初期化中に作成された入出力ストリームをカスタム ロケールで明示的に構成します。  
  
## <a name="impediments-to-diagnosis"></a>診断に対する障害  
 場合によっては、デッドロックの原因を検出することが困難になります。 以下では、そのようなシナリオとそれらの問題の解決策について説明します。  
  
### <a name="implementation-in-headers"></a>ヘッダーでの実装  
 特殊なケースで、ヘッダー ファイル内に関数を実装すると、診断が困難になる場合があります。 インライン関数とテンプレート コードの両方で、その関数をヘッダー ファイルに指定する必要があります。  C++ 言語では、単一定義規則を指定します。単一定義規則を指定すると、同じ名前で実装されているすべての関数が、強制的に同じ意味にされます。 その結果、C++ リンカーでは、特定の関数を重複して実装しているオブジェクト ファイルをマージする際に特別に注意する必要がなくなります。  
  
 Visual Studio 2005 では、前に、リンカーは単に別のソース ファイルに対して異なる最適化オプションを使用すると、事前宣言およびシナリオを合わせて、これらのと同じ意味定義の最大が選択されます。 これにより、ネイティブ DLL と .NET DLL が混在する問題が発生します。  
  
 **/clr** が有効な CPP ファイルと無効な CPP ファイルの両方に同じヘッダーがインクルードされたり、#include が #pragma `unmanaged` ブロック内にラップされたりすることがあるため、ヘッダーで実装が用意されている MSIL バージョンの関数とネイティブ バージョンの関数の両方が使用される可能性があります。 MSIL の実装とネイティブの実装は、ローダー ロックの状態での初期化については異なる意味を持ちます。これは、事実上、単一定義規則に違反しています。 その結果、リンカーが最大の実装を選択すると、他の場所で #pragma unmanaged ディレクティブを使用して明示的にネイティブ コードにコンパイルした場合でも、関数の MSIL バージョンが選択されます。 MSIL バージョンのテンプレートまたはインライン関数がローダー ロック中に呼び出されないようにするには、ローダー ロック中に呼び出されるこのような各関数のすべての定義を、#pragma `unmanaged` ディレクティブで修飾する必要があります。 サード パーティのヘッダー ファイルの場合、これを実現するための最も簡単な方法は、問題のヘッダー ファイルの #include ディレクティブの周囲で #pragma unmanaged ディレクティブをプッシュしてポップすることです。 (を参照してください[マネージ、アンマネージ](../preprocessor/managed-unmanaged.md)例についてはします)。ただし、この方法は、直接 .NET API を呼び出す必要のある他のコードを含むヘッダーには有効ではありません。  
  
 ローダー ロックを扱うユーザーの負担を減らすため、マネージとネイティブの両方の実装が存在する場合、リンカーはネイティブの実装を選択するようになっています。  これにより、上記の問題は回避されます。  ただし、このリリースではコンパイラに未解決の問題が 2 つ残っているため、この規則には、次の 2 つの例外があります。  
  
-   グローバル静的関数ポインターを介したインライン関数呼び出しである場合。  仮想関数はグローバル関数ポインターを介して呼び出されるため、このシナリオには特に注意する必要があります。  たとえば、オブジェクトに適用された  
  
```  
#include "definesmyObject.h"  
#include "definesclassC.h"  
  
typedef void (*function_pointer_t)();  
  
function_pointer_t myObject_p = &myObject;  
  
#pragma unmanaged  
void DuringLoaderlock(C & c)  
{  
    // Either of these calls could resolve to a managed implementation,   
    // at link-time, even if a native implementation also exists.  
    c.VirtualMember();  
    myObject_p();  
}  
```  
  
-   Itanium を対象とするコンパイルの場合。すべての関数ポインターの実装にバグが存在します。  前の例では、myObject_p が during_loaderlock() 内でローカルに定義されていたなら、呼び出しもマネージ実装に解決していたものと思われます。  
  
### <a name="diagnosing-in-debug-mode"></a>デバッグ モードでの診断  
 ローダー ロックに関する問題の診断はすべて、デバッグ ビルドで行う必要があります。 リリース ビルドは診断を生成しない場合があります。また、リリース モードで実行される最適化によって、ローダー ロックのシナリオで MSIL の一部が隠されることがあります。  
  
## <a name="how-to-debug-loader-lock-issues"></a>ローダー ロックに関する問題をデバッグする方法  
 MSIL 関数が呼び出されたときに、CLR が生成する診断は、CLR の実行を中断します。 さらに、このことが原因で、デバッグ対象をインプロセスで実行している場合は Visual C++ の混合モード デバッガーも中断されます。 ただし、プロセスにアタッチした場合、混合デバッガーを使用してデバッグ対象のマネージ コールスタックを取得することはできません。  
  
 ローダー ロック中に呼び出された特定の MSIL 関数を識別するには、開発者が次の手順を実行する必要があります。  
  
1.  mscoree.dll と mscorwks.dll のシンボルを使用できるようにします。  
  
     これは、次の 2 つの方法で行うことができます。 1 つ目の方法として、mscoree.dll と mscorwks.dll の PDB をシンボル検索パスに追加します。 そのためには、シンボル検索パスのオプションのダイアログ ボックスを開きます。 まず、[ツール] メニューの [オプション] をクリックします。 [オプション] ダイアログ ボックスの左ペインで、[デバッグ] ノードを展開し、[シンボル] をクリックします。mscoree.dll PDB ファイルと mscorwks.dll PDB ファイルのパスを検索一覧に追加します。 これらの PDB は、%VSINSTALLDIR%\SDK\v2.0\symbols にインストールされます。 [OK] をクリックします。  
  
     2 つ目の方法として、mscoree.dll と mscorwks.dll の PDB を Microsoft Symbol Server からダウンロードします。 Symbol Server を構成するには、シンボル検索パスのオプションのダイアログ ボックスを開きます。 まず、[ツール] メニューの [オプション] をクリックします。 [オプション] ダイアログ ボックスの左ペインで、[デバッグ] ノードを展開し、[シンボル] をクリックします。検索一覧に "http://msdl.microsoft.com/download/symbols" という検索パスを追加します。 シンボルのキャッシュ ディレクトリをシンボル サーバーのキャッシュのテキスト ボックスに追加します。 [OK] をクリックします。  
  
2.  デバッガーのモードをネイティブのみに設定します。  
  
     これを設定するには、ソリューションのスタートアップ プロジェクトの [プロパティ] グリッドを開きます。 [構成プロパティ] サブツリーで、[デバッグ] ノードを選択します。 [デバッガーの種類] フィールドを [ネイティブのみ] に設定します。  
  
3.  デバッガーを起動します (F5 キー)。  
  
4.  **/clr** を使用した診断が生成されたら、[再試行] をクリックし、[中断] をクリックします。  
  
5.  [呼び出し履歴] ウィンドウを開きます。 このウィンドウを開くには、[デバッグ] メニューの [ウィンドウ] をクリックし、[呼び出し履歴] をクリックします。場合、問題のある`DllMain`または静的初期化子は、緑色の矢印によって識別されます。 問題のある関数が示されない場合は、以下の手順を実行して検索する必要があります。  
  
6.  イミディエイト ウィンドウを開きます。このウィンドウを開くには、[デバッグ] メニューの [ウィンドウ] をクリックし、[イミディエイト] をクリックします。  
  
7.  イミディエイト ウィンドウに「.load sos.dll」と入力し、SOS デバッグ サービスを読み込みます。  
  
8.  イミディエイト ウィンドウに「!dumpstack」と入力し、内部 **/clr** スタックの完全な一覧を取得します。  
  
9. `DllMain` が原因の場合は _CorDllMain、静的初期化子が原因の場合は _VTableBootstrapThunkInitHelperStub または GetTargetForVTableEntry の最初のインスタンス (スタックの一番下にあるもの) を検索します。  この呼び出しのすぐ下にあるスタック エントリが、ローダー ロック中に実行しようとした、MSIL 実装の関数の呼び出しです。  
  
10. 手順 9. で特定したソース ファイルと行番号に移動し、「シナリオ」セクションで説明したシナリオと解決策を使用して問題を解決します。  
  
## <a name="example"></a>例  
  
### <a name="description"></a>説明  
 次のサンプルは、コードを DllMain からグローバル オブジェクトのコンストラクターに移動することによってローダー ロックを回避する方法を示します。  
  
 このサンプルにはグローバル マネージ オブジェクトがあり、そのコンストラクターには、元は DllMain 内にあったマネージ オブジェクトが含まれています。 このサンプルの 2 番目の部分は、マネージ オブジェクトのインスタンスを作成して、初期化を実行するモジュール コンストラクターを呼び出し、アセンブリを参照します。  
  
### <a name="code"></a>コード  
  
```  
// initializing_mixed_assemblies.cpp  
// compile with: /clr /LD   
#pragma once  
#include <stdio.h>  
#include <windows.h>  
struct __declspec(dllexport) A {  
   A() {  
      System::Console::WriteLine("Module ctor initializing based on global instance of class.\n");  
   }  
  
   void Test() {  
      printf_s("Test called so linker does not throw away unused object.\n");  
   }  
};  
  
#pragma unmanaged  
// Global instance of object  
A obj;  
  
extern "C"  
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved) {  
   // Remove all managed code from here and put it in constructor of A.  
   return true;  
}  
```  
  
## <a name="example"></a>例  
  
### <a name="code"></a>コード  
  
```  
// initializing_mixed_assemblies_2.cpp  
// compile with: /clr initializing_mixed_assemblies.lib  
#include <windows.h>  
using namespace System;  
#include <stdio.h>  
#using "initializing_mixed_assemblies.dll"  
struct __declspec(dllimport) A {  
   void Test();  
};  
  
int main() {  
   A obj;  
   obj.Test();  
}  
```  
  
### <a name="output"></a>出力  
  
```  
Module ctor initializing based on global instance of class.  
  
Test called so linker does not throw away unused object.  
```  
  
## <a name="see-also"></a>参照  
 [混在 (ネイティブおよびマネージ) アセンブリ](../dotnet/mixed-native-and-managed-assemblies.md)