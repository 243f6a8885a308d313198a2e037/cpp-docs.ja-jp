---
title: キャスト表記と safe_cast の導入&lt;&gt; |Microsoft ドキュメント
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-cli
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- casting
- C-style casts and /clr, motivation for new cast notation
- safe_cast keyword [C++]
ms.assetid: 4eb1d000-3b93-4394-a37b-8b8563f8dc4d
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
- dotnet
ms.openlocfilehash: 6b9432b40099f9893d7fd270faf5375646fb0493
ms.sourcegitcommit: 76b7653ae443a2b8eb1186b789f8503609d6453e
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/04/2018
---
# <a name="cast-notation-and-introduction-of-safecastltgt"></a>キャスト表記と safe_cast の概要&lt;&gt;
キャスト表記は、Visual C を c++ マネージ拡張から変更されました。  
  
 既存の構造の変更は、初期の構造を作成すると異なりますより難しいエクスペリエンスです。 ほとんど自由度があるし、ソリューションが理想的な再構築とは既存の構造の依存関係間のバランスになりがちです。  
  
 言語の拡張機能は、別の例を示します。 戻る 1990 年代前半オブジェクト指向プログラミングなった重要なパラダイムと C++ のタイプ セーフ ダウン キャスト機能の必要性迫られました。 ダウン キャストは、ユーザーの明示的な変換の基底クラスへのポインターまたはポインターへの参照または派生クラスの参照です。 ダウン キャストでは、明示的なキャストが必要です。 理由は、基本クラスのポインターの実際の型は、ランタイムのさまざまな側面をコンパイラのためチェックインできません。 またはを作成し直して、仮想関数呼び出しと同様のキャストの機能には、動的解決のフォームが必要です。 これには、2 つの質問が発生します。  
  
-   なぜダウン キャストべきオブジェクト指向パラダイムで必要でしょうか。 十分な仮想関数のメカニズムと思いませんか。 つまり、言えないのはなぜダウン キャスト (または、なんらかのキャスト) の任意の必要性がデザイン エラーであるですか。  
  
-   ダウン キャストのサポートで C++ での問題がある必要があります理由 結局のところ、これが問題になりません Smalltalk などのオブジェクト指向言語で (または、その後、Java および C# の場合) ですか? 困難ダウン キャスト機能のサポートは C++ については何か。  
  
 仮想関数は、型のファミリへの一般的な型に依存するアルゴリズムを表します。 (おを考慮していないインターフェイス、および ISO C でサポートされていないが CLR プログラミングで使用可能な興味深い設計方法を示す) です。 通常、ファミリのデザインは、クラスの階層構造では、共通のインターフェイス (仮想関数) と、アプリケーションで実際のファミリの型を表す具体的な派生クラスのセットを宣言する抽象基本クラスによって表されます。ドメイン。  
  
 A`Light`コンピューター生成された画像 (CGI) アプリケーション ドメインで、たとえば、階層が共通の属性など`color`、 `intensity`、 `position`、 `on`、`off`のようにします。 特定の光がスポット ライト、ディレクショナル ライト、方向性のない光 (太陽の考慮してください)、またはおそらく、ライトであるかどうかを心配することがなく、共通のインターフェイスを使用して、さまざまな光を制御できます。 この場合、仮想インターフェイスを実行するために特定の信号の種類にダウン キャストは必要ではありません。 運用環境では、速度が不可欠です。 ダウン キャストし、場合により、仮想の機構を使用する代わりに、呼び出しのインラインの実行を実行できる各メソッドを明示的に起動します。  
  
 そのため、C++ ではダウン キャストする理由の 1 つは、実行時のパフォーマンスの大幅な向上と引き換え仮想機構を抑制するのには。 (この手動による最適化の自動化が調査のアクティブな領域に注意してください。 ただし、明示的な使用を置き換えることよりも解決するために困難です、`register`または`inline`キーワードです)。  
  
 ダウン キャストするための 2 つ目は、ポリモーフィズムの二重性当てはまります。 ポリモーフィズムを考慮する 1 つの方法は、フォームのパッシブおよび動的なペアに分割されているされます。  
  
 仮想呼び出し (およびダウン キャスト機能) は、ポリモーフィズムの動的な使用を表します。 1 つが、プログラムの実行の特定のインスタンスにある基本クラスのポインターの実際の型に基づく動作を実行します。  
  
 ただし、ポリモーフィズムのパッシブなフォームは、基本クラスを指すポインターを派生クラスのオブジェクトを割り当てる場合使用されている、ポリモーフィズムをトランスポート メカニズムとして。 これは、主な用途の`Object`など、汎用前の CLR プログラミングのです。 受動的に使用する場合、通常のトランスポートと記憶域に対して選択した基本クラスのポインターはも抽象であるインターフェイスを提供します。 `Object`、たとえば、そのインターフェイスから 5 つのメソッドを提供より具体的な動作が必要です、明示的なキャストです。 たとえば、スポットの角度や消えるの速度を調整する場合、ならないでしょうダウン キャスト明示的にします。 多数の子のすべての可能なメソッドのスーパー セットであることのサブ型のファミリ内の仮想インターフェイスは実行不可能とためダウン キャスト機能常に必要になります、オブジェクト指向言語内で。  
  
 安全なキャストは、理由は、C++ ほど時間がかかるいずれかに追加し、オブジェクト指向言語で機能が必要ですか。 この問題は、ポインターの実行時の型に関する情報を使用できるようにする方法です。 仮想関数の場合、実行時情報を設定する 2 つの部分で、コンパイラによって。  
  
-   クラスのオブジェクトに追加する仮想テーブル ポインター メンバーが含まれています (クラス オブジェクトの前後のいずれかの興味深い履歴をそれ自体では) 適切な仮想テーブルを解決します。 たとえば、スポット ライト オブジェクト住所ライトの仮想テーブル、ディレクショナル ライト、ディレクショナル ライトの仮想テーブル  
  
-   各仮想関数が、テーブル内のスロットを固定に関連付けられていてを呼び出すための実際のインスタンスは、テーブル内で格納されているアドレスで表されます。 たとえば、仮想`Light`デストラクターをスロット 0 の場合に関連付けられる可能性があります`Color`をスロット 1、したりできます。 これは、コンパイル時に設定し、最小限のオーバーヘッドを表すためにの柔軟性のない効率的な方法です。  
  
 問題は、次に、2 番目のアドレスを追加することで、または何らかの型のエンコーディングを直接追加して、C++ ポインターのサイズを変更せずに型情報をポインターに使用できるようにする方法を示します。 これはありませんプログラマ (およびプログラム) を受け入れ可能を使用しないように、オブジェクト指向パラダイムの大部分を占めていてユーザー コミュニティに残っていました。 別の方法としてがポリモーフィックなクラス型に特殊なポインターを紹介しましたが、これは複雑になる場合、およびポインターの算術演算の問題では特に、2 つを混合するが困難します。 ありません許容できるを現在関連付けられている型では、動的に更新することと各ポインターを関連付けるランタイムのテーブルを保守します。  
  
 問題は、異なるが、正当なプログラムに対してな願望を持つユーザー コミュニティのペアです。 このソリューションには、だけでなく、切望しつつ、相互運用できるこの 2 つのコミュニティとの間のセキュリティを侵害します。 つまり、どちらの側によって提供される、ソリューションを実現する可能性がありますより小さい完璧なのにに最後にソリューションを実装します。 実際の解像度を中心にポリモーフィックなクラスの定義: ポリモーフィックなクラスは、いずれかの仮想関数が含まれています。 ポリモーフィックなクラスは、動的なタイプ セーフなキャストをサポートします。 すべてのポリモーフィックなクラスに対応する仮想テーブルには、その追加ポインター メンバーが含まれているために、管理からのポインター-として-アドレスの問題が解決しました。 関連付けられている型について、そのため、展開された仮想テーブル構造に格納できます。 タイプ セーフなキャストのコストは、(ほとんど) 機能のユーザーにローカライズされます。  
  
 タイプ セーフなキャストに関する次の問題は、その構文をでした。 キャストになっているため、ISO C 委員会に元の提案はこの例のように、非装飾のキャスト構文を使用しました。  
  
```  
spot = ( SpotLight* ) plight;  
```  
  
 これによって拒否されました委員会のキャストのコストを制御するユーザーが許可されませんでした。 動的なタイプ セーフなキャストが同じ構文以前は安全では静的キャスト表記、置換になり、ユーザーには、不要でコストがかかりすぎるときに、実行時のオーバーヘッドを抑えることがありません。  
  
 一般に、C++ は常にコンパイラでサポートされる機能を抑制するメカニズムです。 たとえば、クラス スコープ演算子を使用するか、仮想機構無効にできます (`Box::rotate(angle)`) クラスのオブジェクト (ではなくポインターまたは参照をそのクラスの) 経由で仮想メソッドを呼び出すことによってです。 後者の抑制は言語によっては必要ありませんが、実装上の問題の形式の宣言で、一時的な構造の抑制と同様の品質は。  
  
```  
// compilers are free to optimize away the temporary  
X x = X::X( 10 );  
```  
  
 こうして、提案されたについてさらに検討し、いくつかの代替表記されたと見なされます、委員会に戻さだったフォームの (`?type`)、その何らかの示されている場合、これは、動的な性質です。 静的または動的、2 つの形式の間で切り替えるできるユーザーを付けたこれがすぎる満足でした。 描画ボードに戻るため、します。 成功、3 番目の表記は、今すぐ標準`dynamic_cast<type>`一連の 4 つの新しいスタイルのキャスト表記を汎用化されたします。  
  
 C++ では ISO-、`dynamic_cast`を返します`0`、不適切なポインター型に適用され、スロー、`std::bad_cast`参照型に適用されるときに例外です。 C++ のマネージ拡張で適用する`dynamic_cast`常に返されます (そのポインター表現) のために、マネージ参照型へ`0`です。 `__try_cast<type>` バリアント型をスローする例外にアナログとして導入された、`dynamic_cast`をスローする点を除いて、`System::InvalidCastException`キャストに失敗した場合。  
  
```  
public __gc class ItemVerb;  
public __gc class ItemVerbCollection {  
public:  
   ItemVerb *EnsureVerbArray() [] {  
      return __try_cast<ItemVerb *[]>  
         (verbList->ToArray(__typeof(ItemVerb *)));  
   }  
};  
```  
  
 新しい構文で`__try_cast`として再キャストされました`safe_cast`です。 新しい構文では、同じコード フラグメントを次に示します。  
  
```  
public ref class ItemVerb;  
public ref class ItemVerbCollection {  
public:  
   array<ItemVerb^>^ EnsureVerbArray() {  
      return safe_cast<array<ItemVerb^>^>  
         ( verbList->ToArray( ItemVerb::typeid ));  
   }  
};  
```  
  
 管理対象の世界では、検証できないコードのままにするための方法で型の間でキャストするプログラマの機能を制限することで検証可能なコードを許可する必要があります。 これは、新しい構文で表される動的プログラミング パラダイムの重要な側面です。 このため、古いスタイルのキャストのインスタンスが再キャスト内部的には、実行時のキャストとしてためする例については。  
  
```  
// internally recast into the   
// equivalent safe_cast expression above  
( array<ItemVerb^>^ ) verbList->ToArray( ItemVerb::typeid );   
```  
  
 その一方で、多態性は、アクティブとパッシブ モードの両方を提供するため、サブタイプの非仮想 API にアクセスするだけのキャストを実行する必要があります。 これが発生することができます、たとえば、クラスのメンバーをするアドレス、(トランスポート メカニズムとしてパッシブ ポリモーフィズム) の階層内で型が、特定のプログラムのコンテキスト内で実際のインスタンスがわかっています。 この例では、キャストの実行時チェック許容できないオーバーヘッドになることができます。 コンパイル時を許可する手段を提供する必要があります、新しい構文が管理対象システムのプログラミング言語として使用する場合は、(つまり、静的) ダウン キャストされます。 このため、アプリケーションの`static_cast`表記がダウン キャスト コンパイル時の状態を維持できます。  
  
```  
// ok: cast performed at compile-time.   
// No run-time check for type correctness  
static_cast< array<ItemVerb^>^>(verbList->ToArray(ItemVerb::typeid));  
```  
  
 問題が行うプログラマを保証する方法がないこと、`static_cast`が正しく、善意です。 つまり、マネージ コードは検証可能であるを強制する方法はありません。 これはの動的なプログラム パラダイムをよりネイティブ、下の下にある緊急の問題ですが、プログラミング言語をユーザーに許可しないように静的と実行時のキャストを切り替える機能システム内でだけでは不十分です。  
  
 ただし、パフォーマンスの点と、新しい構文で落とし穴があります。 ネイティブのプログラミングでは、古いスタイルのキャスト表記と、新しいスタイルのパフォーマンスの違いはありません`static_cast`表記します。 新しい構文では、古いスタイルのキャスト表記は、新しいスタイルの使用する場合に比べて大幅に高く、`static_cast`表記します。 その理由は、コンパイラは、実行時チェック例外をスローするに旧形式表記の使用を内部的に変換します。 さらに、ためも変更コードの実行プロファイル - 賢明におそらくは、アプリケーションを取り込むキャッチされない例外が発生したことが、ユーザーは場合は、同じエラー メッセージにはその例外は発生しません、`static_cast`表記を使用します。 これによって、新しい形式の表記法を使用してユーザーの製品と思えるかもしれません。 失敗した場合にのみが、旧形式の表記を使用して、表示されている理由を理解しないまま大幅に低速に実行するプログラムを原因がそれ以外の場合、次の C プログラマ落とし穴に似ています。  
  
```  
// pitfall # 1:   
// initialization can remove a temporary class object,   
// assignment cannot  
Matrix m;  
m = another_matrix;  
  
// pitfall # 2: declaration of class objects far from their use  
Matrix m( 2000, 2000 ), n( 2000, 2000 );  
if ( ! mumble ) return;  
```  
  
## <a name="see-also"></a>関連項目  
 [一般的な言語の変更 (C + + CLI)](../dotnet/general-language-changes-cpp-cli.md)   
 [C スタイル キャストと/clr (C + + CLI)](../windows/c-style-casts-with-clr-cpp-cli.md)   
 [safe_cast](../windows/safe-cast-cpp-component-extensions.md)