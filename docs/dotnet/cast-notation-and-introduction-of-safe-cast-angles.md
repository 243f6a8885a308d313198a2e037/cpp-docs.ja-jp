---
title: キャスト表記と safe_cast の導入&lt;&gt; |Microsoft Docs
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-cli
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- casting
- C-style casts and /clr, motivation for new cast notation
- safe_cast keyword [C++]
ms.assetid: 4eb1d000-3b93-4394-a37b-8b8563f8dc4d
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
- dotnet
ms.openlocfilehash: 88e8165bde08b65b4f078c4b48863c2088132fca
ms.sourcegitcommit: 799f9b976623a375203ad8b2ad5147bd6a2212f0
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/19/2018
ms.locfileid: "46427865"
---
# <a name="cast-notation-and-introduction-of-safecastltgt"></a>キャスト表記と safe_cast の概要&lt;&gt;

キャスト表記は、Visual c の C++ マネージ拡張から変更されました。

既存の構造の変更は、初期構造を作成すると異なるより困難なエクスペリエンスです。 ほとんど自由度があり、理想的な再構築とは、既存の構造的な依存関係の間のセキュリティ侵害にソリューションがあること。

言語拡張機能は、別の例です。 1990 年代初頭にオブジェクト指向プログラミングが重要なパラダイムでは、C++ では、タイプ セーフのダウン キャスト機能の必要性になりましたキーを押す。 ダウン キャストは、基底クラスへのポインターまたはポインターへの参照または派生クラスの参照のユーザーの明示的な変換です。 ダウン キャストでは、明示的なキャストが必要です。 理由は、基本クラスのポインターの実際の型にランタイムの特定の側面があります。コンパイラのためチェックインできません。 またはを作成し直して、キャスト機能は、仮想関数呼び出しと同じように動的解決のフォームが必要です。 これには、2 つの質問が発生します。

- なぜダウン キャストべきオブジェクト指向パラダイムでは必要でしょうか。 仮想関数では不十分ですか。 理由 1 つを要求できませんダウン キャスト (または、どのような種類のキャスト) 必要があるデザイン エラーでしょうか。

- ダウン キャストのサポートは理由 C++ での問題を指定します。 結局のところ、問題ではありません、Smalltalk などのオブジェクト指向言語で (または、その後、Java と c#) でしょうか。 難しいダウン キャスト機能のサポートは C++ の詳細についてはしますか。

仮想関数は、型のファミリへの一般的な型に依存するアルゴリズムを表します。 (私たち考慮していないインターフェイス、設計の興味深い方法として表示されているとは、ISO C ではサポートされていませんが CLR プログラミングで使用可能な)。 そのファミリの設計がクラスの階層構造では、共通のインターフェイス (仮想関数) と一連のアプリケーションで実際のファミリの型を表す具象派生クラスを宣言する抽象基本クラスによって表される通常ドメイン。

A`Light`などのコンピューター生成された画像 (CGI) アプリケーション ドメイン内の階層が共通の属性をなどある`color`、 `intensity`、 `position`、 `on`、`off`など。 特定の光がスポット ライト、指向性光、方向性のない light (太陽の考慮してください)、またはおそらくをライトであるかどうかを心配することがなく、共通のインターフェイスを使用して、いくつかのライトを制御できます。 この場合、仮想インターフェイスに特定のライトの種類にダウン キャストは必要はありません。 運用環境では、ただし、速度が不可欠です。 ダウン キャストし、仮想のメカニズムを使用する代わりに、呼び出しのインライン実行を実行できるようにを実行するであれば、各メソッドを明示的に呼び出します。

そのため、C++ ではダウン キャストする理由の 1 つは、実行時のパフォーマンスの大幅な向上と引き換え仮想機構を抑制するのには。 (この手動の最適化の自動化が活発な分野の研究に注意してください。 ただし、難しくと明示的な使用を交換よりも解決するためには、`register`または`inline`キーワードです)。

ポリモーフィズムのデュアル構成になってから外れたダウン キャストする 2 つ目の理由です。 ポリモーフィズムを考慮する方法の 1 つはパッシブおよび動的なフォームのペアに分割されています。

仮想呼び出し (およびダウン キャスト機能) は、ポリモーフィズムの動的な使用を表します。 1 つが、プログラムの実行で特定のインスタンスにある基本クラスのポインターの実際の型に基づく動作を実行します。

ポリモーフィズムのパッシブ フォームは、ただし、派生クラスのオブジェクトをその基本クラスのポインターに割り当てるポリモーフィズム トランスポート メカニズムとして使用しています。 これの主な用途は、 `Object`、たとえば、事前に汎用の CLR プログラミングの。 受動的に使用される、インターフェイスは抽象的すぎますを通常トランスポートと記憶域用に選択した基本クラスのポインターを提供します。 `Object`、たとえば、そのインターフェイスから 5 つのメソッドを提供します。具体的な動作が必要です、明示的なキャスト。 たとえば、スポット ライトの角度や消えるの速度を調整する場合になりますダウン キャストを明示的に。 その多くの子のすべての可能なメソッドのスーパー セットであることのサブ型ファミリ内の仮想インターフェイスは実行不可能、オブジェクト指向言語内ではそのためするダウン キャスト機能が必要常に。

安全なキャスト理由でした時間がかかる C++ いずれかに追加し、オブジェクト指向言語で機能が必要か。 問題は、ポインターの実行時の型に関する情報を使用できるようにする方法です。 仮想関数の場合、実行時情報を設定する 2 つの部分で、コンパイラによって。

- クラス オブジェクトにはメンバー ポインターに追加の仮想テーブルにはが含まれています (先頭またはクラスのオブジェクトの末尾にいずれかの興味深い歴史をそれ自体が)、該当する仮想テーブルを解決します。 スポット ライトの仮想テーブルを指向性光、指向性光仮想テーブル、および具合のスポット ライト オブジェクトのアドレスなど

- 各仮想関数が関連付けられている固定の表に、スロットと実際のインスタンスを呼び出すが、テーブル内で格納されているアドレスで表されます。 たとえば、仮想`Light`スロット 0 の場合に関連するデストラクター`Color`スロット 1 とにします。 これは、コンパイル時に設定して、最小限のオーバーヘッドを表すために、柔軟性に欠ける場合に効率的な戦略です。

2 番目のアドレスを追加するか、なんらかの種類のエンコードを直接追加することで、C++ ポインターのサイズを変更せずに型情報をポインターを使用できるようにする方法を次が問題です。 プログラマ (およびプログラム) を許容しないなりますいた主要なユーザー コミュニティではまだオブジェクト指向パラダイム - を使用しないことを決定します。 ポリモーフィックなクラス型に特殊なポインターを導入する可能性もあることでしたが、これは混乱を招くポインターの算術演算の問題では特に、2 つを混合するが困難します。 しないでしょうを現在関連付けられている型では、動的に更新することと各ポインターを関連付ける実行時のテーブルを維持するために許容されます。

問題は、異なるが、正当なプログラムに対してな願望があるユーザー コミュニティのペアです。 ソリューション、願望、相互運用機能のだけでなく、2 つのコミュニティのセキュリティ侵害にします。 つまり、いずれかの側によって提供されるソリューションが実現できない可能性があることと、ソリューションは完璧なを最後に実装します。 実際の解像度がポリモーフィックなクラスの定義を中心: ポリモーフィックなクラスは、いずれかの仮想関数が含まれています。 ポリモーフィックなクラスは、動的なタイプ セーフのダウン キャストをサポートします。 すべてのポリモーフィックなクラスに対応する仮想テーブルには、その追加ポインター メンバーが含まれているために、管理から、ポインター-と-アドレスの問題が解決しました。 そのため、関連付けられている型は、展開された仮想テーブル構造に格納できます。 タイプ セーフなキャストのコストは、(ほぼ) 機能のユーザーにローカライズされます。

タイプ セーフなダウン キャストでは、次の問題では、その構文はでした。 キャストのため、ISO C 委員会に元の提案は、この例のように、非キャスト構文を使用しました。

```
spot = ( SpotLight* ) plight;
```

これによって拒否されました、委員会のキャストのコストを制御するユーザーが許可されませんでした。 動的なタイプ セーフなキャストがある同じ構文以前は安全では、静的キャスト表記で代替になり、ユーザーには、不要で、コストがかかりすぎる場合に、実行時にオーバーヘッドを抑えることがありません。

一般に、C++ では、常に、メカニズムはコンパイラでサポートされる機能を非表示に使用します。 たとえば、クラス スコープ演算子を使用して仮想機構無効にできます (`Box::rotate(angle)`) クラスのオブジェクト (ではなくポインターまたは参照をそのクラスの) 経由で仮想メソッドを呼び出すことによりします。 後者の抑制言語では必要ありませんが、品質の実装の問題、一時的な形式の宣言での構築の抑制に似ています。

```
// compilers are free to optimize away the temporary
X x = X::X( 10 );
```

こうして、提案されたについてさらに検討といくつかの代替表記されたと見なされます、委員会に戻ることの 1 つは、フォームが (`?type`)、その未確定 - が示される動的な性質は、します。 静的または動的な-は、2 つの形式の間で切り替えることで、ユーザーを付けたこれが、だれにも満足でした。 描画ボードに戻るためです。 3 番目と成功した表記は、ここで標準`dynamic_cast<type>`、4 つの新しいスタイルのキャスト表記のセットに一般化するがします。

ISO C に`dynamic_cast`を返します`0`、不適切なポインター型に適用され、スロー、`std::bad_cast`例外参照型に適用するとします。 C++ マネージ拡張で適用する`dynamic_cast`常に返されます (ポインター表現) のためのマネージ参照型に`0`します。 `__try_cast<type>` アナログのバリアントをスローする例外に導入された、`dynamic_cast`がスローされる点を除き、`System::InvalidCastException`キャストに失敗した場合。

```
public __gc class ItemVerb;
public __gc class ItemVerbCollection {
public:
   ItemVerb *EnsureVerbArray() [] {
      return __try_cast<ItemVerb *[]>
         (verbList->ToArray(__typeof(ItemVerb *)));
   }
};
```

新しい構文で`__try_cast`として再キャストされました`safe_cast`します。 新しい構文では、同一のコード フラグメントを示します。

```
public ref class ItemVerb;
public ref class ItemVerbCollection {
public:
   array<ItemVerb^>^ EnsureVerbArray() {
      return safe_cast<array<ItemVerb^>^>
         ( verbList->ToArray( ItemVerb::typeid ));
   }
};
```

管理対象の世界では、コードを検証できないままにするための方法で型の間でキャストするプログラマの能力を制限することで検証可能なコードを許可する必要があります。 これは、新しい構文で表される、動的プログラミング パラダイムの重要な側面です。 このため、古いスタイルのキャストのインスタンスが再キャスト内部的に実行時のキャスト、としてようにする例については。

```
// internally recast into the
// equivalent safe_cast expression above
( array<ItemVerb^>^ ) verbList->ToArray( ItemVerb::typeid );
```

その一方で、ポリモーフィズムは、アクティブとパッシブ モードの両方を提供するため、サブタイプの非仮想 API にアクセスするだけのダウン キャストを実行する必要があります。 これが発生することができます、たとえば、クラスのメンバーにする必要があるアドレス任意 (パッシブ ポリモーフィズム トランスポート メカニズムとして)、階層内の入力が特定のプログラム コンテキスト内で実際のインスタンスの既知の。 この場合は、キャストの実行時チェックは、許容できないオーバーヘッドを指定できます。 コンパイル時のための手段を提供するプログラミング言語の管理されたシステムとして機能する新しい構文がある場合 (つまり、静的な) ダウン キャスト。 理由のアプリケーション、`static_cast`表記がダウン キャスト コンパイル時の状態を維持できます。

```
// ok: cast performed at compile-time.
// No run-time check for type correctness
static_cast< array<ItemVerb^>^>(verbList->ToArray(ItemVerb::typeid));
```

問題は、プログラマを実行することを保証する方法がないこと、`static_cast`が正しく、理由の 1 つです。 つまり、マネージ コードと検証可能であるを強制する方法はありません。 これはネイティブ下よりも、プログラムの動的パラダイムでより緊急の問題ですが、プログラミング言語、ユーザーの禁止を静的と実行時のキャストを切り替える機能をシステム内では不十分です。

ただし、パフォーマンスの点と、新しい構文で落とし穴があります。 ネイティブのプログラミングで古いスタイルのキャスト表記と新しいスタイルのパフォーマンスの違いはありません`static_cast`表記します。 しかし、新しい構文では、古いスタイルのキャスト表記は、新しいスタイルを使用するよりも大幅に高く`static_cast`表記します。 理由は、コンパイラは、例外をスローする実行時チェックに古いスタイルの表記の使用を内部的に変換します。 さらも変更コードの実行プロファイル - 賢明でおそらく、アプリケーションをキャッチされない例外が発生するが、ユーザーは場合は、同じエラーにはその例外は発生しませんので、`static_cast`表記を使用します。 これによって、ユーザーに新しいスタイルの表記を使用する駆り立てると思えるかもしれません。 に失敗したときにのみが、なぜ、表示を理解せず実行パフォーマンスが著しく低下する古いスタイルの表記を使用するプログラムを原因がそれ以外の場合、次の C プログラマの落とし穴に似ています。

```
// pitfall # 1:
// initialization can remove a temporary class object,
// assignment cannot
Matrix m;
m = another_matrix;

// pitfall # 2: declaration of class objects far from their use
Matrix m( 2000, 2000 ), n( 2000, 2000 );
if ( ! mumble ) return;
```

## <a name="see-also"></a>関連項目

[言語の変更の概要 (C++/CLI)](../dotnet/general-language-changes-cpp-cli.md)<br/>
[C スタイル キャストと/clr (C +/cli CLI)](../windows/c-style-casts-with-clr-cpp-cli.md)<br/>
[safe_cast](../windows/safe-cast-cpp-component-extensions.md)