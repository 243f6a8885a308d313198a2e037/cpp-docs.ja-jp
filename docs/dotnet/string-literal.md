---
title: "リテラル文字列 |Microsoft ドキュメント"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
helpviewer_keywords:
- string literals
- strings [C++], string literals
ms.assetid: 6d1fc3f8-0d58-4d68-9678-16b4f6dc4766
caps.latest.revision: "8"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- cplusplus
- dotnet
ms.openlocfilehash: dd62f85b87473d1371daf2d2fa009d8620e59b57
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/21/2017
---
# <a name="string-literal"></a>リテラル文字列
リテラル文字列の処理は、Visual C を c++ マネージ拡張から変更されました。  
  
 C++ 言語のデザインのマネージ拡張で、管理対象の文字列リテラルとリテラル文字列の先頭で指定された、`S`です。 例:  
  
```  
String *ps1 = "hello";  
String *ps2 = S"goodbye";  
```  
  
 2 つの初期化のオーバーヘッド間のパフォーマンスはある重要な表現で使用して表示される次の CIL として**ildasm**:  
  
```  
// String *ps1 = "hello";  
ldsflda    valuetype $ArrayType$0xd61117dd  
     modopt([Microsoft.VisualC]Microsoft.VisualC.IsConstModifier)   
     '?A0xbdde7aca.unnamed-global-0'  
  
newobj instance void [mscorlib]System.String::.ctor(int8*)  
stloc.0  
  
// String *ps2 = S"goodbye";  
ldstr      "goodbye"  
stloc.0  
```  
  
 れている助かりますだけ記憶 (学習) とプレフィックスのリテラル文字列の`S`です。 新しい構文ではリテラル文字列の処理が行われますに透明で、使用のコンテキストによって決まります。 `S`を指定する必要がなくなった。  
  
 についておが必要になる明示的にケースは、1 つの解釈または別のコンパイラを直接しますか。 このような場合は、明示的なキャストを適用します。 例:  
  
```  
f( safe_cast<String^>("ABC") );  
```  
  
 さらに、文字列リテラル対応、`String`標準変換ではなく、単純な変換とします。 このことがありますしないように思えるはるかを含むオーバー ロードされた関数のセットの解像度を変更中に、`String`と`const char*`競合する仮パラメーターとして。 1 回に解決する解像度、`const char*`インスタンスがあいまいとフラグが立てようになりました。 例:  
  
```  
ref struct R {  
   void f(const char*);  
   void f(String^);  
};  
  
int main () {  
   R r;  
   // old syntax: f( const char* );  
   // new syntax: error: ambiguous  
   r.f("ABC");   
}  
```  
  
 違いはなぜですか。 という名前の複数のインスタンスから`f`が存在する、プログラム内での呼び出しに適用する関数のオーバー ロード解決アルゴリズムが必要です。 オーバー ロード関数の仮引数の解決では、次の 3 つの手順があります。  
  
1.  候補関数のコレクション。 候補関数は、構文的に呼び出される関数の名前に一致するスコープ内でのこれらのメソッドです。 たとえば、`f()`のインスタンスを通じて呼び出された`R`、すべてという名前の関数`f`のメンバーではないこと`R`(またはその基本クラスの階層構造の) 候補関数ではありません。 この例では 2 つの候補関数があります。 これらの 2 つのメンバー関数は、`R`という`f`です。 呼び出しは、候補関数のセットが空の場合、このフェーズで失敗します。  
  
2.  候補関数の中から実行可能な関数のセット。 実行可能な関数は、いずれかの引数とその型の数を指定の呼び出しで指定された引数を指定して呼び出すことができます。 この例では両方候補関数も実行可能な関数です。 呼び出しは、実行可能な関数のセットが空の場合、このフェーズで失敗します。  
  
3.  呼び出しの最適な一致を表す関数を選択します。 これは、実行可能な関数のパラメーターの型の引数の変換を適用する変換を順位付けをします。 これは、1 つのパラメーターの関数では; で比較的簡単これは、複数のパラメーターがある場合に多少複雑になります。 呼び出しは、最適な一致項目が存在しない場合、このフェーズで失敗します。 つまり、仮パラメーターの型に実際の引数の型を変換する必要がある変換が同程度に優れた場合。 呼び出しがあいまいとフラグが付けられます。  
  
 マネージ拡張で呼び出されるこの呼び出しの解決、`const char*`最善の一致としてインスタンス。 一致するように必要な変換の新しい構文では`"abc"`に`const char*`と`String^`は同等では、同程度に優れた - ため、呼び出しが不適切な - としては、フラグが設定としてあいまいです。  
  
 2 つの質問になります。  
  
-   実際の引数の型は`"abc"`しますか?  
  
-   1 つの型変換が他よりも優れたときを判断するためのアルゴリズムとは何ですか。  
  
 文字列リテラルの型`"abc"`は`const char[4]`-ただしのすべての文字列の最後に、暗黙的な null 終端文字をリテラルがあります。  
  
 1 つの型変換が他よりも優れたときを判断するためのアルゴリズムには、階層内の可能な型変換を配置することが含まれます。 ここでについて理解するにはその階層でのこれらすべての変換です。 また、暗黙的なです。 階層と同様の方法をオーバーライドする明示的なキャスト表記を使用してかっこ式の通常の演算子の優先順位をオーバーライドします。  
  
1.  完全に一致するをお勧めします。 驚くほど、引数を正確に一致する、必要はありません。 パラメーターの型を完全に一致するには十分だけが必要です。 これは、この例では、言語が変更された方法で何が起こってについて理解するキーです。  
  
2.  プロモーションが標準の変換よりも向上します。 たとえば、昇格、`short int`を`int`への変換より優れていますが、`int`に、`double`です。  
  
3.  標準変換はボックス化変換より優れています。 たとえば、変換、`int`に、`double`は優れているボックス化、`int`に、`Object`です。  
  
4.  ボックス化変換は暗黙的なユーザー定義の変換より優れています。 たとえば、ボックス化、`int`に、`Object`の変換演算子を適用するよりもをお勧め、`SmallInt`クラスの値します。  
  
5.  暗黙的なユーザー定義変換は変換なしより優れています。 暗黙的なユーザー定義変換は、(仮引数の署名で param 配列またはその位置にある省略記号を含む可能性がある注意事項) を持つエラーの前に、最後の終了です。  
  
 そのため、何を意味して完全に一致する必ずしも正確に一致するものではないことにしますか。 たとえば、`const char[4]`は完全に一致しないか`const char*`または`String^`、この例のあいまいさが競合する 2 つの完全一致の間ではまだ!  
  
 完全に一致にはした場合でも単純変換の数が含まれています。 適用できるし、まだ完全に一致する条件を満たしている ISO-C++ に 4 つの単純変換があります。 3 つは、左辺値の変換と呼ばれます。 4 番目の型は、限定変換と呼ばれます。 3 つの左辺値の変換はより正確に一致よりも限定変換を必要とする 1 つとして扱われます。  
  
 左辺値変換の 1 つのフォームは、ネイティブ ポインターの配列に変換します。 これは、照合に新機能が含まれている、`const char[4]`に`const char*`です。 一致するものではそのため、`f("abc")`に`f(const char*)`完全に一致します。 この言語の初期の段階でこれが最適では、実際には。  
  
 コンパイラ フラグとして、あいまいな呼び出しをそのため、いる必要がありますの変換、`const char[4]`を`String^`単純変換を完全に一致があります。 これは、変更を新しい言語バージョンが導入されました。 これとは、呼び出しは、フラグが理由としてあいまいです。  
  
## <a name="see-also"></a>参照  
 [一般的な言語の変更 (C + + CLI)](../dotnet/general-language-changes-cpp-cli.md)   
 [String](../windows/string-cpp-component-extensions.md)