---
title: 文字列リテラル |Microsoft Docs
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-cli
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- string literals
- strings [C++], string literals
ms.assetid: 6d1fc3f8-0d58-4d68-9678-16b4f6dc4766
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
- dotnet
ms.openlocfilehash: 41f1996cd4f4caf24ac08d09b05e636cb09f7eed
ms.sourcegitcommit: 799f9b976623a375203ad8b2ad5147bd6a2212f0
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/19/2018
ms.locfileid: "46415266"
---
# <a name="string-literal"></a>リテラル文字列

リテラル文字列の処理は、Visual c の C++ マネージ拡張から変更されました。

文字列リテラルを付けること C++ 言語設計のマネージ拡張で指定された管理対象の文字列リテラル、`S`します。 例えば:

```
String *ps1 = "hello";
String *ps2 = S"goodbye";
```

2 つの初期化のオーバーヘッド間のパフォーマンスがある重要な答えは、表現で使用して表示される次の CIL として**ildasm**:

```
// String *ps1 = "hello";
ldsflda    valuetype $ArrayType$0xd61117dd
     modopt([Microsoft.VisualC]Microsoft.VisualC.IsConstModifier)
     '?A0xbdde7aca.unnamed-global-0'

newobj instance void [mscorlib]System.String::.ctor(int8*)
stloc.0

// String *ps2 = S"goodbye";
ldstr      "goodbye"
stloc.0
```

助かりますだけ記憶 (または learning) をリテラル文字列がある、`S`します。 新しい構文で文字列リテラルの処理は透明に、使用のコンテキストによって決まります。 `S`指定する必要はありません。

について私たちが必要になる明示的にする場合は、1 つの解釈または別のコンパイラを直接でしょうか。 このような場合は、明示的なキャストが適用されます。 例えば:

```
f( safe_cast<String^>("ABC") );
```

今すぐにリテラル文字列を一致するさらに、`String`標準変換ではなく、単純な変換を使用します。 この思うかもしれませんがずっとを含むオーバー ロードされた関数のセットの解像度を変更中に、`String`と`const char*`競合する仮パラメーターとして。 1 回に解決される解像度、`const char*`インスタンスがあいまいとフラグが設定ようになりました。 例えば:

```
ref struct R {
   void f(const char*);
   void f(String^);
};

int main () {
   R r;
   // old syntax: f( const char* );
   // new syntax: error: ambiguous
   r.f("ABC"); 
}
```

違いはなぜですか。 という名前の 1 つ以上のインスタンスから`f`が存在する、プログラム内での呼び出しに適用する関数のオーバー ロード解決アルゴリズムが必要です。 オーバー ロード関数の仮の解像度では、次の 3 つの手順があります。

1. 候補関数のコレクション。 候補関数は、スコープ内で呼び出される関数の名前を構文的に一致するこれらのメソッドです。 たとえば、`f()`がのインスタンスから呼び出される`R`すべて、という名前の関数`f`のメンバーではない`R`(またはその基本クラスの階層構造の) 候補関数ではありません。 この例では 2 つの候補関数があります。 これらの 2 つのメンバー関数は、`R`という`f`します。 呼び出しは、候補関数のセットが空の場合、このフェーズで失敗します。

1. 候補関数の中から実行可能な関数のセット。 実行可能な関数は、1 つの呼び出しで指定されて、引数とその型の数を指定された引数で呼び出すことができます。 この例で使用する両方の候補関数も実行可能な関数です。 呼び出しは、実行可能な関数のセットが空の場合、このフェーズで失敗します。

1. 呼び出しの最適な一致を表す関数を選択します。 これは、実行可能な関数のパラメーターの型に引数変換を適用する変換を順位付けを実行します。 これは、1 つのパラメーターの関数では; で比較的簡単これは、複数のパラメーターがある場合にやや複雑になります。 呼び出しは、最適な一致が存在しない場合、このフェーズで失敗します。 つまり、仮パラメーターの型に実際の引数の型を変換するために必要な変換が同等である場合。 呼び出しがあいまいとフラグが設定されます。

管理されている拡張機能は、この呼び出しが呼び出されるの解像度、`const char*`最善の一致のインスタンス。 新しい構文、一致するように必要な変換で`"abc"`に`const char*`と`String^`は同等では、同等のため、呼び出しが不良 - としては、フラグが設定あいまいとします。

2 つの質問に進みましょう。

- 実際の引数の型は`"abc"`でしょうか。

- 1 つの型変換が他よりも優れた場合を決定するためのアルゴリズムとは何ですか。

文字列リテラルの型`"abc"`は`const char[4]`-すべての文字列の最後に、暗黙的な null 終端文字があるリテラル注意してください。

1 つの型変換が他よりも優れた場合を決定するためのアルゴリズムでは、階層内の型変換を配置する必要があります。 ここでは、私の知る限り、その階層のこれらすべての変換です。 また、暗黙的な。 階層と同様の方法をオーバーライドする明示的なキャスト表記を使用してかっこ式の一般的な演算子の優先順位よりも優先されます。

1. 完全に一致するをお勧めします。 意外にも、引数を完全に一致するにする必要はありません、パラメーターの型と正確に一致十分が必要があります。 これは、この例では、言語が変更された方法で何が起こって理解するためのキーです。

1. プロモーションは標準の変換よりも優れています。 たとえば、昇格、`short int`を`int`変換よりも優れていますが、`int`に、`double`します。

1. ボックス化変換よりも、標準変換をお勧めします。 たとえば、変換、`int`に、`double`をお勧めするボックス化、`int`に、`Object`します。

1. ボックス化変換は暗黙的なユーザー定義の変換よりも優れています。 たとえば、ボックス化、`int`に、`Object`の変換演算子を適用するよりも優れていますが、`SmallInt`クラスの値します。

1. 暗黙的なユーザー定義変換がまったくない変換よりも優れています。 暗黙的なユーザー定義の変換は、(param 配列またはその位置にある省略記号に正式な署名が含まれますことに注意) してエラーの前に、最後の終了です。

そのため、これはどういう必ずしも正確に一致する厳密な一致ではないことを言うでしょうか。 たとえば、`const char[4]`は完全に一致しないか`const char*`または`String^`、競合する 2 つの正確な一致の間のコード例のあいまいさがまだと!

完全一致では、偶然ですが、単純変換数が含まれています。 適用できるし、まだ完全に一致する条件を満たしている ISO C の下の 4 つの単純変換があります。 3 つが、左辺値の変換と呼ばれます。 4 番目の型には、限定変換が呼び出されます。 左辺値の 3 つの変換より正確な一致よりも限定変換を必要とする 1 つとして扱われます。

左辺値の変換の 1 つの形式は、ネイティブ ポインターの配列に変換します。 これは、一致する手順、`const char[4]`に`const char*`します。 一致するものではそのため、`f("abc")`に`f(const char*)`正確に一致します。 この言語の初期の段階でこれは最適では、実際にです。

コンパイラと、あいまいな呼び出しにフラグを設定するため、する必要がありますの変換、`const char[4]`を`String^`も単純な変換によって完全に一致をします。 これは、変更を新しい言語バージョンが導入されています。 このため、呼び出しは、フラグがあいまいとします。

## <a name="see-also"></a>関連項目

[言語の変更の概要 (C++/CLI)](../dotnet/general-language-changes-cpp-cli.md)<br/>
[String](../windows/string-cpp-component-extensions.md)