---
title: 値の型のセマンティクス |Microsoft Docs
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-cli
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- interior_ptr keyword [C++]
- virtual functions, value types
- inheritance, value types
- pinning pointers
- pin_ptr keyword [C++]
- __pin keyword
ms.assetid: 7f065589-ad25-4850-baf1-985142e35e52
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
- dotnet
ms.openlocfilehash: 72dc6a613616d13e9ff92e8af0c39c63dfe63162
ms.sourcegitcommit: 799f9b976623a375203ad8b2ad5147bd6a2212f0
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/19/2018
ms.locfileid: "46413797"
---
# <a name="value-type-semantics"></a>値型セマンティクス

値型のセマンティクスは、Visual C に C++ のマネージ拡張から変更されました。

C++ 仕様のマネージ拡張で使用される標準的な値の型を次に示します。

```
__value struct V { int i; };
__gc struct R { V vr; };
```

マネージ拡張であっても、値の型の 4 つの構文バリアント (2 および 3 のフォームが同じである意味)。

```
V v = { 0 };       // Form (1)
V *pv = 0;         // Form (2) an implicit form of (3)
V __gc *pvgc = 0;  // Form (3)
__box V* pvbx = 0; // Form (4) must be local
```

## <a name="invoking-inherited-virtual-methods"></a>継承された仮想メソッドの呼び出し

`Form (1)` 標準の値オブジェクトは、ことがよく理解されて、継承された仮想メソッドを呼び出すように試行する場合を除く`ToString()`します。 例えば:

```
v.ToString(); // error!
```

がオーバーライドされていないため、このメソッドを呼び出すために`V`コンパイラは、基底クラスの関連付けられている仮想テーブルへのアクセスが必要です。 値の型は仮想テーブル (vptr) に関連付けられているポインターを持たない状態での記憶域であるため、このことが必要`v`ボックス化します。 マネージ拡張言語の設計で暗黙的なボックス化はサポートされていませんがする必要があります明示的に指定する、プログラマとしての

```
__box( v )->ToString(); // Managed Extensions: note the arrow
```

この設計背後のプライマリは教育: メカニズムを基になる 'コスト' のインスタンスが提供されないのあるので、プログラマに表示される必要があります。 `V`のインスタンスを格納する`ToString`、ボックス化する必要はありません。

新しい構文では、自体には、ボックス化の基になるコストされませんが、オブジェクトを明示的にボックス化の構文の複雑さが削除されます。

```
v.ToString(); // new syntax
```

コストの明示的なインスタンスを提供しないか、クラス デザイナーは誤解を招く可能性がありますが、`ToString`メソッド内で`V`します。 ため、暗黙的なボックス化よりも優先されますが、通常は 1 つのクラス デザイナーが、ある無制限の数を自由に変更が、先のいずれも、ユーザーの`V`煩わしいの明示的なボックスを排除します。

インスタンスをオーバーライドするかどうかを決定する条件`ToString`頻度とその使用の場所、値内でクラスになります。 ごくまれには、呼び出された場合、その定義でほとんどメリットはもちろんありません。 同様に、アプリケーションの非効率領域でそれを呼び出すと、追加してある程度までもありませんに追加されます、アプリケーションの全般的なパフォーマンス。 代わりに、追跡ハンドルからボックス化された値を保持でき、ハンドルが呼び出しでは、ボックス化は必要はありません。

## <a name="there-is-no-longer-a-value-class-default-constructor"></a>値クラスの既定のコンス トラクターはありません。

マネージ拡張と、新しい構文の値型を持つ別の相違点は、既定のコンス トラクターに対するサポートの廃止です。 CLR が関連付けられている既定のコンス トラクターを呼び出さずに値型のインスタンスを作成できる実行中に状況があるためにです。 つまり、値型の中で、既定のコンス トラクターをサポートするために、マネージ拡張で試行でした実際面では保証されません。 保証がないを指定するには、最初のアプリケーションで決定的にすることができますのではなく、サポートを廃止する方がよいこと感じます。

初期状態思わほどではありません。 これは、値型の各オブジェクトが自動的にゼロ クリアため (つまり、各型からの既定値に初期化されます)。 その結果、ローカル インスタンスのメンバーでは、未定義はできません。 この意味で自明な既定のコンス トラクターを定義する機能の損失は本当にではありませんが失われる - と、実際には、CLR によって実行されるときより効率的です。

問題は、マネージ拡張のユーザーが自明でない既定のコンス トラクターを定義する場合です。 新しい構文へのマッピングがありません。 コンス トラクター内のコードは、ユーザーが明示的に呼び出す必要のある名前付きの初期化メソッドに移行する必要があります。

新しい構文内で値型のオブジェクトの宣言は、それ以外の場合変更されません。 これの欠点は、次の理由で値型はネイティブ型の折り返しの満足でないことは。

- 値型のデストラクターのサポートはありません。 つまり、一連のオブジェクトの有効期間の終了によってトリガーされるアクションを自動化する方法はありません。

- ネイティブ クラスは、ネイティブ ヒープに割り当てられる次のポインターとしてマネージ型内でのみに含まれることができます。

今回は値型ではなく、参照型、double のヒープ割り当てを回避するためにで小規模なネイティブ クラスをラップする: ネイティブの型を保持するために、ネイティブ ヒープおよびマネージ ラッパーを保持するために、CLR ヒープ。 ネイティブ クラスを値型をラッピングは、マネージ ヒープを回避することができますが、ネイティブ ヒープ メモリの解放を自動化する方法は提供されません。 参照型は、重要なネイティブ クラスをラップする実際的なマネージ型です。

## <a name="interior-pointers"></a>内部ポインター

`Form (2)` `Form (3)`上記のほとんどすべてをアドレスこの世界に (つまり、何もマネージまたはネイティブ) [次へ]。 そのため、たとえば、次のすべてはマネージ拡張で許可されます。

```
__value struct V { int i; };
__gc struct R { V vr; };

V v = { 0 };  // Form (1)
V *pv = 0;  // Form (2)
V __gc *pvgc = 0;  // Form (3)
__box V* pvbx = 0;  // Form (4)

R* r;

pv = &v;            // address a value type on the stack
pv = __nogc new V;  // address a value type on native heap
pv = pvgc;          // we are not sure what this addresses
pv = pvbx;          // address a boxed value type on managed heap
pv = &r->vr;        // an interior pointer to value type within a
                    //    reference type on the managed heap
```

そのため、`V*`ローカル ブロック内の場所に対処できます (およびそのため、ぶら下がりことができます)、ネイティブ内のグローバル スコープで (たとえば、アドレス、オブジェクトが既に削除されている場合)、CLR ヒープ内のヒープ (およびしたがってが追跡される場合は、する必要があります再配置するガベージ コレクション中に)、および (内部ポインターの場合、これが呼び出されると、透過的にも追跡されます)、CLR ヒープ上の参照オブジェクトの内部にします。

マネージ拡張でのネイティブな側面を分離する方法はありません、 `V*`; は、扱われます、包括的にオブジェクトまたはサブオブジェクトは、マネージ ヒープでアドレス指定可能性を処理します。

新しい構文では、値型のポインターが 2 つの型にファクタリングされます: `V*`、非 CLR ヒープの場所、および内部のポインターに限定される`interior_ptr<V>`、できますが、マネージ ヒープ内のアドレスは必要ありません。

```
// may not address within managed heap
V *pv = 0;

// may or may not address within managed heap
interior_ptr<V> pvgc = nullptr;
```

`Form (2)` `Form (3)`にマップするマネージ拡張の`interior_ptr<V>`します。 `Form (4)` 追跡ハンドルです。 マネージ ヒープ内にボックス化されているオブジェクト全体に対応します。 新しい構文で変換されます、 `V^`、

```
V^ pvbx = nullptr; // __box V* pvbx = 0;
```

新しい構文では内部ポインターにすべてマップ マネージ拡張で、次の宣言。 (内で値型では、`System`名前空間)。

```
Int32 *pi;   // => interior_ptr<Int32> pi;
Boolean *pb; // => interior_ptr<Boolean> pb;
E *pe;       // => interior_ptr<E> pe; // Enumeration
```

組み込みの型が、内の型をエイリアスとして機能するマネージ型は、考慮されません、`System`名前空間。 したがって、次のマッピングは、マネージ拡張と、新しい構文の当てはまります。

```
int * pi;     // => int* pi;
int __gc * pi2; // => interior_ptr<int> pi2;
```

変換するときに、 `V*` 、既存のプログラムで、最も保守的な戦略が常に有効にするのには、`interior_ptr<V>`します。 これは、マネージ拡張での処理方法です。 新しい構文では、プログラマはヒープの管理対象外のアドレスを指定することで値の型を制限するオプション`V*`内部ポインターではなく。 プログラムの変換では、そのすべての使用の推移的終了を行うし、割り当てられたアドレスが、マネージ ヒープ内に存在する場合、終了し、として`V*`は問題ありません。

## <a name="pinning-pointers"></a>固定ポインター

ガベージ コレクターは、圧縮フェーズ中には、通常、ヒープ内の別の場所に、CLR ヒープ上に存在するオブジェクトを必要に応じて移動可能性があります。 この移動はハンドルや追跡参照では、これらのエンティティを透過的に更新する内部ポインターを追跡する問題ではありません。 ユーザーが、ランタイム環境の外部で CLR ヒープのオブジェクトのアドレスを渡された場合は、ただし、問題はこの移動です。 ここでは、揮発性オブジェクトの移動はランタイム エラーが発生する可能性があります。 外部使用量のそれぞれの場所に固定する必要がある、移動されるようオブジェクトを除外します。

マネージ拡張で、*固定ポインター*とポインター宣言を修飾することにより宣言は、`__pin`キーワード。 マネージ拡張仕様を少し変更した例を次に示します。

```
__gc struct H { int j; };

int main()
{
   H * h = new H;
   int __pin * k = & h -> j;

   // ...
};
```

新しい言語の設計で固定ポインターは、内部ポインターに似た構文を使用して宣言されます。

```
ref struct H
{
public:
   int j;
};

int main()
{
   H^ h = gcnew H;
   pin_ptr<int> k = &h->j;

   // ...
}
```

新しい構文では、固定ポインターは、内部ポインターの特殊なケースです。 固定ポインターの元の制約が残ります。 たとえば、パラメーターとして使用することはできませんや; メソッドの型を返すこれは、ローカル オブジェクトでのみ宣言できます。 ただし、さまざまな追加の制約の場合は、新しい構文で追加されましたが。

固定ポインターの既定値は`nullptr`ではなく、`0`します。 A`pin_ptr<>`初期化するか、または割り当てられていることはできません`0`します。 すべての割り当ての`0`既存のコードでに変更する必要があります`nullptr`します。

マネージ拡張で固定ポインターは、マネージ拡張仕様から引用した次の例のように、オブジェクト全体に対処する許可でした。

```
__gc class G {
public:
   void incr(int* pi) { pi += 1; }
};
__gc struct H { int j; };
void f( G * g ) {
   H __pin * pH = new H;
   g->incr(& pH -> j);
};
```

新しい構文ではオブジェクト全体をピン留めによって返される、`new`式はサポートされていません。 代わりに、内部メンバーのアドレスを固定する必要があります。 たとえば、オブジェクトに適用された

```
ref class G {
public:
   void incr(int* pi) { *pi += 1; }
};
ref struct H { int j; };
void f( G^ g ) {
   H ^ph = gcnew H;
   Console::WriteLine(ph->j);
   pin_ptr<int> pj = &ph->j;
   g->incr(  pj );
   Console::WriteLine(ph->j);
}
```

## <a name="see-also"></a>関連項目

[値型とその動作 (C++/CLI)](../dotnet/value-types-and-their-behaviors-cpp-cli.md)<br/>
[クラスと構造体](../windows/classes-and-structs-cpp-component-extensions.md)<br/>
[interior_ptr (C++/CLI)](../windows/interior-ptr-cpp-cli.md)<br/>
[pin_ptr (C++/CLI)](../windows/pin-ptr-cpp-cli.md)