---
title: "Visual C のジェネリックの概要 |Microsoft ドキュメント"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-windows
ms.tgt_pltfrm: 
ms.topic: language-reference
dev_langs: C++
helpviewer_keywords:
- generics [C++], about generics
- default initializers [C++]
- type parameters [C++]
- constructed types
- type arguments [C++]
- constructed types, open [C++]
- open constructed types [C++]
- constructed types, closed [C++]
ms.assetid: 21f10637-0fce-4916-b925-6c86a126d3aa
caps.latest.revision: "21"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- cplusplus
- uwp
ms.openlocfilehash: 5082f603c64e796ef369044e3586ae5bfe85605a
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/21/2017
---
# <a name="overview-of-generics-in-visual-c"></a>Visual C++ のジェネリックの概要
ジェネリックは、共通言語ランタイムでサポートされているパラメーター化された型です。 パラメーター化された型は、ジェネリックを使用する場合に指定されている不明な型パラメーターで定義されている型です。  
  
## <a name="why-generics"></a>なぜジェネリックしますか?  
 ジェネリック型指定されたコレクション クラスを作成するパラメーター化された型のサポートを C++ テンプレートと両方のテンプレートのサポートします。 ただし、テンプレートは、コンパイル時のパラメーター化を提供します。 テンプレートの定義を含むアセンブリを参照およびテンプレートの特殊化の新しいを作成できません。 コンパイルされる、特殊化されたテンプレートは、その他のクラスまたはメソッドのようになります。 これに対し、ジェネリックでは出力 MSIL をパラメーター化された型以外に、ランタイムによって把握されているパラメーター化された型としてジェネリック型を含むアセンブリを参照するソース コードでは、ジェネリック型の特殊化を作成できます。 Visual C のテンプレートとジェネリックの比較の詳細については、次を参照してください。[ジェネリックとテンプレート (Visual c)](../windows/generics-and-templates-visual-cpp.md)です。  
  
## <a name="generic-functions-and-types"></a>汎用的な機能と型  
 クラス型として、マネージ型は、ジェネリックで可能性があります。 この例があります、`List`クラスです。 リスト内のオブジェクトの種類は、型パラメーターになります。 必要がある場合、`List`ジェネリックを使用した前に、オブジェクトのさまざまな種類のクラス、`List`を受け取る**system::object**項目の種類として。 リストで使用する (正しくない型のオブジェクトを含む) 任意のオブジェクトはできます。 この一覧には、型指定されていないコレクション クラスが呼び出されます。 最高で実行時に種類を確認し、例外をスローする可能性があります。 または、アセンブリに 1 回コンパイルの一般的な品質を失いますテンプレートを使用した可能性があります。 アセンブリのコンシューマーは、テンプレートの独自の特殊化を作成できませんでした。 ジェネリックでは、たとえば、型指定されたコレクション クラスを作成できます`List<int>`("int 型の一覧"として読み取り) と`List<double>`"("の一覧倍)、型指定されたにそのまま使用するように設計されたコレクション型を配置しようとしています。 コンパイル時エラーが生成するいない。コレクションです。 さらは、コンパイル後は、これらの型もジェネリックできます。  
  
 ジェネリック クラスの構文の説明は、「[ジェネリック クラス (C + + CLI)](../windows/generic-classes-cpp-cli.md) `.`新しい名前空間、 <xref:System.Collections.Generic>、パラメーター化されたコレクションを含む型のセット導入<xref:System.Collections.Generic.Dictionary%602>、 <xref:System.Collections.Generic.List%601>と<xref:System.Collections.Generic.LinkedList%601>です。  
  
 両方のインスタンスと静的クラス メンバー関数、デリゲート、およびグローバル関数もありますジェネリックです。 関数のパラメーターが、不明な種類の場合、または関数自体がジェネリック型を扱う必要があります、汎用的な機能が必要な可能性があります。 多くの場合、 **system::object**使用されていた可能性、不明なオブジェクトの種類のパラメーターとして以前は、ジェネリック型パラメーター可能性があります使用する代わりに、複数のタイプ セーフ コードのことができます。 関数の仕様になっていない型で渡すしようとすると、フラグが設定されますエラー コンパイル時にします。 使用して**system::object**関数のパラメーターでは、不注意に渡すこととして、オブジェクトの関数のされなかったに対処するものであるが検出されないとに特定の型に不明なオブジェクト型にキャストする必要があります、関数本体と、invalidcastexception が発生する可能性のアカウントです。 ジェネリック、オブジェクトを関数に渡そうとコードが発生することは競合する型ため、関数の本体は型が正しいことを保証します。  
  
 同様の利点は、ジェネリック上に構築されたコレクション クラスに適用されます。 過去のコレクション クラスを使用して、 **system::object**をコレクションに要素を格納します。 コレクションはのないように設計された型のオブジェクトの挿入がいないフラグが設定し、コンパイル時に、多くの場合、オブジェクトが挿入されたときにも表示されません。 通常、コレクション内でアクセスされた場合は、オブジェクトを別の型にキャストは。 キャストが失敗した場合だけは予期しない型検出します。 ジェネリックでは、コンパイル時にこの問題を解決が一致しません (または暗黙的に変換) する型を挿入するすべてのコードを検出することにより、ジェネリック コレクションの型パラメーターです。  
  
 詳細については、構文を参照してください。[ジェネリック関数 (C + + CLI)](../windows/generic-functions-cpp-cli.md)です。  
  
## <a name="terminology-used-with-generics"></a>ジェネリックを使用する用語  
  
##### <a name="type-parameters"></a>型パラメーター  
 ジェネリック宣言と呼ばれる 1 つまたは複数の不明な型が含まれています。*パラメーター入力*です。 型パラメーターには、ジェネリック宣言の本体の種類の名前が与えられます。 型パラメーターはジェネリック宣言の本体の種類として使用します。 一覧については、ジェネリック宣言 < T\> t です型パラメーターが含まれています。  
  
##### <a name="type-arguments"></a>型引数  
 *引数を入力*ジェネリックが特定の型または型に特化したときに、型パラメーターの代わりに使用される実際の型です。 たとえば、`int`の型引数には、`List<int>`です。 値型とハンドル型には、ジェネリック型引数としての許可のみの種類です。  
  
##### <a name="constructed-type"></a>構築された型  
 ジェネリック型から構築された型と呼びます、*構築型*です。 完全には、指定した型など`List<T>`は、*オープン構築型*以外の場合は完全に、指定した型など、`List<double>,`は、*クローズ構築型*または*型を特殊化*. オープン構築型では、他のジェネリック型またはメソッドの定義で使用される可能性があり、完全に指定できません、包含ジェネリックはそれ自体が指定されるまでです。 たとえば、オープン構築型のジェネリック型の基底クラスとしての使用は、次のように。  
  
 `// generics_overview.cpp`  
  
 `// compile with: /clr /c`  
  
 `generic <typename T>`  
  
 `ref class List {};`  
  
 `generic <typename T>`  
  
 `ref class Queue : public List<T> {};`  
  
##### <a name="constraint"></a>制約  
 制約とは、型パラメーターとして使用できる型に制限します。 たとえば、指定されたジェネリック クラスは、指定したクラスから継承するクラスのみを受け入れるまたは指定されたインターフェイスを実装します。 詳細については、次を参照してください。[ジェネリック型パラメーターの制約 (C + + CLI)](../windows/constraints-on-generic-type-parameters-cpp-cli.md)です。  
  
## <a name="reference-types-and-value-types"></a>参照型と値の型  
 ハンドル型と値型は、型引数として使用可能性があります。 入力するかを使用することがあります、ジェネリックの定義構文では参照型のことです。 たとえば、  **->** 演算子を使用して、最終的に使用された型が参照型または値型かどうか、型パラメーターの型のメンバーにアクセスします。 値の型は、型引数として使用すると、ランタイムは値の型をボックス化せずに直接値の型を使用するコードを生成します。  
  
 参照型をジェネリック型引数として使用する場合は、ハンドルの構文を使用します。 値の型をジェネリック型引数として使用する場合は、型の名前を直接使用します。  
  
 `// generics_overview_2.cpp`  
  
 `// compile with: /clr`  
  
 `generic <typename T>`  
  
 `ref class GenericType {};`  
  
 `ref class ReferenceType {};`  
  
 `value struct ValueType {};`  
  
 `int main() {`  
  
 `GenericType<ReferenceType^> x;`  
  
 `GenericType<ValueType> y;`  
  
 `}`  
  
## <a name="type-parameters"></a>型パラメーター  
 ジェネリック クラスの型パラメーターは、その他の識別子のように扱われます。 ただし、型を認識していないためには、使用に関する制限します。 たとえば、これらのメンバーをサポートするために、型パラメーターがわかっている場合を除き、メンバーと型パラメーターのクラスのメソッドを使用できません。 メンバー、型パラメーターを使用してアクセスするには、型パラメーターの制約リストにメンバーを含む型を追加する必要があります。  
  
 `// generics_overview_3.cpp`  
  
 `// compile with: /clr`  
  
```  
interface class I {  
   void f1();  
   void f2();  
};  
  
ref struct R : public I {  
   virtual void f1() {}  
   virtual void f2() {}   
   virtual void f3() {}   
};  
  
generic <typename T>  
where T : I  
void f(T t) {  
   t->f1();  
   t->f2();  
   safe_cast<R^>(t)->f3();  
}  
  
int main() {  
   f(gcnew R());  
}  
```  
  
 これらの制限は、同様の演算子に適用されます。 制約のないジェネリック型パラメーターを使用することはできません、`==`と`!=`型がこれらの演算子をサポートしていない場合は、型パラメーターの 2 つのインスタンスを比較する演算子です。 これらのチェックは、ジェネリックのために必要ですが、テンプレートではなく実行時のすべてのクラスを使用、ジェネリックを特殊化することがありますのでを満たす、制約とは遅すぎますの無効なメンバーの使用を確認します。  
  
 使用して、型パラメーターの既定のインスタンスを作成する場合があります、`()`演算子。 例:  
  
 `T t = T();`  
  
 ここで`T`ジェネリック クラスまたはメソッドの定義の型パラメーターは、既定値に変数を初期化します。 場合`T`場合は null ポインターがなります、ref クラスは、`T`値クラス、オブジェクトは、ゼロに初期化します。 これと呼ばれる、*既定の初期化子*です。  
  
## <a name="see-also"></a>参照  
 [ジェネリック](../windows/generics-cpp-component-extensions.md)