---
title: Visual C のジェネリックの概要 |Microsoft Docs
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-windows
ms.topic: reference
dev_langs:
- C++
helpviewer_keywords:
- generics [C++], about generics
- default initializers [C++]
- type parameters [C++]
- constructed types
- type arguments [C++]
- constructed types, open [C++]
- open constructed types [C++]
- constructed types, closed [C++]
ms.assetid: 21f10637-0fce-4916-b925-6c86a126d3aa
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
- uwp
ms.openlocfilehash: 6503898f492fb3b16b0c6b4381075fabee530152
ms.sourcegitcommit: 4586bfc32d8bc37ab08b24816d7fad5df709bfa3
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/07/2018
ms.locfileid: "39608577"
---
# <a name="overview-of-generics-in-visual-c"></a>Visual C++ のジェネリックの概要
ジェネリックは、共通言語ランタイムでサポートされているパラメーター化された型です。 パラメーター化された型は、ジェネリックを使用する場合に指定されている不明な型パラメーターで定義されている型です。  
  
## <a name="why-generics"></a>なぜジェネリックでしょうか。  
 ジェネリック型指定されたコレクション クラスを作成するパラメーター化された型のサポートを C++ テンプレートと両方のテンプレートのサポートします。 ただし、テンプレートは、コンパイル時のパラメーター化を提供します。 テンプレート定義を含むアセンブリを参照し、テンプレートの特殊化を新しいを作成できません。 コンパイルされると、完了すると、特殊化されたテンプレートは他のクラスまたはメソッドのようになります。 パラメーター化された型; に、ランタイムによって認識されているパラメーター化された型としてジェネリックが msil 出力これに対し、ジェネリック型を含むアセンブリを参照しているソース コードは、ジェネリック型の特殊化を作成できます。 Visual C のテンプレートとジェネリックの比較の詳細については、次を参照してください。[ジェネリックとテンプレート (Visual c)](../windows/generics-and-templates-visual-cpp.md)します。  
  
## <a name="generic-functions-and-types"></a>ジェネリック関数と型  
 クラスの型、管理対象の型としてジェネリックで可能性があります。 この例があります、`List`クラス。 リスト内のオブジェクトの型は、型パラメーターになります。 必要がある場合、`List`ジェネリックを使用していたより前に、のオブジェクトのさまざまな種類のクラス、`List`を受け取る`System::Object`項目の型として。 リストで使用する (間違った型のオブジェクトを含む) 任意のオブジェクトを可能にします。 この一覧には、型指定されていないコレクション クラスを呼び出すは。 せいぜい、実行時に型を確認し、例外をスローする可能性があります。 または、テンプレート、失う可能性がアセンブリに 1 回コンパイルの一般的な品質を使用した可能性があります。 アセンブリのコンシューマーは、独自の特殊化のテンプレートを作成できませんでした。 ジェネリックでは、たとえば、型指定されたコレクション クラスを作成できます`List<int>`(int の"リスト"として読み取り) と`List<double>`("List 二重") に型指定されたそのまま使用するもので、コレクション型にしようとした、コンパイル時エラーが生成されるありません。コレクションです。 さらは、コンパイル後は、これらの型もジェネリック。  
  
 ジェネリック クラスの構文の説明が存在する可能性があります[ジェネリック クラス (C +/cli CLI)](../windows/generic-classes-cpp-cli.md)します。 新しい名前空間を<xref:System.Collections.Generic>を含むパラメーター化されたコレクションの種類のセットが導入されています<xref:System.Collections.Generic.Dictionary%602>、<xref:System.Collections.Generic.List%601>と<xref:System.Collections.Generic.LinkedList%601>します。  
  
 両方のインスタンスと静的クラス メンバー関数、デリゲート、およびグローバル関数をジェネリックあります。 ジェネリック関数は、関数のパラメーターが不明な型である場合、または、関数自体は、ジェネリック型を使用する必要があります、ために必要なことがあります。 多くの場合、`System::Object`使用されている可能性が不明なオブジェクトの種類のパラメーターとして以前は、ジェネリック型パラメーター可能性があります使用する代わりに、さらに、タイプ セーフ コードのことができます。 しようとすると、関数の仕様になっていない型で渡すには、コンパイル時にエラーとしてフラグが。 使用して`System::Object`不注意に渡すことで、関数パラメーターとしてオブジェクトの関数は、処理する意図しないは検出されません、および関数本体内の特定の型に不明なオブジェクト型をキャストして、考慮する必要があります、InvalidCastException が発生する可能性です。 ジェネリック、オブジェクトを関数に渡そうとしたコードが発生すること型が競合するため、関数本体に正しい型を持つことが保証されます。  
  
 同じ利点は、ジェネリック上に構築されたコレクション クラスに適用されます。 過去のコレクション クラスを使用して、`System::Object`コレクションに要素を格納します。 コレクションは、のようになっていない型のオブジェクトの挿入しないフラグが設定された、コンパイル時に、多くの場合、オブジェクトが挿入された場合でもです。 通常、コレクション内にアクセスしたときに、オブジェクトを別の型にキャストは。 キャストが失敗した場合だけは予期しない型は検出されます。 ジェネリック コンパイル時に型と一致しません (または暗黙的に変換) を挿入するコードを検出することによってこの問題を解決するジェネリック コレクションの型パラメーター。  
  
 構文の説明は、次を参照してください。[ジェネリック関数 (C +/cli CLI)](../windows/generic-functions-cpp-cli.md)します。  
  
## <a name="terminology-used-with-generics"></a>ジェネリックを使用する用語  
  
### <a name="type-parameters"></a>型パラメーター  
 ジェネリック宣言と呼ばれる 1 つまたは複数の不明な型が含まれています。*パラメーター入力*します。 型パラメーターには、ジェネリック宣言の本体で型の名前が指定されます。 型パラメーターは、ジェネリック宣言の本文内の型として使用されます。 ジェネリック宣言には、 `List<T>` t です型パラメーターが含まれています。  
  
### <a name="type-arguments"></a>型引数  
 *引数を入力*ジェネリックは、特定の種類または種類の特殊化される型パラメーターの代わりに使用される実際の型です。 たとえば、 **int**の型引数には、`List<int>`します。 値の型およびハンドルの型は、ジェネリック型引数としてでは許可の種類のみです。  
  
### <a name="constructed-type"></a>構築された型  
 ジェネリック型から構築された型と呼びます、*構築型*します。 完全には、指定した型など`List<T>`は、*オープン構築型*は完全に、指定した型など`List<double>,`は、*クローズ構築型*または*特化型*. 構築されたオープン型の他のジェネリック型またはメソッドの定義で使用でき、いない完全指定できるまで、指定された自体がジェネリックであります。 たとえば、オープン構築型のジェネリック型の基本クラスとしての使用は、次のように。  
  
```cpp
// generics_overview.cpp
// compile with: /clr /c
generic <typename T>  
  
ref class List {}; 
  
generic <typename T>
  
ref class Queue : public List<T> {};  
```
  
### <a name="constraint"></a>制約  
 制約は、型パラメーターとして使用できる型での制限です。 など指定されたジェネリック クラスは、指定したクラスから継承するクラスのみを受け入れるまたは指定したインターフェイスを実装します。 詳細については、次を参照してください。[ジェネリック型パラメーターの制約 (C +/cli CLI)](../windows/constraints-on-generic-type-parameters-cpp-cli.md)します。  
  
## <a name="reference-types-and-value-types"></a>参照型と値の型  
 ハンドル型と値型は、型引数として使用可能性があります。 ジェネリックの定義をいずれかの型を使用する可能性があります、参照型の構文では。 たとえば、`->`演算子を使用して、最終的に使用される型が参照型または値型かどうか、型パラメーターの型のメンバーにアクセスします。 値の型は型引数として使用するときに、ランタイムは、値型をボックス化せずに直接値の型を使用するコードを生成します。  
  
 参照型をジェネリック型引数として使用する場合は、ハンドルの構文を使用します。 値の型をジェネリック型引数として使用する場合は、直接型の名前を使用します。  
  
```cpp
// generics_overview_2.cpp  
// compile with: /clr  
generic <typename T>  
  
ref class GenericType {};  
ref class ReferenceType {};  
  
value struct ValueType {};  
  
int main() {  
    GenericType<ReferenceType^> x;  
    GenericType<ValueType> y;  
}  
```
  
## <a name="type-parameters"></a>型パラメーター  
 ジェネリック クラスの型パラメーターは、他の識別子のように扱われます。 ただし、種類が不明なのでは使用に制限します。 たとえば、これらのメンバーをサポートするために、型パラメーターがわかっていない限りは、メンバーと型パラメーターのクラスのメソッドを使用できません。 型パラメーターでメンバーにアクセスするには、型パラメーターの制約リストにメンバーを含む型を追加する必要があります。  
  
```cpp  
// generics_overview_3.cpp  
// compile with: /clr
interface class I {  
   void f1();  
   void f2();  
};  
  
ref struct R : public I {  
   virtual void f1() {}  
   virtual void f2() {}   
   virtual void f3() {}   
};  
  
generic <typename T>  
where T : I  
void f(T t) {  
   t->f1();  
   t->f2();  
   safe_cast<R^>(t)->f3();  
}  
  
int main() {  
   f(gcnew R());  
}  
```  
  
 演算子もに、これらの制限が適用されます。 制約のないジェネリック型パラメーターを使用していない可能性があります、`==`と`!=`型は、これらの演算子をサポートしていない場合、型パラメーターの 2 つのインスタンスを比較する演算子。 これらのチェックは、ジェネリックのために必要ながテンプレートではなくジェネリックは、任意のクラスを使用して実行時に特殊化することがありますのでする制約を満たす、ときに遅すぎるの無効なメンバーの使用を確認します。  
  
 使用して型パラメーターの既定のインスタンスを作成する場合があります、`()`演算子。 例えば:  
  
 `T t = T();`  
  
 場所`T`ジェネリック クラスまたはメソッドの定義の型パラメーターは、既定値に変数を初期化します。 場合`T`場合 null ポインタがなります、ref クラスは、`T`値クラスでは、オブジェクトがゼロに初期化されます。 これと呼ばれますが、*既定の初期化子*します。  
  
## <a name="see-also"></a>関連項目  
 [ジェネリック](../windows/generics-cpp-component-extensions.md)