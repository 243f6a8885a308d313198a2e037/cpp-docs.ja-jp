---
title: "デストラクター (C++) | Microsoft Docs"
ms.custom: ""
ms.date: "12/03/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "language-reference"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "~ 演算子, デストラクターの指定"
  - "破棄 (オブジェクトを), デストラクター"
  - "デストラクター, デストラクターの概要"
  - "デストラクター, C++"
  - "オブジェクト [C++], 破棄"
  - "Visual C++, デストラクター"
ms.assetid: afa859b0-f3bc-4c4d-b250-c68b335b6004
caps.latest.revision: 10
caps.handback.revision: 10
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# デストラクター (C++)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

"デストラクター" 関数は、コンストラクター関数の逆の操作を行います。  呼び出されるのは、オブジェクトが破棄 \(割り当てを解放\) されるときです。  関数をクラスのデストラクターとして指定するには、クラス名の前にティルダ \(`~`\) を付けます。  たとえば、クラス `String` のデストラクターを宣言するには、`~String()` とします。  
  
 \/clr のコンパイルでは、マネージおよびアンマネージ リソースを解放する際に、デストラクターが特別な役割を果たします。  詳細については、「[Visual C\+\+ のデストラクターおよびファイナライザー](../misc/destructors-and-finalizers-in-visual-cpp.md)」を参照してください。  
  
 デストラクターは、通常、オブジェクトが不要になったときに "クリーンアップ" を行うために使用されます。  `String` クラスの次のような宣言があるとします。  
  
```  
// spec1_destructors.cpp  
#include <string.h>  
  
class String {  
public:  
   String( char *ch );  // Declare constructor  
   ~String();           //  and destructor.  
private:  
   char    *_text;  
   size_t  sizeOfText;  
};  
  
// Define the constructor.  
String::String( char *ch ) {  
   sizeOfText = strlen( ch ) + 1;  
  
   // Dynamically allocate the correct amount of memory.  
   _text = new char[ sizeOfText ];  
  
   // If the allocation succeeds, copy the initialization string.  
   if( _text )  
      strcpy_s( _text, sizeOfText, ch );  
}  
  
// Define the destructor.  
String::~String() {  
   // Deallocate the memory that was previously reserved  
   //  for this string.  
   if (_text)  
      delete[] _text;  
}  
  
int main() {  
   String str("The piper in the glen...");  
}  
```  
  
 上の例では、デストラクター `String::~String` が `delete` 演算子を使用して、テキストの保存のために動的に割り当てられた領域を解放します。  
  
## デストラクターの宣言  
 デストラクターはクラスと同じ名前の関数ですが、先頭にティルダ \(`~`\) が付きます。  
  
 上記の構文の最初の形式は、デストラクタ―をクラス宣言内で宣言または定義する場合に使用します。2 番目の形式は、デストラクタ―をクラス宣言の外側で定義する場合に使用します。  
  
 デストラクターの宣言には以下の規則が適用されます  。  
  
-   デストラクタ―は引数を受け取りません。  
  
-   デストラクタ―は戻り値の型 \(`void` を含む\) を指定できません。  
  
-   デストラクタ―は、`return` ステートメントを使って値を返すことができません。  
  
-   デストラクタ―は **const**、`volatile`、または **static** として宣言できません。  ただし、**const**、`volatile`、または **static** として宣言されているオブジェクトを破棄するために呼び出すことができます。  
  
-   デストラクタ―は **virtual** として宣言できます。  仮想デストラクターを使用すると、型を知らなくてもオブジェクトを破棄できます。オブジェクトの正しいデストラクターが、仮想関数のメカニズムを使用して呼び出されます。  デストラクターは、抽象クラスの純粋仮想関数として宣言することもできます。  
  
## デストラクターの使用  
 デストラクターは、次のいずれかのイベントが発生したときに呼び出されます。  
  
-   **new** 演算子を使用して割り当てられたオブジェクトは、**delete** 演算子を使用して明示的に解放されます。  **delete** 演算子を使用してオブジェクトを解放すると、メモリは "最もよく派生されるオブジェクト"、または完全なオブジェクトであって基底クラスを表すサブオブジェクトではないオブジェクトのために解放されます。  この "最派生オブジェクト" の解放は、仮想デストラクターでのみ機能することが保証されています。  型情報が実際のオブジェクトの基になる型に対応していない多重継承の状況では、解放に失敗する可能性があります。  
  
-   ブロック スコープを持つローカル \(自動\) オブジェクトがスコープから外れます。  
  
-   一時オブジェクトの有効期間は終了します。  
  
-   プログラムは終了し、グローバルまたはスタティック オブジェクトが存在します。  
  
-   デストラクターは、デストラクター関数の完全修飾名を使用して明示的に呼び出されます   \(詳細については、「[明示的なデストラクター呼び出し](../misc/explicit-destructor-calls.md)」を参照してください\)。  
  
 前のケースでは、すべてのオブジェクトをユーザー定義メソッドで確実に破棄できます。  
  
 基底クラスまたはデータ メンバーにアクセスできるデストラクターがあり、派生クラスでデストラクターを宣言していない場合、コンパイラはデストラクターを生成します。  コンパイラが生成したこのデストラクターは、基底クラス デストラクターと派生型のメンバーのデストラクターを呼び出します。  既定のデストラクターはパブリックです   \(アクセシビリティの詳細については、「[基底クラスのアクセス指定子](../misc/access-specifiers-for-base-classes.md)」を参照してください\)。  
  
 デストラクターは、自由にクラス メンバー関数を呼び出したり、クラス メンバーのデータにアクセスしたりできます。  仮想関数がデストラクターから呼び出されるとき、呼び出された関数は、現在破棄されているクラスの関数です   \(詳細については、「[破棄の順序](../misc/order-of-destruction.md)」を参照してください\)。  
  
 デストラクターの使用には 2 つの制限があります。  最初の制限は、デストラクターのアドレスを受け取ることができないことです。  2 番目は、派生クラスは基底クラスのデストラクターを継承しないことです。  代わりに、前に説明したように、基底クラスのデストラクターを常にオーバーライドします。  
  
## 破棄の順序  
 オブジェクトがスコープ外になるとき、または削除されるとき、完全な破棄のイベントの順序は次のとおりです。  
  
1.  クラスのデストラクターが呼び出され、デストラクター関数の本体が実行されます。  
  
2.  非静的メンバー オブジェクトのデストラクターは、クラス宣言での出現順序の逆順で呼び出されます。  これらのメンバーの構築に使用されたオプションのメンバー初期化リストは、\(構築または\) 破棄の順序に影響を与えません   \(メンバーの初期化の詳細については、「[基底クラスとメンバーの初期化](http://msdn.microsoft.com/ja-jp/2f71377e-2b6b-49da-9a26-18e9b40226a1)」を参照してください\)。  
  
3.  非仮想基底クラスのデストラクターは、宣言の逆順で呼び出されます。  
  
4.  仮想基底クラスのデストラクターは、宣言の逆順で呼び出されます。  
  
```  
// order_of_destruction.cpp  
#include <stdio.h>  
  
struct A1      { virtual ~A1() { printf("A1 dtor\n"); } };  
struct A2 : A1 { virtual ~A2() { printf("A2 dtor\n"); } };  
struct A3 : A2 { virtual ~A3() { printf("A3 dtor\n"); } };  
  
struct B1      { ~B1() { printf("B1 dtor\n"); } };  
struct B2 : B1 { ~B2() { printf("B2 dtor\n"); } };  
struct B3 : B2 { ~B3() { printf("B3 dtor\n"); } };  
  
int main() {  
   A1 * a = new A3;  
   delete a;  
   printf("\n");  
  
   B1 * b = new B3;  
   delete b;  
   printf("\n");  
  
   B3 * b2 = new B3;  
   delete b2;  
}  
  
Output: A3 dtor  
A2 dtor  
A1 dtor  
  
B1 dtor  
  
B3 dtor  
B2 dtor  
B1 dtor  
  
```  
  
### 仮想基底クラス  
 仮想基底クラスのデストラクターが有向非循環グラフ \(深さ優先、左から右、後順走査\) で外観の逆の順序で呼び出されます。  次の図は、継承グラフを示しています。  
  
 ![仮想基底クラスを示す継承グラフ](../cpp/media/vc392j1.png "vc392J1")  
仮想基底クラスを示す継承グラフ  
  
 図に示されているクラスの先頭を次に示します。  
  
```  
class A  
class B  
class C : virtual public A, virtual public B  
class D : virtual public A, virtual public B  
class E : public C, public D, virtual public B  
```  
  
 コンパイラは、`E` 型のオブジェクトの仮想基底クラスの破棄の順序を決定するため、次のアルゴリズムを適用してリストを作成します。  
  
1.  グラフを左に走査し、グラフの最も深いポイント \(この場合は `E`\) で開始します。  
  
2.  すべてのノードが表示されるまで左方向への走査を実行します。  現在のノードの名前を確認します。  
  
3.  保持するノードが仮想基底クラスであるかどうかを確認するために、前のノード \(右下隅\) を再表示します。  
  
4.  保持するノードが仮想基底クラスである場合は、既に構成されているかどうかを参照するために、リストを確認します。  仮想基底クラスでない場合は無視します。  
  
5.  保持するノードがリストにない場合は、リストの末尾に追加します。  
  
6.  上方向および次のパスに沿って右へグラフを走査します。  
  
7.  手順 2. に進みます。  
  
8.  最後の上方向のパスが使い果たされたら、現在のノードの名前を確認します。  
  
9. 手順 3. に進みます。  
  
10. 下部のノードが再び現在のノードになるまで、このプロセスを続行します。  
  
 したがって、クラス `E` の場合、破棄の順序は次のようになります。  
  
1.  非仮想基底クラス `E`。  
  
2.  非仮想基底クラス `D`。  
  
3.  非仮想基底クラス `C`。  
  
4.  仮想基底クラス `B`。  
  
5.  仮想基底クラス `A`。  
  
 このプロセスにより、一意のエントリの順序付きリストが作成されます。  いずれのクラス名も、2 回表示されることはありません。  リストが構築されると、逆順で走査され、リストの各クラスのデストラクターが最後から最初まで呼び出されます。  
  
 構築または破棄の順序は、1 つのクラスのコンストラクターまたはデストラクターが、初めて作成されるか、より長く保持されている他のコンポーネントに依存する場合に、特に重要になります。たとえば、コードが実行されたときに \(上記の図に示す\) `A` のデストラクター \(上記の図に示す\) がまだ存在している `B` に依存している場合や、その逆の場合です。  
  
 継承グラフでのクラス間のこのような依存関係は、後で派生するクラスが左端のパスを変更し、それによって構築と破棄の順序を変更できるため、本質的に危険です。  
  
### 非仮想基底クラス  
 非仮想基底クラスのデストラクターは、基底クラスの名前を宣言した順序と逆の順序で呼び出されます。  クラス宣言の例を次に示します。  
  
```  
class MultInherit : public Base1, public Base2  
...  
```  
  
 前の例では、`Base2` のデストラクターは、`Base1` のデストラクターの前に呼び出されます。  
  
## 明示的なデストラクター呼び出し  
 デストラクターを明示的に呼び出す必要はほとんどありません。  ただし、絶対アドレスにあるオブジェクトのクリーンアップを実行すると便利な場合があります。  これらのオブジェクトは、一般に、配置引数を受け取るユーザー定義の **new** 演算子を使用して割り当てられます。  このメモリはフリー ストアから割り当てられていないので、**delete** 演算子はこのメモリを解放できません \(詳細については、[new 演算子と delete 演算子](../cpp/new-and-delete-operators.md)を参照\)。  ただし、デストラクターへの呼び出しは適切なクリーンアップを実行できます。  オブジェクトのデストラクターを明示的に呼び出すには、`s` \(`String` クラス\) で次のいずれかのステートメントを使用します。  
  
```  
s.String::~String();     // Nonvirtual call  
ps->String::~String();   // Nonvirtual call  
  
s.~String();       // Virtual call  
ps->~String();     // Virtual call  
```  
  
 先に示したデストラクターへの明示的な呼び出しの表記は、型がデストラクターを定義するかどうかにかかわらず使用できます。  これにより、デストラクターが型に対して定義されているかどうかを確認せずにこのような明示的な呼び出しを行うことができます。  何も定義されていないデストラクターへの明示的な呼び出しは無効です。  
  
## 参照  
 [特殊なメンバー関数](../misc/special-member-functions-cpp.md)