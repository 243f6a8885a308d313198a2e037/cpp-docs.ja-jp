---
title: "スコープ規則の概要 |Microsoft ドキュメント"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-language
ms.tgt_pltfrm: 
ms.topic: language-reference
dev_langs:
- C++
helpviewer_keywords:
- class scope [C++], rules
- classes [C++], scope
- class names [C++], scope rules
- names [C++], class
- scope [C++], class names
ms.assetid: 47e26482-0111-466f-b857-598c15d05105
caps.latest.revision: 8
author: mikeblome
ms.author: mblome
manager: ghogen
ms.translationtype: HT
ms.sourcegitcommit: 6ffef5f51e57cf36d5984bfc43d023abc8bc5c62
ms.openlocfilehash: 2e4a728d23dc9a04b62c9852823f359c3a7cb150
ms.contentlocale: ja-jp
ms.lasthandoff: 09/25/2017

---
# <a name="summary-of-scope-rules"></a>スコープ規則の概要
名前の使用はスコープ内で明確である必要があります (オーバーロードが決定される段階まで)。 名前が関数を表している場合、関数はパラメーターの数と型に対し明確でなければなりません。 名前があいまいでない、残っている場合[メンバー アクセス](../cpp/member-access-control-cpp.md)規則が適用されます。  
  
## <a name="constructor-initializers"></a>Constructor Initializers (コンストラクター初期化子)  
 コンス トラクター初期化子 (記載[初期化の基本クラスとメンバー](http://msdn.microsoft.com/en-us/2f71377e-2b6b-49da-9a26-18e9b40226a1)) は指定したコンス トラクターの最も外側のブロックのスコープで評価されます。 したがって、初期化子は、コンストラクターのパラメーター名を使用できます。  
  
## <a name="global-names"></a>Global Names (グローバルな名前)  
 オブジェクト、関数、または列挙子の名前が関数やクラスの外側に記述されているか、またはグローバル スコープの単項演算子 (`::`) が先頭に付加されており、以下のいずれかの二項演算子と共に使用されていない場合、その名前はグローバルと見なされます。  
  
-   スコープ解決 (`::`)  
  
-   オブジェクトと参照のメンバー選択 (**.**)  
  
-   ポインターのメンバー選択 (**->**)  
  
## <a name="qualified-names"></a>修飾名  
 バイナリ スコープ解決演算子 (`::`) と共に使用される名前は、"修飾名" と呼ばれます。 バイナリ スコープ解決演算子の後ろに指定される名前は、演算子の左側で指定されたクラスのメンバーまたはその基底クラスのメンバーである必要があります。  
  
 メンバー選択演算子の後に指定した名前 (**です。** または** -> **) 演算子の左側またはその基底クラスのメンバーで指定されたオブジェクトのクラス型のメンバーである必要があります。 メンバー選択演算子の右側に指定した名前 (**->**) はオブジェクトの場合も、別のクラス型の条件の左側にある** -> **クラス オブジェクトとクラスがオーバー ロードされたメンバー選択演算子を定義すること (**->**) その他の任意のクラス型へのポインターに評価されます。 (このプロビジョニングはで詳しく説明[クラス メンバー アクセス](../cpp/member-access.md))。  
  
 コンパイラは、次の順序で名前を検索し、名前が見つかると検索を停止します。  
  
1.  名前が関数内で使用されている場合は現在のブロック スコープを、それ以外の場合はグローバル スコープを検索する。  
  
2.  現在のブロックを囲む各ブロックを外側へ、(関数のパラメーターが含まれる) 最も外側の関数スコープまで検索する。  
  
3.  名前がメンバー関数内で使用されている場合は、そのクラスのスコープで名前を検索する。  
  
4.  そのクラスの基底クラスで名前を検索する。  
  
5.  入れ子の外側のクラス スコープ (存在する場合) とその基底クラスを検索する。 最も外側を囲むクラス スコープが検索されるまで検索を続行する。  
  
6.  グローバル スコープを検索する。  
  
 ただし、この検索順序は、次のように変更できます。  
  
1.  `::` の後ろの名前については、グローバル スコープから検索を開始する。  
  
2.  後ろの名前、**クラス**、 `struct`、および**共用体**キーワードのみを検索するコンパイラに強制**クラス**、 `struct`、または**共用体**名。  
  
3.  スコープ解決演算子の左側にある名前 (`::`) だけを使用できます**クラス**、 `struct`、**名前空間**、または**共用体**名。  
  
 名前が非静的メンバーを参照しているにもかかわらず、静的メンバー関数で使用されている場合は、エラー メッセージが生成されます。 同様に、名前が外側のクラスの非静的メンバーを参照している場合、エラー メッセージが生成取り込まれているクラスは、それを囲むクラスを持たないため**この**ポインター。  
  
## <a name="function-parameter-names"></a>関数のパラメーター名  
 関数定義内の関数のパラメーター名は、関数本体の最も外側のブロックのスコープ内にあると見なされます。 したがって、それらの引数名はローカル名であり、関数が終了するとスコープ外に出ます。  
  
 関数宣言 (プロトタイプ) 内の関数のパラメーター名はローカル スコープにあり、宣言の終了時にスコープ外に出ます。  
  
 既定のパラメーターは、上記で説明したとおり、それらを既定とするパラメーターのスコープ内にあります。 ただし、ローカル変数や非静的クラス メンバーにはアクセスできません。 既定のパラメーターは、関数呼び出しの時点で評価されますが、関数宣言の元のスコープで評価されます。 したがって、メンバー関数の既定のパラメーターは、常にクラス スコープで評価されます。  
  
## <a name="see-also"></a>関連項目  
 [継承](../cpp/inheritance-cpp.md)
