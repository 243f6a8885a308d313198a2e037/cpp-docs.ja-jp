---
title: "標準変換 | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "language-reference"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "変換, 標準"
  - "L 値"
  - "標準変換, カテゴリ"
ms.assetid: ce7ac8d3-5c99-4674-8229-0672de05528d
caps.latest.revision: 10
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
caps.handback.revision: 7
---
# 標準変換
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

C\+\+ 言語では、基本型間での変換が定義されています。  また、ポインター、参照、およびメンバーへのポインターの派生型についても変換が定義されています。  これらの変換を "標準変換" といいます。\(型、標準の型、および派生型の詳細については、「[型](http://msdn.microsoft.com/ja-jp/6882ee83-ea32-4373-8d57-c3efbbc15af0)」を参照してください。\)  
  
 このセクションでは、次の標準変換について説明します。  
  
-   [整数の上位変換](../misc/integral-promotions.md)  
  
-   [整数の変換](../misc/integral-conversions.md)  
  
-   [浮動小数点の変換](../misc/floating-conversions.md)  
  
-   [浮動小数点と整数の変換](../misc/floating-and-integral-conversions.md)  
  
-   [算術変換](../misc/arithmetic-conversions.md)  
  
-   [ポインター変換](../misc/pointer-conversions-cpp.md)  
  
-   [参照変換](../Topic/Reference%20Conversions.md)  
  
-   [メンバーへのポインター変換](../misc/pointer-to-member-conversions.md)  
  
    > [!NOTE]
    >  ユーザー定義型では独自の変換を指定できます。  ユーザー定義型の変換については、「[コンストラクター](../cpp/constructors-cpp.md)」および「[変換](../cpp/user-defined-type-conversions-cpp.md)」を参照してください。  
  
 次のコードは、変換 \(この例では整数の上位変換\) の実行例を示しています。  
  
```  
long  lnum1, lnum2;  
int   inum;  
  
// inum promoted to type long prior to assignment.  
lnum1 = inum;  
  
// inum promoted to type long prior to multiplication.  
lnum2 = inum * lnum2;  
```  
  
> [!NOTE]
>  参照型を生成する場合のみ、変換の結果が左辺値になります。  たとえば、次のようなユーザー定義変換を宣言したとします。  
  
```  
operator int&()  
```  
  
> [!NOTE]
>  このユーザー定義変換は参照を返し、左辺値です。  一方、次のような変換を宣言したとします。  
  
```  
operator int()  
```  
  
> [!NOTE]
>  この場合はオブジェクトを返し、左辺値ではありません。  
  
## 整数の上位変換  
 整数型のオブジェクトは別の大きな整数型 \(つまり、より大きな値のセットを表現できる型\) に変換できます。  この拡大型の変換は、"整数の上位変換" と呼ばれます。 整数の上位変換を使用すると、式で他の整数型を使用できる任意の場所で、次のものを使用できます。  
  
-   `char` と `short int` 型のオブジェクト、リテラル、および定数  
  
-   列挙型  
  
-   `int` ビット フィールド  
  
-   列挙子  
  
 C\+\+ の上位変換では "値保持" されます。 つまり、上位変換後の値が上位変換前の値と同じであることが保証されます。  値保持の上位変換では、より短い整数型のオブジェクト \(ビット フィールドや `char` 型のオブジェクトなど\) は、`int` が元の型の全範囲を表すことができる場合、`int` 型に上位変換されます。  `int` で値のすべての範囲を表すことができない場合、オブジェクトは `unsigned int` 型に昇格されます。  この方法は ANSI C によって使用される方法と同じですが、値を保持する変換はオブジェクトの "符号の有無" を保持しません。  
  
 値保持の上位変換および符号の有無を保持する上位変換は、通常、同じ結果を生成します。  ただし、昇格されたオブジェクトが次のいずれかである場合は、異なる結果になる可能性があります。  
  
-   **\/**、`%`、`/=`、`%=`、**\<**、**\<\=**、**\>**、または **\>\=** のオペランド  
  
     これらの演算子は、結果を判断するために符号に依存します。  したがって、これらのオペランドに適用した場合、値保持と符号保持の上位変換により、異なる結果が生成されます。  
  
-   **\>\>** または **\>\>\=** の左のオペランド  
  
     これらの演算子は、シフト演算を実行するときに符号付き数量と符号なし数量を別々に扱います。  符号付きの数量の場合、数量を右にシフトすると、符号は空いたビット位置に移されます。  符号なし数量の場合、空いたビット位置は 0 で埋められます。  
  
-   引数の一致のためにそのオペランドの型の符号の有無に依存する、オーバーロードされた演算子のオーバーロードされた関数またはオペランドへの引数   \(オーバーロードされた演算子の定義の詳細については、「[オーバーロードされた演算子](../cpp/operator-overloading.md)」を参照\)。  
  
## 整数の変換  
 整数変換は整数型間で実行されます。  整数型は `char`、`int`、**long** \(およびこれらの型の **short**、**signed**、`unsigned` バージョン\) です。  
  
 **signed から unsigned へ**  
  
 符号付き整数型のオブジェクトは、対応する符号なし型に変換できます。  これらの変換が発生しても実際のビット パターンは変わりませんが、データの解釈が変わります。  次のコードを考えてみます。  
  
```  
// conve__pluslang_Converting_Signed_to_Unsigned.cpp  
// compile with: /EHsc  
#include <iostream>  
  
using namespace std;  
int main()  
{  
    short  i = -3;  
    unsigned short u;  
  
    cout << (u = i) << "\n";  
}  
// Output: 65533  
  
```  
  
 前の例では、`signed short`、`i` が定義され、負の数値に初期化されます。  式 `(u = i)` は、`i` に代入する前に、 **を `u`unsigned short** 型に変換します。  
  
 **unsigned から signed へ**  
  
 符号なし整数型のオブジェクトは、対応する符号付き型に変換できます。  ただし、次の例に示すように、符号なしオブジェクトの値が符号付き型で表現できる範囲を超えている場合、このような変換によりデータが誤って解釈される可能性があります。  
  
```  
// conve__pluslang_Converting_Unsigned_to_Signed.cpp  
// compile with: /EHsc  
#include <iostream>  
  
using namespace std;  
int main()  
{  
 short  i;  
 unsigned short u = 65533;  
  
 cout << (i = u) << "\n";  
}  
//Output: -3  
```  
  
 前の例で、`u` は、`unsigned` 式を評価するために符号付き数量に変換する必要がある  **`(i = u)`short** の整数オブジェクトです。  その値は、`signed short` で正しく表現できないため、データはここで示したように、誤って解釈されます。  
  
## 浮動小数点の変換  
 浮動小数点型のオブジェクトは、より精度の高い浮動小数点型に安全に変換できます。つまり、変換で精度は低下しません。  たとえば、**float** から **double** への変換または **double** から `long double` への変換は安全であり、値は変更されません。  
  
 浮動小数点型のオブジェクトは、より精度の低い型で表現できる範囲にある場合はその型に変換できます。  \(浮動小数点型の範囲については、「[浮動小数点の制限](../cpp/floating-limits.md)」を参照してください\)。 元の値を正確に表すことができない場合、その値は次に大きくまたは次に小さく表現できる値に変換できます。  このような値がない場合、結果は未定義です。  次に例を示します。  
  
```  
cout << (float)1E300 << endl;  
```  
  
 型 **float** によって表すことができる最大値は 3.402823466E38 で、1E300 よりもかなり小さい値です。  したがって、数は無限大に変換され、結果は 1.\#INF です。  
  
## 整数型と浮動小数点型の変換  
 特定の式は、浮動小数点型のオブジェクトから整数型のオブジェクトへの変換、またはその逆の変換が発生する場合があります。  整数型のオブジェクトが浮動小数点型に変換され、元の値を正確に表すことができない場合、結果はそれより大きいか小さくて最も近い表現可能な値になります。  
  
 浮動小数点型のオブジェクトが整数型に変換されるときは、小数部分が切り捨てられます。  変換プロセスで丸めは発生しません。  切り捨てとは、1.3 などの数値が 1 に変換され、– 1.3 などの数値が –1 に変換されることを意味します。  
  
## 算術変換  
 多くのバイナリ演算子 \(「[Expressions with Binary Operators \(バイナリ演算子を含む式\)](../cpp/expressions-with-binary-operators.md)」を参照\) では、オペランドの変換が発生し、生じる結果も同様に変換されます。  これらの演算子で変換が発生する方法は、"通常の算術変換" と呼ばれます。 異なるネイティブ型のオペランドの算術変換は、次の表に示すように実行されます。  typedef 型は、基になるネイティブ型に従って動作します。  
  
### 型変換の条件  
  
|満たされる条件|変換|  
|-------------|--------|  
|どちらかのオペランドが **long double** 型|もう一方のオペランドが **long double** 型に変換されます。|  
|上の条件が満たされず、どちらかのオペランドが **double** 型|もう一方のオペランドが **double** 型に変換されます。|  
|上の条件が満たされず、どちらかのオペランドが **float** 型|もう一方のオペランドが **float** 型に変換されます。|  
|上の条件が満たされていない \(どちらのオペランドも浮動小数点型ではない\)|オペランドに次のように整数の上位変換が実行されます。<br /><br /> -   どちらかのオペランドが `unsigned` **long** 型の場合、もう一方のオペランドは `unsigned long` 型に変換されます。<br />-   上の条件が満たされず、どちらかのオペランドが **long** 型で、もう一方が `unsigned` `int` 型である場合、両方のオペランドが `unsigned long` 型に変換されます。<br />-   上の 2 つの条件が満たされず、どちらかのオペランドが **long** 型である場合、もう一方のオペランドが **long** 型に変換されます。<br />-   上の 3 つの条件が満たされず、どちらかのオペランドが `unsigned int` 型である場合、もう一方のオペランドは `unsigned int` 型に変換されます。<br />-   上の条件がどれも満たされない場合、両方のオペランドは `int` 型に変換されます。|  
  
 次のコードは、表で説明している変換規則を示しています。  
  
```  
// arithmetic_conversions.cpp  
double dVal;  
float fVal;  
int iVal;  
unsigned long ulVal;  
  
int main() {  
   // iVal converted to unsigned long  
   // result of multiplication converted to double  
   dVal = iVal * ulVal;  
  
   // ulVal converted to float  
   // result of addition converted to double  
   dVal = ulVal + fVal;  
}  
```  
  
 上記の例の最初のステートメントは、2 つの整数型、`iVal` と `ulVal` の乗算を示しています。  満たされる条件は、どちらのオペランドも浮動小数点型ではなく、一方のオペランドが `unsigned int` 型であることです。  したがって、もう一方のオペランドである `iVal` は `unsigned int` 型に変換されます。  結果は `dVal` に代入されます。  満たされる条件は、一方のオペランドが **double** 型であることです。したがって、乗算の `unsigned int` の結果は **double** 型に変換されます。  
  
 上記の例の 2 番目のステートメントは、**float** および整数型の `fVal` と `ulVal` の加算を示しています。  `ulVal` 変数は **float** 型に変換されます \(表の 3 番目の条件\)。  加算の結果は、**double** 型に変換され \(表の 2 番目の条件\)、`dVal` に代入されます。  
  
## ポインター変換  
 ポインターは、代入、初期化、比較、および他の式の中で変換できます。  
  
### クラスへのポインター  
 クラスへのポインターを基底クラスへのポインターに変換できる 2 つのケースがあります。  
  
 最初のケースは、指定した基底クラスがアクセス可能であり、変換が明確である場合です。  \(あいまいな基底クラスの参照の詳細については、「[複数の基底クラス](../cpp/multiple-base-classes.md)」を参照してください\)。  
  
 基底クラスにアクセスできるかどうかは、派生で使用される継承の種類によって決まります。  次の図に示す継承を考えます。  
  
 ![基底クラスのアクセシビリティを示す継承グラフ](../cpp/media/vc38xa1.png "vc38XA1")  
基底クラスのアクセシビリティを示す継承グラフ  
  
 次の表は、図で示す状況に対する基底クラスのアクセシビリティを示します。  
  
### 基底クラスのアクセシビリティ  
  
|関数の型|派生|変換 \(<br /><br /> B\* から A\* へ\) は有効か?|  
|----------|--------|------------------------------------|  
|外部 \(非クラス スコープ\) 関数|プライベート|いいえ|  
||プロテクト|いいえ|  
||パブリック|はい|  
|B のメンバー関数 \(B のスコープ内\)|プライベート|はい|  
||プロテクト|はい|  
||パブリック|はい|  
|C のメンバー関数 \(C のスコープ内\)|プライベート|いいえ|  
||プロテクト|はい|  
||パブリック|はい|  
  
 クラスへのポインターを基底クラスへのポインターに変換できる 2 番目のケースは、明示的な型変換を使用する場合です   \(明示的な型変換に関する詳細については、「[明示的な型変換を含む式](http://msdn.microsoft.com/ja-jp/060ad6b4-9592-4f3e-8509-a20ac84a85ae)」を参照してください\)。  
  
 このような変換の結果は「サブオブジェクト」へのポインターです。サブオブジェクトは、基底クラスによって完全に記述されたオブジェクトの一部です。  
  
 次のコードでは、2 つのクラス `A` と `B` を定義しています。`B` は `A` から派生しています。  \(継承の詳細については、「[派生クラス](../cpp/inheritance-cpp.md)」を参照してください\)。 次に、`bObject`、型 `B` のオブジェクト、およびオブジェクトを指す 2 つのポインター \(`pA` と `pB`\) を定義します  
  
```  
// conve__pluslang_Pointers_to_Classes.cpp  
// C2039 expected  
class A  
{  
public:  
    int AComponent;  
    int AMemberFunc();  
};  
  
class B : public A  
{  
public:  
    int BComponent;  
    int BMemberFunc();  
};  
int main()  
{  
   B bObject;  
   A *pA = &bObject;  
   B *pB = &bObject;  
  
   pA->AMemberFunc();   // OK in class A  
   pB->AMemberFunc();   // OK: inherited from class A  
   pA->BMemberFunc();   // Error: not in class A  
}  
```  
  
 ポインター `pA` は、型 `A *` へのポインターを意味するものとして解釈できる型 `A` です。 `bObject` `(``BComponent`、`BMemberFunc` など\) のメンバーは、`B` 型において一意であり、`pA` からアクセスできません。  `pA` ポインターは、クラス `A` で定義されているオブジェクトのこれらの特性 \(メンバー関数とデータ\) にのみアクセスを許可します。  
  
### 関数へのポインター  
 関数へのポインターは、**void \*** 型がそのポインターを保持するために十分に大きい場合は、**void \*** 型に変換できます。  
  
### void へのポインター  
 `void` 型へのポインターは他の任意の型へのポインターに変換できますが、\(C の場合とは異なり\) 明示的な型キャストを使用する場合に限られます   \(型キャストに関する詳細については、「[明示的な型変換を含む式](http://msdn.microsoft.com/ja-jp/060ad6b4-9592-4f3e-8509-a20ac84a85ae)」を参照してください\)。 任意の型へのポインターは型 `void` へのポインターに暗黙に変換できます。型の不完全オブジェクトへのポインターは、`void` へのポインターに変換でき \(暗黙\)、逆向きにも変換できます \(明示的\)。  このような変換の結果は、元のポインターの値と同じです。  オブジェクトを宣言しても、サイズまたは基底クラスを決定するための十分な情報がない場合は、オブジェクトは不完全であると見なされます。  
  
 **const** でも `volatile` でもないオブジェクトへのポインターは、暗黙的に **void \*** 型のポインターに変換できます。  
  
### const ポインターと volatile ポインター  
 C\+\+ では、**const** 型または `volatile` 型から **const** または `volatile` ではない型への標準変換を提供していません。  ただし、どの種類の変換も、明示的な型キャストを使用して指定できます \(安全でない変換も含む\)。  
  
> [!NOTE]
>  静的メンバーへのポインターを除く、メンバーへの C\+\+ のポインターは、通常のポインターとは異なり、同じ標準変換がありません。  静的メンバーへのポインターは通常のポインターであり、通常のポインターと同じ変換を持ちます。  \(詳細については、「[\(NOTINBUILD\) Directly Derived Types](http://msdn.microsoft.com/ja-jp/d2d611d1-dbff-4fb4-9858-e1572544f5c3)」を参照してください。\)  
  
### null ポインターの変換  
 評価するとゼロになる整数定数式、またはそのような式をポインター型にキャストした結果は、"null ポインター" というポインターに変換されます。 このポインターは、すべての有効なオブジェクトまたは関数へのポインターと等しくないと判定されることが保証されます \(同じオフセットを持っていても別のオブジェクトを指すことができる、ベース付きのオブジェクトへのポインターを除く\)。  
  
 C\+\+11 では、[nullptr](../Topic/nullptr.md) 型は、C スタイルの null ポインターより優先する必要があります。  
  
### ポインター式の変換  
 配列型の式は、同じ型のポインターに変換できます。  変換の結果は最初の配列要素へのポインターです。  次のコードは、この変換を示す例です。  
  
```  
char szPath[_MAX_PATH]; // Array of type char.  
char *pszPath = szPath; // Equals &szPath[0].  
```  
  
 特定の型を返す関数となる式は、次の場合を除き、その型を返す関数へのポインターに変換されます。  
  
-   式がアドレス演算子 \(**&**\) のオペランドとして使用されています。  
  
-   式が関数呼び出し演算子のオペランドとして使用されています。  
  
## 参照変換  
 次のケースでは、クラスへの参照を基底クラスへの参照に変換できます。  
  
-   指定した基底クラスにはアクセスできます \(「[クラスへのポインター](../misc/pointers-to-classes.md)」で定義のとおり\)。  
  
-   変換は明確です。  \(あいまいな基底クラスの参照の詳細については、「[複数の基底クラス](../cpp/multiple-base-classes.md)」を参照してください\)。  
  
 変換の結果は、基底クラスを表すサブオブジェクトへのポインターです。  
  
## メンバーへのポインター  
 クラス メンバーへのポインターは、代入、初期化、比較、および他の式の中で変換できます。  このセクションでは、以下のポインターからメンバーへの変換について説明します。  
  
## 基底クラスのメンバーへのポインター  
 基底クラスのメンバーへのポインターは、次の条件を満たす場合に、そのクラスから派生したクラスのメンバーへのポインターに変換できます。  
  
-   派生クラスへのポインターから基底クラスへのポインターへの逆変換がアクセス可能である。  
  
-   派生クラスが基底クラスからの仮想的な継承でない。  
  
 左のオペランドがメンバーへのポインターである場合、右のオペランドはメンバーへのポインター型であるか、0 に評価される定数式である必要があります。  この代入は、次の場合にのみ有効です。  
  
-   右のオペランドが、左のオペランドと同じクラスのメンバーへのポインターである。  
  
-   左のオペランドが、右のオペランドのクラスからパブリックかつ明確に派生したクラスのメンバーへのポインターである。  
  
## 整数定数の変換  
 評価するとゼロになる整数定数式は、"null ポインター" というポインターに変換されます。 このポインターは、すべての有効なオブジェクトまたは関数へのポインターと等しくないと判定されることが保証されます \(同じオフセットを持っていても別のオブジェクトを指すことができる、ベース付きのオブジェクトへのポインターを除く\)。  
  
 次のコードは、クラス `i` のメンバー `A` へのポインターの定義を示しています。  ポインター `pai` が 0、つまり null ポインターに初期化されます。  
  
```  
// conve__pluslang_Integral_Constant_Expressions.cpp  
class A  
{  
public:  
 int i;  
};  
  
int A::*pai = 0;  
  
int main()  
{  
}  
```  
  
## 参照  
 [C\+\+ 言語リファレンス](../cpp/cpp-language-reference.md)