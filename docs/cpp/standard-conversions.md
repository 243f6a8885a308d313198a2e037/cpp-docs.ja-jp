---
title: "標準変換 |Microsoft ドキュメント"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-language
ms.tgt_pltfrm: 
ms.topic: language-reference
dev_langs: C++
helpviewer_keywords:
- standard conversions, categories of
- L-values [C++]
- conversions, standard
ms.assetid: ce7ac8d3-5c99-4674-8229-0672de05528d
caps.latest.revision: "10"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.openlocfilehash: 954ba431378317a3f9079677f49223a336af5d9e
ms.sourcegitcommit: ebec1d449f2bd98aa851667c2bfeb7e27ce657b2
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/24/2017
---
# <a name="standard-conversions"></a>標準変換
C++ 言語では、基本型間での変換が定義されています。 また、ポインター、参照、およびメンバーへのポインターの派生型についても変換が定義されています。 これらの変換を "標準変換" といいます  (種類、標準の型、および派生型に関する詳細については、次を参照してください[型](http://msdn.microsoft.com/en-us/6882ee83-ea32-4373-8d57-c3efbbc15af0)。)。  
  
 このセクションでは、次の標準変換について説明します。  
  
-   整数の上位変換  
  
-   整数の変換  
  
-   浮動小数点の変換  
  
-   浮動小数点と整数の変換  
  
-   算術変換  
  
-   ポインター変換  
  
-   参照変換  
  
-   メンバーへのポインター変換  
  
    > [!NOTE]
    >  ユーザー定義型では独自の変換を指定できます。 ユーザー定義型の変換は、「[コンス トラクター](../cpp/constructors-cpp.md)と[変換](../cpp/user-defined-type-conversions-cpp.md)です。  
  
 次のコードは、変換 (この例では整数の上位変換) の実行例を示しています。  
  
```  
long  long_num1, long_num2;  
int   int_num;  
  
// int_num promoted to type long prior to assignment.  
long_num1 = int_num;  
  
// int_num promoted to type long prior to multiplication.  
long_num2 = int_num * long_num2;  
```  
  
 参照型を生成する場合のみ、変換の結果が左辺値になります。 たとえば、ユーザー定義の変換として宣言されている`operator int&()`の参照を返し、左辺値です。 ただし、変換として宣言`operator int()`オブジェクトを返し、左辺値ではありません。  
  
## <a name="integral-promotions"></a>整数の上位変換  
 整数型のオブジェクトは別の大きな整数型 (つまり、より大きな値のセットを表現できる型) に変換できます。 この拡大型の変換は、"整数の上位変換" と呼ばれます。 整数の上位変換を使用すると、式で他の整数型を使用できる任意の場所で、次のものを使用できます。  
  
-   `char` と `short int` 型のオブジェクト、リテラル、および定数  
  
-   列挙型  
  
-   `int` ビット フィールド  
  
-   列挙子  
  
 C++ の上位変換では "値保持" されます。 つまり、上位変換後の値が上位変換前の値と同じであることが保証されます。 値保持の上位変換では、より短い整数型のオブジェクト (ビット フィールドや `char` 型のオブジェクトなど) は、`int` が元の型の全範囲を表すことができる場合、`int` 型に上位変換されます。 `int` で値のすべての範囲を表すことができない場合、オブジェクトは `unsigned int` 型に昇格されます。 この方法は ANSI C によって使用される方法と同じですが、値を保持する変換はオブジェクトの "符号の有無" を保持しません。  
  
 値保持の上位変換および符号の有無を保持する上位変換は、通常、同じ結果を生成します。 ただし、昇格されたオブジェクトが次のいずれかである場合は、異なる結果になる可能性があります。  
  
-   オペランド **/** 、 `%`、 `/=`、 `%=`、  **<** 、  **\< =** 、 **>** 、または**>=**  
  
     これらの演算子は、結果を判断するために符号に依存します。 したがって、これらのオペランドに適用した場合、値保持と符号保持の上位変換により、異なる結果が生成されます。  
  
-   左オペランド **>>** または**>>=**  
  
     これらの演算子は、シフト演算を実行するときに符号付き数量と符号なし数量を別々に扱います。 符号付きの数量の場合、数量を右にシフトすると、符号は空いたビット位置に移されます。 符号なし数量の場合、空いたビット位置は 0 で埋められます。  
  
-   引数の一致のためにそのオペランドの型の符号の有無に依存する、オーバーロードされた演算子のオーバーロードされた関数またはオペランドへの引数 (を参照してください[オーバー ロードされた演算子](../cpp/operator-overloading.md)オーバー ロードされた演算子を定義する方法の詳細です)。  
  
## <a name="integral-conversions"></a>整数の変換  
 整数変換は整数型間で実行されます。 整数型には`char`、 `int`、および**長い**(および**短い**、**署名**、および`unsigned`これらの型のバージョン)。  
  
 **Signed から unsigned**  
  
 符号付き整数型のオブジェクトは、対応する符号なし型に変換できます。 これらの変換が発生しても実際のビット パターンは変わりませんが、データの解釈が変わります。 次のコードを考えてみます。  
  
```  
  
#include <iostream>  
  
using namespace std;  
int main()  
{  
    short  i = -3;  
    unsigned short u;  
  
    cout << (u = i) << "\n";  
}  
// Output: 65533  
  
```  
  
 前の例では、`signed short`、`i` が定義され、負の数値に初期化されます。 式`(u = i)`により`i`に変換する、 **unsigned short**への割り当てをする前に`u`です。  
  
 **Unsigned から signed**  
  
 符号なし整数型のオブジェクトは、対応する符号付き型に変換できます。 ただし、次の例に示すように、符号なしオブジェクトの値が符号付き型で表現できる範囲を超えている場合、このような変換によりデータが誤って解釈される可能性があります。  
  
```  
  
#include <iostream>  
  
using namespace std;  
int main()  
{  
 short  i;  
 unsigned short u = 65533;  
  
 cout << (i = u) << "\n";  
}  
//Output: -3  
```  
  
 この例では、`u`は、 `unsigned` **短い**整数オブジェクト式を評価する符号付きの数値に変換する必要があります`(i = u)`です。 その値は、`signed short` で正しく表現できないため、データはここで示したように、誤って解釈されます。  
  
## <a name="floating-point-conversions"></a>浮動小数点の変換  
 浮動小数点型のオブジェクトは、より精度の高い浮動小数点型に安全に変換できます。つまり、変換で精度は低下しません。 変換など、 **float**に**二重**またはから**二重**に`long double`は安全であり、値は変更されません。  
  
 浮動小数点型のオブジェクトは、より精度の低い型で表現できる範囲にある場合はその型に変換できます。 (を参照してください[浮動小数点の制限](../cpp/floating-limits.md)の浮動小数点型の範囲です)。元の値を正確に表すことができない場合、その値は次に大きくまたは次に小さく表現できる値に変換できます。 このような値がない場合、結果は未定義です。 次に例を示します。  
  
```  
cout << (float)1E300 << endl;  
```  
  
 型で表現可能な最大値**float**は 3.402823466 e 38 — 数が 1E300 よりもはるかに小さくなります。 したがって、数は無限大に変換され、結果は 1.#INF です。  
  
## <a name="conversions-between-integral-and-floating-point-types"></a>整数型と浮動小数点型の変換  
 特定の式は、浮動小数点型のオブジェクトから整数型のオブジェクトへの変換、またはその逆の変換が発生する場合があります。 整数型のオブジェクトが浮動小数点型に変換され、元の値を正確に表すことができない場合、結果はそれより大きいか小さくて最も近い表現可能な値になります。  
  
 浮動小数点型のオブジェクトが整数型に変換されるときは、小数部分が切り捨てられます。 変換プロセスで丸めは発生しません。 切り捨ては、1.3 は 1、および-1.3 に変換などの数値は-1 に変換されていることを意味します。  
  
## <a name="arithmetic-conversions"></a>算術変換  
 バイナリ演算子の多く (で説明した[二項演算子を含む式](../cpp/expressions-with-binary-operators.md)) のオペランドの変換が発生して、生じる結果も同様です。 これらの演算子で変換が発生する方法は、"通常の算術変換" と呼ばれます。 異なるネイティブ型のオペランドの算術変換は、次の表に示すように実行されます。 typedef 型は、基になるネイティブ型に従って動作します。  
  
### <a name="conditions-for-type-conversion"></a>型変換の条件  
  
|満たされる条件|変換|  
|--------------------|----------------|  
|いずれかのオペランドの型は**long double**です。|もう一方のオペランドを型に変換されます**long double**です。|  
|型の上の条件が満たされず、どちらかのオペランドが**二重**です。|もう一方のオペランドを型に変換されます**二重**です。|  
|型の上の条件が満たされず、どちらかのオペランドが**float**です。|もう一方のオペランドを型に変換されます**float**です。|  
|上の条件が満たされていない (どちらのオペランドも浮動小数点型ではない)|オペランドに次のように整数の上位変換が実行されます。<br /><br /> 場合、いずれかのオペランドの型は`unsigned`**長い**、もう一方のオペランドを型に変換されます`unsigned long`です。<br />場合、上の条件が満たされず、およびどちらかのオペランドの型の場合**長い**、もう一方の型が`unsigned` `int`、両方のオペランドを型に変換されます`unsigned long`です。<br />場合、上記の 2 つの条件が満たされず、およびどちらかのオペランドの型の場合**長い**、もう一方のオペランドを型に変換されます**長い**です。<br />のいずれかのオペランドの型の場合場合、上記の 3 つの条件が満たされず、 `unsigned int`、もう一方のオペランドを型に変換されます`unsigned int`です。<br />-両方のオペランドを型に変換されます上の条件も満たさない場合、`int`です。|  
  
 次のコードは、表で説明している変換規則を示しています。  
  
```  
  
double dVal;  
float fVal;  
int iVal;  
unsigned long ulVal;  
  
int main() {  
   // iVal converted to unsigned long  
   // result of multiplication converted to double  
   dVal = iVal * ulVal;  
  
   // ulVal converted to float  
   // result of addition converted to double  
   dVal = ulVal + fVal;  
}  
```  
  
 上記の例の最初のステートメントは、2 つの整数型、`iVal` と `ulVal` の乗算を示しています。 満たされる条件は、どちらのオペランドも浮動小数点型ではなく、一方のオペランドが `unsigned int` 型であることです。 したがって、もう一方のオペランドである `iVal` は `unsigned int` 型に変換されます。 結果は `dVal` に代入されます。 満たされる条件はその 1 つのオペランドの型は**二重**。 したがって、、 `unsigned int` 、乗算の結果は、型に変換されます**二重**です。  
  
 前の例では、2 番目のステートメントの追加を示しています、 **float**と整数型、`fVal`と`ulVal`です。 `ulVal`変数は、型に変換されます**float** (テーブルの 3 番目の条件)。 加算の結果は、型に変換されます**二重**(2 番目のテーブルで条件) に割り当てられていると`dVal`です。  
  
## <a name="pointer-conversions"></a>ポインター変換  
 ポインターは、代入、初期化、比較、および他の式の中で変換できます。  
  
### <a name="pointer-to-classes"></a>クラスへのポインター  
 クラスへのポインターを基底クラスへのポインターに変換できる 2 つのケースがあります。  
  
 最初のケースは、指定した基底クラスがアクセス可能であり、変換が明確である場合です。 (を参照してください[複数の基底クラス](../cpp/multiple-base-classes.md)あいまいな基底クラスの参照の詳細についてはします)。  
  
 基底クラスにアクセスできるかどうかは、派生で使用される継承の種類によって決まります。 次の図に示す継承を考えます。  
  
 ![継承グラフを示すベース &#45; クラスのアクセシビリティ](../cpp/media/vc38xa1.gif "vc38XA1")  
基底クラスのアクセシビリティを示す継承グラフ  
  
 次の表は、図で示す状況に対する基底クラスのアクセシビリティを示します。  
  
### <a name="base-class-accessibility"></a>基底クラスのアクセシビリティ  
  
|関数の型|派生|変換 (<br /><br /> B * A から\*法的しますか?|  
|----------------------|----------------|-------------------------------------------|  
|外部 (非クラス スコープ) 関数|プライベート|いいえ|  
||プロテクト|いいえ|  
||パブリック|はい|  
|B のメンバー関数 (B のスコープ内)|プライベート|はい|  
||プロテクト|はい|  
||パブリック|はい|  
|C のメンバー関数 (C のスコープ内)|プライベート|いいえ|  
||プロテクト|はい|  
||パブリック|はい|  
  
 クラスへのポインターを基底クラスへのポインターに変換できる 2 番目のケースは、明示的な型変換を使用する場合です  (を参照してください[明示的な型変換を含む式](http://msdn.microsoft.com/en-us/060ad6b4-9592-4f3e-8509-a20ac84a85ae)明示的な型変換の詳細についてはします)。  
  
 このような変換の結果は「サブオブジェクト」へのポインターです。サブオブジェクトは、基底クラスによって完全に記述されたオブジェクトの一部です。  
  
 次のコードでは、2 つのクラス `A` と `B` を定義しています。`B` は `A` から派生しています。 (継承の詳細については、次を参照してください[派生クラスの](../cpp/inheritance-cpp.md)。)。次に、`bObject`、型 `B` のオブジェクト、およびオブジェクトを指す 2 つのポインター (`pA` と `pB`) を定義します  
  
```  
// C2039 expected  
class A  
{  
public:  
    int AComponent;  
    int AMemberFunc();  
};  
  
class B : public A  
{  
public:  
    int BComponent;  
    int BMemberFunc();  
};  
int main()  
{  
   B bObject;  
   A *pA = &bObject;  
   B *pB = &bObject;  
  
   pA->AMemberFunc();   // OK in class A  
   pB->AMemberFunc();   // OK: inherited from class A  
   pA->BMemberFunc();   // Error: not in class A  
}  
```  
  
 ポインター `pA` は、型 `A *` へのポインターを意味するものとして解釈できる型 `A` です。 メンバー `bObject` `(`など`BComponent`と`BMemberFunc`) を入力する一意`B`はこれにを通してアクセスできないと`pA`です。 `pA` ポインターは、クラス `A` で定義されているオブジェクトのこれらの特性 (メンバー関数とデータ) にのみアクセスを許可します。  
  
### <a name="pointer-to-function"></a>関数へのポインター  
 関数へのポインター型に変換できる**void \***場合は、型**void \*** がそのポインターを保持するのに十分です。  
  
### <a name="pointer-to-void"></a>void へのポインター  
 `void` 型へのポインターは他の任意の型へのポインターに変換できますが、(C の場合とは異なり) 明示的な型キャストを使用する場合に限られます  (を参照してください[明示的な型変換を含む式](http://msdn.microsoft.com/en-us/060ad6b4-9592-4f3e-8509-a20ac84a85ae)型キャストの詳細についてはします)。任意の型へのポインターは型 `void` へのポインターに暗黙に変換できます。型の不完全オブジェクトへのポインターは、`void` へのポインターに変換でき (暗黙)、逆向きにも変換できます (明示的)。 このような変換の結果は、元のポインターの値と同じです。 オブジェクトを宣言しても、サイズまたは基底クラスを決定するための十分な情報がない場合は、オブジェクトは不完全であると見なされます。  
  
 はない任意のオブジェクトへのポインター **const**または`volatile`型のポインターに暗黙的に変換できる**void \***です。  
  
### <a name="const-and-volatile-pointers"></a>const ポインターと volatile ポインター  
 C++ ではからの標準変換が用意されていません、 **const**または`volatile`型ではない型を**const**または`volatile`です。 ただし、どの種類の変換も、明示的な型キャストを使用して指定できます (安全でない変換も含む)。  
  
> [!NOTE]
>  静的メンバーへのポインターを除く、メンバーへの C++ のポインターは、通常のポインターとは異なり、同じ標準変換がありません。 静的メンバーへのポインターは通常のポインターであり、通常のポインターと同じ変換を持ちます。   
  
### <a name="null-pointer-conversions"></a>null ポインターの変換  
 評価するとゼロになる整数定数式、またはそのような式をポインター型にキャストした結果は、"null ポインター" というポインターに変換されます。 このポインターは、すべての有効なオブジェクトまたは関数へのポインターと等しくないと判定されることが保証されます (同じオフセットを持っていても別のオブジェクトを指すことができる、ベース付きのオブジェクトへのポインターを除く)。  
  
 C++ 11 で、 [nullptr](../cpp/nullptr.md)型は、C スタイルの null ポインターを優先する必要があります。  
  
### <a name="pointer-expression-conversions"></a>ポインター式の変換  
 配列型の式は、同じ型のポインターに変換できます。 変換の結果は最初の配列要素へのポインターです。 次のコードは、この変換を示す例です。  
  
```  
char szPath[_MAX_PATH]; // Array of type char.  
char *pszPath = szPath; // Equals &szPath[0].  
```  
  
 特定の型を返す関数となる式は、次の場合を除き、その型を返す関数へのポインターに変換されます。  
  
-   この式がアドレス演算子のオペランドとして使用 (**&**)。  
  
-   式が関数呼び出し演算子のオペランドとして使用されています。  
  
## <a name="reference-conversions"></a>参照変換  
 次のケースでは、クラスへの参照を基底クラスへの参照に変換できます。  
  
-   指定した基底クラスはアクセスできます。  
  
-   変換は明確です。 (を参照してください[複数の基底クラス](../cpp/multiple-base-classes.md)あいまいな基底クラスの参照の詳細についてはします)。  
  
 変換の結果は、基底クラスを表すサブオブジェクトへのポインターです。  
  
## <a name="pointer-to-member"></a>メンバーへのポインター  
 クラス メンバーへのポインターは、代入、初期化、比較、および他の式の中で変換できます。 このセクションでは、以下のポインターからメンバーへの変換について説明します。  
  
## <a name="pointer-to-base-class-member"></a>基底クラスのメンバーへのポインター  
 基底クラスのメンバーへのポインターは、次の条件を満たす場合に、そのクラスから派生したクラスのメンバーへのポインターに変換できます。  
  
-   派生クラスへのポインターから基底クラスへのポインターへの逆変換がアクセス可能である。  
  
-   派生クラスが基底クラスからの仮想的な継承でない。  
  
 左のオペランドがメンバーへのポインターである場合、右のオペランドはメンバーへのポインター型であるか、0 に評価される定数式である必要があります。 この代入は、次の場合にのみ有効です。  
  
-   右のオペランドが、左のオペランドと同じクラスのメンバーへのポインターである。  
  
-   左のオペランドが、右のオペランドのクラスからパブリックかつ明確に派生したクラスのメンバーへのポインターである。  
  
## <a name="integral-constant-conversions"></a>整数定数の変換  
 評価するとゼロになる整数定数式は、"null ポインター" というポインターに変換されます。 このポインターは、すべての有効なオブジェクトまたは関数へのポインターと等しくないと判定されることが保証されます (同じオフセットを持っていても別のオブジェクトを指すことができる、ベース付きのオブジェクトへのポインターを除く)。  
  
 次のコードは、クラス `i` のメンバー `A` へのポインターの定義を示しています。 ポインター `pai` が 0、つまり null ポインターに初期化されます。  
  
```  
class A  
{  
public:  
 int i;  
};  
  
int A::*pai = 0;  
  
int main()  
{  
}  
```  
  
## <a name="see-also"></a>関連項目  
 [C++ 言語リファレンス](../cpp/cpp-language-reference.md)