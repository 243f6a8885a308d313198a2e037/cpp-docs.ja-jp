---
title: "C++ 型システム (Modern C) |Microsoft ドキュメント"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-language
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
ms.assetid: 553c0ed6-77c4-43e9-87b1-c903eec53e80
caps.latest.revision: "24"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.openlocfilehash: 47d8fdec93c9d77e6648c5f648171a8ff349474d
ms.sourcegitcommit: ebec1d449f2bd98aa851667c2bfeb7e27ce657b2
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/24/2017
---
# <a name="c-type-system-modern-c"></a>C++ 型システム (Modern C++)
概念*型*は C++ では非常に重要です。 変数、関数の引数、関数の戻り値をコンパイルするには、それぞれに型が必要です。 さらに、すべての式 (リテラル値を含む) には、評価前にコンパイラーにより暗黙的に型が指定されます。 いくつかの種類の例`int`、整数値を格納する`double`浮動小数点値を格納する (とも呼ばれる*スカラー*データ型)、または標準ライブラリ クラス[:basic_string](../standard-library/basic-string-class.md)テキストを格納します。 `class` や `struct` を定義することで、独自の型を作成できます。 型は、変数 (または式の結果) に割り当てられるメモリの量、その変数に格納される値の種類、それらの値の解釈方法 (ビット パターンとして)、その型で実行可能な操作を指定します。 ここでは、C++ の型システムの主な機能の概要を示します。  
  
## <a name="terminology"></a>用語  
 **変数**: シンボリック リンクが定義されているコードのスコープ全体で参照するデータにアクセスする名前を使用できるようにするデータの量の名前。 C++ では、*変数*他の型のインスタンスは通常呼び出されますが、スカラー データ型のインスタンスを参照するは通常、使用*オブジェクト*です。  
  
 **オブジェクト**: 簡潔さと整合性では、この記事は、用語を使用して*オブジェクト*クラスまたは構造体、および一般的な意味で使用されているときに、任意のインスタンスには参照するには、すべての型が含まれていますスカラー変数を含めています。  
  
 **POD 型**(プレーンな古いデータ): C++ でのデータ型のこの非公式なカテゴリがスカラーである型を参照 (基本型」を参照してください)、または*POD クラス*です。 POD クラスには、POD でもない静的データ メンバーはなく、ユーザー定義のコンストラクター、ユーザー定義のデストラクター、ユーザー定義の代入演算子もありません。 また、POD クラスに仮想関数、基底クラス、プライベートまたは保護された非静的データ メンバーもありません。 POD 型は、外部データ交換によく使用されます。たとえば、C 言語で記述されたモジュール (POD 型しかありません) との交換などです。  
  
## <a name="specifying-variable-and-function-types"></a>変数と関数の型の指定  
 C は、*厳密に型指定*言語でありも*静的に型指定された*以外の場合はすべてのオブジェクトの型、型は決してできません (静的なデータ オブジェクトと混同しないでください) に変更します。   
**変数を宣言するときに**、コード内の型を明示的に指定かを使用して、`auto`初期化子から型を推測するようコンパイラに指示するキーワードです。   
**関数を宣言するときに**、コード内の各引数と戻り値、型を指定する必要がありますまたは`void`関数によって値が返されない場合。 例外は、任意の型の引数を使用できる関数テンプレートを使用する場合です。  
  
 最初に変数を宣言すると、後で型を変更することはできません。 ただし、変数の値または関数の戻り値を異なる型の別の変数にコピーすることはできます。 このような操作が呼び出されて*変換の入力*、これが必要になるが、データの損失や不正確なデータの潜在的な原因もします。  
  
 POD 型の変数を宣言するときは、初期化する (つまり、初期値を指定する) ことを強くお勧めします。 変数を初期化しないと、以前そのメモリ位置にたまたま存在していたビットで構成される "不要な" 値が含まれたままになります。 これは、特に自動的に初期化が行われる別の言語を使用していた場合は、覚えておくべき C++ の重要な側面です。 非 POD クラス型の変数を宣言した場合、コンストラクターにより初期化が実行されます。  
  
 次の例は、それぞれ記述を含む、いくつかの簡単な変数宣言を示しています。 この例は、コンパイラが型情報を使用して、特定の後続の処理を許可または拒否する方法も示しています。  
  
```  
  
int result = 0;              // Declare and initialize an integer.  
double coefficient = 10.8;   // Declare and initialize a floating   
                             // point value.  
auto name = "Lady G.";       // Declare a variable and let compiler   
                             // deduce the type.  
auto address;                // error. Compiler cannot deduce a type   
                             // without an intializing value.  
age = 12;                    // error. Variable declaration must  
                             // specify a type or use auto!  
result = "Kenny G.";         // error. Can’t assign text to an int.  
string result = "zero";      // error. Can’t redefine a variable with  
                             // new type.  
int maxValue;                // Not recommended! maxValue contains   
                             // garbage bits until it is initialized.  
  
```  
  
## <a name="fundamental-built-in-types"></a>基本 (組み込み) 型  
 一部の言語とは異なり、C++ には他のすべての型の派生元となる汎用基本型はありません。 各種言語の Visual C 実装*基本的な型*とも呼ばれる、*組み込み型*です。 これには、`int`、`double`、`long`、`bool` などの数値型だけでなく、`char` 型と `wchar_t` 型 (それぞれ ASCII 文字と UNICODE 文字用) が含まれます。 ほとんどの基本型 (`bool`、`double`、`wchar_t` と関連する型を除く) には、変数に格納できる値の範囲を変更する符号なしのバージョンがあります。 たとえば、32 ビット符号付き整数が格納される `int` は、-2,147,483,648 ～ 2,147,483,647 の値を表すことができます。 32 ビットとしても格納される `unsigned int` には、0 ～ 4,294,967,295 の値を格納できます。 各ケースで格納できる値の合計数は同じです。範囲のみ異なります。  
  
 基本型は、実行可能な操作や他の基本型に変換する方法を制御する組み込みの規則を持つコンパイラにより認識されます。 組み込み型、サイズ、および数値の制限の一覧については、次を参照してください。[基本的な型](../cpp/fundamental-types-cpp.md)です。  
  
 次の図は、組み込み型の相対サイズを示しています。  
  
 ![サイズ (バイト) の構築 (& a) #45; の種類で](../cpp/media/built-intypesizes.png "組み込み inTYpeSizes")  
  
 次の表は、最もよく使用される基本型の一覧です。  
  
|型|サイズ|コメント|  
|----------|----------|-------------|  
|int|4 バイト|整数値の既定のオプション。|  
|double|8 バイト|浮動小数点値の既定のオプション。|  
|bool|1 バイト|true または false になる値を表します。|  
|char|1 バイト|以前の C スタイル文字列内の ASCII 文字や、UNICODE に変換する必要がない std::string オブジェクトの ASCII 文字に使用します。|  
|wchar_t|2 バイト|UNICODE 形式でエンコードできるワイド文字を表します (Windows では UTF-16。他のオペレーティング システムでは異なる場合があります)。 これは、型 `std::wstring` の文字列で使用される文字型です。|  
|unsigned char|1 バイト|C++ には、組み込みの `byte` 型はありません。  バイト値を表すには unsigned char を使用します。|  
|unsigned int|4 バイト|ビット フラグの既定のオプション。|  
|long long|8 バイト|非常に大きな整数値を表します。|  
  
## <a name="the-void-type"></a>void 型  
 `void` 型は、特殊な型です。`void` 型の変数を宣言することはできませんが、型 `void *` (`void` へのポインター) の変数を宣言することはできます。これは、生 (型指定されていない) メモリを割り当てる場合に必要になることがあります。 ただし、`void` へのポインターはタイプ セーフではないため、最新の C++ では通常使用しないことを強くお勧めします。 関数の宣言では、`void` の戻り値は、関数が値を返さないことを意味します。これは、`void` の一般的で適切な使い方です。 C 言語では、パラメーター リストで `void` を宣言するにはパラメーターが 0 の関数が必要でしたが (`fou(void)` など)、を宣言する、最新の C++ ではこの規則が廃止され、`fou()` を宣言する必要があります。 詳細については、次を参照してください。[型変換とタイプ セーフ](../cpp/type-conversions-and-type-safety-modern-cpp.md)です。  
  
## <a name="const-type-qualifier"></a>const 型修飾子  
 組み込み型またはユーザー定義型は、const キーワードで修飾することができます。 また、メンバー関数は `const` で修飾したり、`const` でオーバーロードすることもできます。 `const` 型の値を初期化後に変更することはできません。  
  
```  
  
const double PI = 3.1415;  
PI = .75 //Error. Cannot modify const variable.  
  
```  
  
 `const` 修飾子は関数と変数の宣言で広範囲に使用されるため、"const の正確性" は C++ の重要な概念です。基本的には、`const` を使用して、コンパイル時に値が誤って変更されないことを保証することを意味します。 詳細については、次を参照してください。 [const](../cpp/const-cpp.md)です。  
  
 `const` 型は、const でないバージョンと区別されます。たとえば、`const int` は `int` とは異なる型です。 C++ を使用する`const_cast`演算子を削除する必要がありますとという特殊な状況に*const*変数からです。 詳細については、次を参照してください。[型変換とタイプ セーフ](../cpp/type-conversions-and-type-safety-modern-cpp.md)です。  
  
## <a name="string-types"></a>文字列型  
 厳密には、C++ 言語の型を持たない組み込みの文字列です。`char`と`wchar_t`単一の文字を格納 - 終端の null 値を追加する、これらの型を文字列型の概算の配列を宣言する必要があります (たとえば、ASCII `'\0'`) 最後の有効な文字のいずれかの配列要素に (とも呼ばれる、*C スタイル文字列*)。 C スタイル文字列では、かなり多くのコードを記述するか、外部文字列ユーティリティ ライブラリ関数を使用する必要がありました。 しかし、最新の C++ には、標準ライブラリの型 `std::string` (8 ビットの `char` 型文字列の場合) または `std::wstring` (16 ビットの `wchar_t` 型文字列の場合) があります。 これらの C++ 標準ライブラリのコンテナー見なすことができますのネイティブの文字列型として、準拠している C++ ビルド環境に含まれている標準ライブラリの一部であるためです。 `#include <string>` ディレクティブを使用するだけで、これらの型をプログラムで使用できるようになります  (MFC や ATL を使用している場合、CString クラスも使用できますが、C++ の標準の一部ではありません)。null で終わる文字配列 (前述の C スタイル文字列) は、最新の C++ では使用しないことを強くお勧めします。  
  
## <a name="user-defined-types"></a>ユーザー定義型  
 `class`、`struct`、`union`、または `enum` を定義すると、基本型の場合と同じようにコードの残りの部分ではその構造体が使用されます。 メモリ内には既知のサイズがあり、コンパイル時のチェックを要求し、実行時にプログラムの有効期間を問い合わせるために使用する方法に関する一定の規則もあります。 基本の組み込み型とユーザー定義型の主な相違点は次のとおりです。  
  
-   コンパイラには、ユーザー定義型に関する組み込みの情報はありません。 コンパイル処理中に定義を最初に検出すると、型の学習します。  
  
-   クラス メンバーまたは非メンバー関数として適切な演算子を定義することで (オーバーロードを通じて)、型で実行可能な操作と他の方に変換する方法を指定します。 詳細については、次を参照してください。[関数のオーバー ロード](function-overloading.md)です。  
  
-   静的に型指定する必要はありません (オブジェクトの型が変化することはないという規則)。 機構により、*継承*と*ポリモーフィズム*クラス (クラスのオブジェクトのインスタンスと呼ばれる) のユーザー定義型として宣言された変数でよりも実行時に別の型である可能性がありますコンパイル時。 詳細については、「[継承](../cpp/inheritance-cpp.md)」を参照してください。  
  
## <a name="pointer-types"></a>ポインター型  
 C 言語の初期バージョンからそうであったように、C++ では特別な宣言子 `*` (アスタリスク) を使用して、ポインター型の変数を宣言できます。 ポインター型には、実際のデータ値が格納されているメモリ位置のアドレスが格納されます。 最新の c++ では、これらをいいます*生のポインター*、特殊な演算子を使用して、コードでアクセスおよび`*`(アスタリスク) または`->`(ダッシュと大きい-よりも)。 これと呼ばれます*の逆参照*どれを使用することがスカラーへのポインターまたはオブジェクト内のメンバーへのポインターを逆参照されているかどうかに依存します。 ポインター型の使用は、長い間 C および C++ プログラム開発における最も困難で複雑な側面の 1 つでした。 ここでは、いくつかのファクトと生のポインターを使用する場合は、それが不要になったために必要な (または推奨) の最新の c++ のためのガイドラインについて概説の進化したため、オブジェクトの所有権に生のポインターを使用する、[スマート ポインター](../cpp/smart-pointers-modern-cpp.md) (説明より、このセクションの最後) します。 現在でも、オブジェクトの観察には生のポインターが役立ち、使用してもかまいませんが、オブジェクトの所有権に使用する必要がある場合は慎重に使用し、生のポインターが所有するオブジェクトを作成および破棄する方法について十分に考慮してください。  
  
 まず知る必要がある点は、生のポインター変数を宣言すると、ポインターが逆参照されるときに参照するメモリ位置のアドレスを格納するのに必要なメモリだけが割り当てられるという点です。 データ値自体のメモリの割り当て (とも呼ばれる*バッキング ストア*) がまだ割り当てられていません。 言い換えると、生のポインター変数を宣言することで、実際のデータの変数ではなくメモリ アドレスの変数を作成することになります。 バッキング ストアへの有効なアドレスが含まれることを確認する前にポインター変数を逆参照すると、プログラムで定義されていない動作 (通常は重大なエラー) が発生します。 この種のエラーの例を次に示します。  
  
```  
  
int* pNumber;       // Declare a pointer-to-int variable.  
*pNumber = 10;      // error. Although this may compile, it is  
                    // a serious error. We are dereferencing an  
                    // uninitialized pointer variable with no  
                    // allocated memory to point to.  
  
```  
  
 この例では、実際の整数データまたはそこに割り当てられた有効なメモリ アドレスを格納するメモリを割り当てずに、ポインター型を逆参照しています。 このエラーを修正するコード例を次に示します。  
  
```  
  
    int number = 10;          // Declare and initialize a local integer  
                              // variable for data backing store.  
    int* pNumber = &number;   // Declare and initialize a local integer  
                              // pointer variable to a valid memory  
                              // address to that backing store.  
...  
    *pNumber = 41;            // Dereference and store a new value in   
                              // the memory pointed to by  
                              // pNumber, the integer variable called  
                              // "number". Note "number" was changed, not  
                              // "pNumber".  
  
```  
  
 修正後のコード例では、ローカル スタック メモリを使用して、`pNumber` がポイントするバッキング ストアを作成します。 ここでは、説明を簡単にするために基本型を使用しています。 ポインターのバッキング ストアが動的に割り当てられた領域にあると呼ばれるメモリのほとんどの多くの場合、ユーザー定義の型を実際には、*ヒープ*(または*フリー ストア*) を使用して、`new`キーワード式 (C スタイル プログラミングでは、古い`malloc()`C ランタイム ライブラリ関数が使用されました)。 割り当てられると、これらの変数は通常と呼ばれるオブジェクト、クラス定義に基づいている場合に特にです。 `new` によって割り当てられたメモリは、対応する `delete` ステートメント (または、`malloc()` 関数を使用して割り当てる場合は、C ランタイム関数 `free()`) によって削除される必要があります。  
  
 ただし、これは、動的に割り当てられるオブジェクト、特に複雑なコードと呼ばれるリソース バグの原因で削除することを忘れがち、*メモリ リーク*です。 したがって、最新の C++ では生のポインターを使用しないことを強くお勧めします。 生のポインターをラップする方が適切ではほとんどの場合、[スマート ポインター](../cpp/smart-pointers-modern-cpp.md)、自動的にメモリを解放します (コードがスマート ポインターのスコープ外に出る) 場合は、デストラクターが呼び出される; スマート ポインターを使用して、事実上C++ プログラムでバグのクラス全体を削除します。 次の例では、`MyClass` がパブリック メソッド `DoSomeWork();` を持つユーザー定義型であることを前提としています。  
  
```  
  
void someFunction() {  
    unique_ptr<MyClass> pMc(new MyClass);  
    pMc->DoSomeWork();  
}  
  // No memory leak. Out-of-scope automatically calls the destructor  
  // for the unique_ptr, freeing the resource.  
  
```  
  
 スマート ポインターの詳細については、次を参照してください。[スマート ポインター](../cpp/smart-pointers-modern-cpp.md)です。  
  
 ポインター変換の詳細については、次を参照してください。[型変換とタイプ セーフ](../cpp/type-conversions-and-type-safety-modern-cpp.md)です。  
  
 ポインターの詳細については一般を参照してください[ポインター](../cpp/pointers-cpp.md)です。  
  
## <a name="windows-data-types"></a>Windows のデータ型  
 C および C++ 向けの従来の Win32 プログラミングでは、ほとんどの関数は Windows 固有の typedef マクロと #define マクロ (`windef.h` で定義) を使用して、パラメーターと戻り値の型を指定します。 これら Windows データ型はほとんどの場合のみ特別な名前 (別名) C と C++ の組み込み型を指定します。 これらの typedef とプリプロセッサの定義の一覧については、次を参照してください。 [Windows Data Types](http://msdn.microsoft.com/en-us/4553cafc-450e-4493-a4d4-cb6e2f274d46)です。 HRESULT や LCID など、typedef には便利で内容がわかりやすいものがあります。 INT など、他の typedef には特別な意味がなく、C++ の基本型のエイリアスにすぎません。 他の Windows のデータ型には、C プログラミングおよび 16 ビット プロセッサの時代から残っている名前がありますが、最新のハードウェアやオペレーティング システムでは目的も意味もありません。 として一覧に、Windows ランタイム ライブラリに関連付けられている特殊なデータ型もあります[Windows ランタイムの基本データ型](http://msdn.microsoft.com/en-us/b5735851-ec07-48c1-92b4-ca9f768096f6)です。 最新の C++ では、値の解釈方法について Windows の型が追加の意味を伝えるのでない限り、一般的なガイドラインとして C++ の基本型が推奨されます。  
  
## <a name="more-information"></a>詳細情報  
 C++ の型システムの詳細については、次のトピックを参照してください。  
  
|||  
|-|-|  
|[値型](../cpp/value-types-modern-cpp.md)|説明*値の型*と使用に関連する問題です。|  
|[型変換とタイプ セーフ](../cpp/type-conversions-and-type-safety-modern-cpp.md)|よくある型変換の問題について説明し、その回避方法を示します。|  
  
## <a name="see-also"></a>関連項目  
 [C++ へようこそ](../cpp/welcome-back-to-cpp-modern-cpp.md)   
 [C++ 言語リファレンス](../cpp/cpp-language-reference.md)   
 [.NET 標準ライブラリ](../standard-library/cpp-standard-library-reference.md)