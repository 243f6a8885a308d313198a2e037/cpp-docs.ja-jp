---
title: "コピー コンストラクターとコピー代入演算子 (C++) | Microsoft Docs"
ms.custom: ""
ms.date: "12/03/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "language-reference"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "= 演算子, コピー (オブジェクト)"
  - "値をコピー オブジェクトに代入"
  - "代入演算子, コピー オブジェクト用"
  - "代入ステートメント, コピー (オブジェクト)"
  - "コピー (オブジェクト)"
  - "初期化 (オブジェクトを), コピー オブジェクトによる"
  - "オブジェクト [C++], コピー"
ms.assetid: a94fe1f9-0289-4fb9-8633-77c654002c0d
caps.latest.revision: 12
caps.handback.revision: 12
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# コピー コンストラクターとコピー代入演算子 (C++)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

> [!NOTE]
>  C\+\+ 11 以降では、2 種類の代入 \(*コピーの代入*と*移動の代入*\) が言語でサポートされています。  この記事では、特に明示的に記載しない限り、"代入" はコピーの代入を意味します。  移動の代入については、「[移動コンストラクターと移動代入演算子 \(C\+\+\)](http://msdn.microsoft.com/ja-jp/1442de5f-37a5-42a1-83a6-ec9cfe0414db)」を参照してください。  
>   
>  代入演算と初期化操作では、いずれもオブジェクトがコピーされます。  
  
-   **代入**: あるオブジェクトの値が別のオブジェクトに割り当てられると、最初のオブジェクトが 2 番目のオブジェクトにコピーされます。  次に例を示します。  
  
    ```cpp  
    Point a, b;  
    ...  
    a = b;  
    ```  
  
     の場合、`b` の値が `a` にコピーされます。  
  
-   **初期化**: 初期化は、新しいオブジェクトが宣言されたとき、引数が値によって関数に渡されたとき、または値によって関数から値が返されたときに発生します。  
  
 クラス型のオブジェクトに「コピー」の意味を定義できます。  たとえば、次のコードについて考えます。  
  
```cpp  
TextFile a, b;  
a.Open( "FILE1.DAT" );  
b.Open( "FILE2.DAT" );  
b = a;  
```  
  
 前のコードは、「FILE1.DAT から FILE2.DAT に内容をコピーする」を意味する場合もありますが、「FILE2.DAT を無視して `b` を FILE1.DAT への 2 番目のハンドルにする」という意味もあります。 各クラスには、次のように適切なコピーのセマンティクスを割り当てる必要があります。  
  
-   戻り型としてのクラス型への参照と `operator=` 参照によって渡されるパラメーター \(たとえば、`const`\) と共に代入演算子 `ClassName& operator=(const ClassName& x);` を使用する。  
  
-   コピー コンストラクターを使用する。  コピー コンストラクターの詳細については、「[コンストラクターの宣言に関する規則](../misc/rules-for-declaring-constructors.md)」を参照してください。  
  
 コピー コンストラクターを宣言していない場合、コンパイラはメンバーごとのコピー コンストラクターを生成します。  コピー代入演算子を宣言していない場合、コンパイラはメンバーごとのコピー代入演算子を生成します。 コピー コンストラクターを宣言しても、コンパイラで生成されるコピー代入演算子は抑制されません。また、その逆も同様です。  いずれか 1 つを実装する場合、コードの意味を明確にするために、もう 1 つも実装することをお勧めします。  
  
 メンバーごとの割り当てについては、「[\(NOTINBUILD\) Memberwise Assignment and Initialization](http://msdn.microsoft.com/ja-jp/94048213-8b49-4416-8069-b1b7a6f271f9)」で詳しく説明しています。  
  
 コピー コンストラクターは、*class\-name***&** 型の引数を受け取ります。ここで、 *class\-name* は、コンストラクターが定義されているクラスの名前です。  例:  
  
```cpp  
// spec1_copying_class_objects.cpp  
class Window  
{  
public:  
    Window( const Window& ); // Declare copy constructor.  
    // ...  
};  
  
int main()  
{  
}  
```  
  
> [!NOTE]
>  可能な限り、コピー コンストラクターの引数の型を *const class\-name***&** にします。  これによって、コピー コンストラクターが誤ってコピー元のオブジェクトを変更しないようにすることができます。  また、**const** オブジェクトからコピーできます。  
  
## コンパイラによって生成されたコピー コンストラクター  
 ユーザー定義のコピー コンストラクターなど、コンパイラが生成したコピー コンストラクターは、"*class\-name* への参照" 型の単一の引数を受け取ります。 例外は、すべての基底クラスとメンバーのクラスに、**const** *class\-name***&** 型の単一の引数の取得として宣言されたコピー コンストラクターがある場合です。  このような場合、コンパイラが生成したコピー コンストラクターの引数も **const** です。  
  
 コピー コンストラクターへの引数の型が **const** ではない場合、**const** オブジェクトのコピーによる初期化はエラーを生成します。  逆は true ではありません。引数が **const** の場合、**const** ではないオブジェクトをコピーして初期化できます。  
  
 コンパイラが生成した代入演算子は **const** に関しては同じパターンに従います。 これらの演算子は、すべての基底クラスおよびメンバー クラスの代入演算子が **const** *class\-name&* 型の引数を受け取らない場合は、*class\-name***&** 型の単一の引数を受け取ります。 この場合、クラスの生成された代入演算子は **const** 引数を受け取ります。  
  
> [!NOTE]
>  コピー コンストラクターによって初期化されるか、コンパイラによって生成されるか、またはユーザーによって定義される場合、仮想基底クラスは構築される時点で 1 回だけ初期化されます。  
  
 影響はコピー コンストラクターの影響と似ています。  引数の型が **const** ではない場合、**const** オブジェクトからの割り当てではエラーが発生します。  逆は true ではありません。**const** 値が、**const** ではない値に代入された場合、代入は成功します。  
  
 オーバーロード代入演算子の詳細については、「[代入](../cpp/assignment.md)」を参照してください。  
  
## 参照  
 [特殊なメンバー関数](../misc/special-member-functions-cpp.md)