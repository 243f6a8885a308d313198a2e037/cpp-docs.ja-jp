---
title: "同時実行ランタイムの概要 | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "同時実行ランタイム, アーキテクチャ"
  - "同時実行ランタイム, ラムダ式"
  - "同時実行ランタイム, 概要"
  - "同時実行ランタイム, 要件"
ms.assetid: 56237d96-10b0-494a-9cb4-f5c5090436c5
caps.latest.revision: 22
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
caps.handback.revision: 19
---
# 同時実行ランタイムの概要
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

このドキュメントでは、同時実行ランタイムの概要について説明します。  また、同時実行ランタイムの利点、使用する状況、コンポーネントどうしの対話方法、コンポーネントとオペレーティング システムやアプリケーションとの対話方法について説明します。  
  
> [!IMPORTANT]
>  Visual Studio 2015 以降では、同時実行ランタイムのタスク スケジューラは、ppltasks.h 内の task クラスや関連する型のためのスケジューラではなくなりました。  現在、これらの型では、パフォーマンスや Windows 同期プリミティブとの相互運用性を向上させるために、Windows のスレッド プールが使用されています。  parallel\_for などの並列アルゴリズムでは引き続き、同時実行ランタイムのタスク スケジューラが使用されます。  
  
##  <a name="top"></a> セクション  
 このドキュメントは、次のセクションで構成されています。  
  
-   [同時実行用のランタイムが重要である理由](#runtime)  
  
-   [アーキテクチャ](#architecture)  
  
-   [C\+\+ ラムダ式](#lambda)  
  
-   [必要条件](#requirements)  
  
##  <a name="runtime"></a> 同時実行用のランタイムが重要である理由  
 同時実行用のランタイムでは、同時に実行されるアプリケーションおよびアプリケーション コンポーネントに統一性と予測可能性が提供されます。  同時実行ランタイムの利点の例として、*協調タスク スケジューリング*と*協調ブロッキング*の 2 つがあります。  
  
 同時実行ランタイムで使用される協調タスク スケジューラには、ワーク スティーリング アルゴリズムが実装されており、作業がコンピューティング リソース間に効率的に分散されます。  たとえば、同じランタイムによって管理される 2 つのスレッドを持つアプリケーションがあるとします。  一方のスレッドがスケジュールされたタスクを完了したら、他方のスレッドから作業をオフロードできます。  このメカニズムにより、アプリケーションの全体的な作業負荷のバランスが保たれます。  
  
 また、同時実行ランタイムでは、協調ブロッキングを使用して、リソースへのアクセスを同期する同期プリミティブも提供されます。  たとえば、共有リソースへの排他アクセスを必要とするタスクがあるとします。  ランタイムは協調的なブロッキングによって、最初のタスクがリソースを待機しているときに、残りのクォンタムを使用して別のタスクを実行できます。  このメカニズムにより、コンピューティング リソースを最大限に利用できます。  
  
 \[[トップ](#top)\]  
  
##  <a name="architecture"></a> アーキテクチャ  
 同時実行ランタイムは、並列パターン ライブラリ \(PPL\)、非同期エージェント ライブラリ、タスク スケジューラ、およびリソース マネージャーの 4 つのコンポーネントで構成されます。  これらのコンポーネントは、オペレーティング システムとアプリケーションの間に配置されます。  次の図は、同時実行ランタイムのコンポーネントがオペレーティング システムおよびアプリケーションとの間でどのようにやり取りするかを示しています。  
  
 **同時実行ランタイム アーキテクチャ**  
  
 ![同時実行ランタイム アーキテクチャ](../../parallel/concrt/media/concurrencyrun.png "ConcurrencyRun")  
  
> [!IMPORTANT]
>  タスク スケジューラとリソース マネージャーのコンポーネントは、[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] アプリから、または ppltasks.h の task クラスなどの型を使用している場合には使用できません。  
  
 同時実行ランタイムは非常に*組み合わせ自在*で、既存の機能を結合して機能を拡張できます。  同時実行ランタイムでは、下位のコンポーネントから、並列アルゴリズムなど多数の機能を構成します。  
  
 また、同時実行ランタイムでは、協調ブロッキングを使用して、リソースへのアクセスを同期する同期プリミティブも提供されます。  これらの同期プリミティブの詳細については、「[同期データ構造](../Topic/Synchronization%20Data%20Structures.md)」を参照してください。  
  
 以下のセクションでは、各コンポーネントが備えている機能と使用する場面についての概要を簡単に説明します。  
  
### 並列パターン ライブラリ  
 並列パターン ライブラリ \(PPL\) は、粒度の細かい並列化を実行するための汎用的なコンテナーとアルゴリズムを提供します。  PPL では、コレクションまたはデータのセットに対する計算をコンピューティング リソースに分散する並列アルゴリズムを提供して、*命令型データの並列化*を実現しています。  複数の個別の演算をコンピューティング リソースに分散するタスク オブジェクトを提供して、*タスクの並列化*を可能にしています。  
  
 ローカルの計算で並列実行の利点を活用できる場合は、並列パターン ライブラリを使用します。  たとえば、[concurrency::parallel\_for](../Topic/parallel_for%20Function.md) アルゴリズムを使用して、既存の `for` ループを並列で動作するように変換できます。  
  
 並列パターン ライブラリの詳細については、「[並列パターン ライブラリ \(PPL\)](../../parallel/concrt/parallel-patterns-library-ppl.md)」を参照してください。  
  
### 非同期エージェント ライブラリ  
 非同期エージェント ライブラリ \(または単に*エージェント ライブラリ*\) は、アクターベースのプログラミング モデルに加えて、粒度の粗いデータ フローおよびパイプライン処理タスクのメッセージ パッシング インターフェイスの役割も果たします。  非同期エージェントを使用すると、他のコンポーネントがデータを待機しているときに作業を実行することにより、待機時間を生産的に活用できます。  
  
 相互に非同期通信を行う複数のエンティティがある場合に、エージェント ライブラリを使用します。  たとえば、データをファイルまたはネットワーク接続から読み取って、そのデータをメッセージ パッシング インターフェイスで別のエージェントに送信するエージェントを作成できます。  
  
 エージェント ライブラリの詳細については、「[非同期エージェント ライブラリ](../../parallel/concrt/asynchronous-agents-library.md)」を参照してください。  
  
### タスク スケジューラ  
 タスク スケジューラは、実行時にタスクをスケジュールおよび調整します。  タスク スケジューラは他の処理と連携して行われ、ワーク スティーリング アルゴリズムを使用して処理リソースを最大限に活用します。  
  
 同時実行ランタイムには既定のスケジューラが用意されているため、インフラストラクチャの詳細を管理する必要はありません。  ただし、アプリケーションの品質ニーズを満たすために、独自のスケジューリング ポリシーを用意したり、特定のスケジューラを特定のタスクに関連付けたりすることもできます。  
  
 タスク スケジューラの詳細については、「[タスク スケジューラ](../../parallel/concrt/task-scheduler-concurrency-runtime.md)」を参照してください。  
  
### リソース マネージャー  
 リソース マネージャーの役割は、プロセッサやメモリなどのコンピューティング リソースを管理することです。  リソース マネージャーは、実行時の作業負荷の変更に応答して、効果が最も大きくなる場所にリソースを割り当てます。  
  
 リソース マネージャーは、コンピューティング リソースの抽象化として機能し、主にタスク スケジューラとやり取りします。  リソース マネージャーを使用してライブラリおよびアプリケーションのパフォーマンスを微調整できますが、通常は、並列パターン ライブラリ、エージェント ライブラリ、およびタスク スケジューラに備わった機能を使用します。  これらのライブラリでは、リソース マネージャーを使用して、作業負荷の変更に応じてリソースのバランスを直接的に再調整します。  
  
 \[[トップ](#top)\]  
  
##  <a name="lambda"></a> C\+\+ ラムダ式  
 同時実行ランタイムで定義されている型やアルゴリズムの多くは、C\+\+ テンプレートとして実装されています。  こうした型やアルゴリズムの中には、処理を実行するためのルーチンをパラメーターとして受け取るものがあります。  このパラメーターには、ラムダ関数、関数オブジェクト、または関数ポインターを使用できます。  これらのエンティティは、*処理関数*または*処理ルーチン*とも呼ばれます。  
  
 ラムダ式は、Visual C\+\+ 言語の重要な新機能の 1 つです。ラムダ式を使用すると、並列処理用の処理関数を簡潔に定義できます。  関数オブジェクトおよび関数ポインターを使用すると、既存のコードで同時実行ランタイムを使用できます。  ただし、新しいコードを記述するときには、安全性や生産性の面で優れたラムダ式を使用することをお勧めします。  
  
 次の例では、[concurrency::parallel\_for\_each](../Topic/parallel_for_each%20Function.md) アルゴリズムを複数回呼び出す場合のラムダ関数、関数オブジェクト、および関数ポインターの構文を比較しています。  `parallel_for_each` を呼び出している各コードは、それぞれ異なる手法を用いて [std::array](../../standard-library/array-class-stl.md) オブジェクト内の各要素の 2 乗を計算しています。  
  
 [!code-cpp[concrt-comparing-work-functions#1](../../parallel/concrt/codesnippet/CPP/overview-of-the-concurrency-runtime_1.cpp)]  
  
 **出力**  
  
  **1**  
**256**  
**6561**  
**65536**  
**390625** C\+\+ でのラムダ関数の詳細については、「[ラムダ式](../../cpp/lambda-expressions-in-cpp.md)」を参照してください。  
  
 \[[トップ](#top)\]  
  
##  <a name="requirements"></a> 必要条件  
 次の表は、同時実行ランタイムの各コンポーネントに関連付けられているヘッダー ファイルを示しています。  
  
|コンポーネント|ヘッダー ファイル|  
|-------------|---------------|  
|並列パターン ライブラリ \(PPL\)|ppl.h<br /><br /> concurrent\_queue.h<br /><br /> concurrent\_vector.h|  
|非同期エージェント ライブラリ|agents.h|  
|タスク スケジューラ|concrt.h|  
|リソース マネージャー|concrtrm.h|  
  
 同時実行ランタイムは、[Concurrency](../../parallel/concrt/reference/concurrency-namespace.md) 名前空間で宣言されています   \(この名前空間のエイリアスである [concurrency](../../parallel/concrt/reference/concurrency-namespace.md) も使用できます\)。 `concurrency::details` 名前空間は、同時実行ランタイム フレームワークをサポートしますが、コードから直接使用することを目的としていません。  
  
 同時実行ランタイムは、C ランタイム ライブラリ \(CRT\) の一部として提供されます。  CRT を使用するアプリケーションをビルドする方法の詳細については、「[CRT ライブラリの機能](../../c-runtime-library/crt-library-features.md)」を参照してください。  
  
 \[[トップ](#top)\]