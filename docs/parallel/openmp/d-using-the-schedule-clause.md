---
title: "D: スケジュール句を使用して |Microsoft ドキュメント"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
ms.assetid: bf3d8f51-ea05-4803-bf55-657c12e91efe
caps.latest.revision: "5"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: b51eeb36a4cffafde0e90586fec08d28b9672e5d
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/21/2017
---
# <a name="d-using-the-schedule-clause"></a>D: スケジュール句を使用します。
並列領域には、少なくとも 1 つのバリア、末端で持ち内の別の障壁を必要があります。 各バリアで、チームの他のメンバーは到着する最後のスレッドを待つ必要があります。 すべてのスレッドがほぼ同時にバリアに到達できるようにこの待機時間を最小限に抑えるには、共有の作業を分散します。 作業が含まれている場合は、一部の共有**の**構築では、`schedule`句は、この目的で使用できます。  
  
 スケジュールの選択、同じオブジェクトを繰り返し参照がある場合、**の**コンス トラクターが存在してキャッシュとメモリにアクセスするかどうかのサイズなど、メモリ、システムの特性によって、主に判断できます時間は、uniform または nonuniform です。 このような考慮事項ことする可能性がいくつかのスレッドが比較的少ない作業のループの一部を割り当てられている場合でも同じ一連のループ、配列の要素のセットを一貫して参照する各スレッドがあることをお勧めします。 これを使用して行うことができます、**静的**すべてのループに対して同じ境界内でスケジュールされます。 次の例を注意してください。 2 番目のループ内の下限としてゼロがいなくても使用**k**スケジュールが重要でない場合は、より自然になります。  
  
```  
#pragma omp parallel  
{  
#pragma omp for schedule(static)  
  for(i=0; i<n; i++)  
    a[i] = work1(i);  
#pragma omp for schedule(static)  
  for(i=0; i<n; i++)  
    if(i>=k) a[i] += work2(i);  
}  
```  
  
 その他の例ではそのメモリと見なさアクセスが重要な考慮事項ではないと明記しない限り、すべてのスレッドが比較可能なコンピューティング リソースを受信します。 この場合、スケジュールの選択、**の**コンストラクトは、最も近いの前の間で実行されるすべての共有作業によって異なりますバリアと暗黙的なバリアまたはがある場合、後続のバリアに最も近い。`nowait`句。 スケジュールの各種類では、簡単な例方法を示しますスケジュールこのような最適な選択をする可能性があります。 簡単な説明については、それぞれの例を次に示します。  
  
 **静的**スケジュールにも適している最も簡単な場合は、1 つを含む並列領域**の**同じ作業量を必要とする各イテレーションを構築します。  
  
```  
#pragma omp parallel for schedule(static)  
for(i=0; i<n; i++) {  
  invariant_amount_of_work(i);  
}  
```  
  
 **静的**スケジュールの特徴は、プロパティの各スレッドが約、他のスレッドとのイテレーションの同じ番号を取得するし、各スレッドできます個別を決定できませんに割り当てられるイテレーション。 したがって同期がなくても、作業を分散して、各イテレーションが同じ作業量が必要であるという想定に基づいて、すべてのスレッドは同じ時刻について完了にする必要があります。  
  
 チームの`p`スレッドを使用できます*ceiling (n/p)* 、整数である*q*を満たす*n = p\*q - r*で*0 < = r < p*. 1 つの実装、**静的**スケジュールは、この例に割り当てますの*q*最初の反復*p-1*スレッド、および*q r*最後のスレッドを反復処理します。  別の許容可能な実装が割り当てられる*q*最初の反復*p r*スレッド、および*q-1* 、残りのイテレーション*r*スレッドです。 これは、プログラムは、特定の実装の詳細に依存しないように理由を示しています。  
  
 **動的**スケジュールに適したの大文字と小文字、**の**でさまざまな、または予測不能で作業の金額を必要とするイテレーションを構築します。  
  
```  
#pragma omp parallel for schedule(dynamic)  
  for(i=0; i<n; i++) {  
    unpredictable_amount_of_work(i);  
}  
```  
  
 **動的**スケジュールが待機しないバリアに必要なその最後の反復処理を実行する別のスレッドよりも長くなるため、プロパティによって特徴付けられます。 これは、イテレーションに割り当てられること、一度に 1 つのスレッド同期の各割り当てのために、利用可能になる必要があります。 最小のチャンク サイズを指定することによって、同期のオーバーヘッドを削減できます*k*スレッドが割り当てられているように、1 より大きい*k*までよりも少ない、一度に*k*ままにします。 これにより、その最後のチャンクをで実行する別のスレッドがより長くバリアにスレッドが待機しない*k*反復処理します。  
  
 **動的**スケジュールできる計算リソースをさまざまなスレッドが表示される場合に役立ちます。 各イテレーションの作業の量は変化とほぼ同じ結果を持ちます。 同様に、動的なスケジュールにも役立ちますでスレッドが到着した場合、**の**もいくつかでこのような場合のさまざまな時間は、構築、**ガイド付き**スケジュールが適している可能性があります。  
  
 **ガイド付き**スケジュールは、スレッドがさまざまなタイミングでくる可能性がありますの場合、適切な**の**で各反復処理を必要とする同じ作業量を構築します。 これは、場合に発生することができます、たとえば、**の**コンス トラクターは 1 つまたは複数のセクションの後または**の**構造は`nowait`句。  
  
```  
#pragma omp parallel  
{  
  #pragma omp sections nowait  
  {  
    // ...  
  }  
  #pragma omp for schedule(guided)  
  for(i=0; i<n; i++) {  
    invariant_amount_of_work(i);  
  }  
}  
```  
  
 同様に**動的**、**ガイド付き**スケジュールをその最後の反復処理を実行する別のスレッドがよりも長いまたは最後のバリアでスレッドが待機しないことを保証*k*イテレーション場合のチャンク サイズ*k*を指定します。 このようなスケジュールの間で、**ガイド付き**スケジュールの特徴は、プロパティの数が最も少ない同期が必要とすることです。 チャンク サイズの*k*、一般的な実装が割り当てられます*q = ceiling (n/p)*最初に使用できるスレッドのイテレーションの設定 *n* 大きい方にの*n-q*と*p\*k*、すべてのイテレーションが割り当てられるまでを繰り返します。  
  
 最適なスケジュールの選択がこれらの例では、明確ではないときに、**ランタイム**スケジュールは、さまざまなスケジュールとチャンクのサイズを変更してプログラムを再コンパイルしなくても試す場合に便利です。 最適なスケジュールがプログラムを適用する入力データに (予測可能な方法はいくつか) に依存する場合に役立ちますできます。  
  
 異なるスケジュール間のトレードオフの例を参照してください、1000 回の繰り返し 8 スレッド間での共有を検討してください。 各イテレーションで作業量が固定であると仮定し、時間の単位としてそれを使用します。  
  
 すべてのスレッドが、同時に開始する場合、**静的**スケジュールは、そのコンストラクト同期なしの 125 単位で実行するためです。 1 つのスレッドがの到着が遅れる 100 単位であるとします。 バリアで 100 単位の残りの 7 つのスレッドを待機し、し、225 にコンストラクト全体の実行時間が増加します。  
  
 両方、**動的**と**ガイド付き**スケジュールことを確認してバリアで 1 つ以上の単位のスレッドが待機しないと、138 にしか増加コンス トラクターの実行時間の遅延のスレッドこの単位を使用して、可能性のある同期からの遅延が増加します。 同期の数が 1000 で重要になりますこのような遅延がごくわずかでない場合は、**動的**が唯一の 41 で**ガイド付き**、1 つの既定のチャンク サイズを想定しています。 チャンク サイズが 25 の**動的**と**ガイド付き**それぞれで 150 の単位と、必要な同期を今すぐ数だけ 40、20 から遅延完了両方です。