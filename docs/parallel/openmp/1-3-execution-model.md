---
title: 1.3 実行モデル |Microsoft ドキュメント
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-parallel
ms.topic: conceptual
dev_langs:
- C++
ms.assetid: 85ae8bc4-5bf0-45e0-a45f-02de9adaf716
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 0acdd7a5d9f2dcb58850254281b5c18fd0d1123c
ms.sourcegitcommit: 7019081488f68abdd5b2935a3b36e2a5e8c571f8
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/07/2018
ms.locfileid: "33687895"
---
# <a name="13-execution-model"></a>1.3 実行モデル
OpenMP では、並列実行の fork-join モデルを使用します。 この fork-join モデルは、さまざまな問題を解決するために役立ちますできますが、大きな配列ベースのアプリケーションでは多少合わせてです。 OpenMP の対象は両方として正しく実行並列プログラム (複数のスレッドの実行と完全 OpenMP サポート ライブラリ) プログラムをサポートする、および順次プログラム (ディレクティブは無視し、簡単な OpenMP スタブ ライブラリ)。 ただし、ことしは正しく動作しない順番に実行されたときに、プログラムを開発します。 さらに、並列処理の次数が異なる可能性があります数値結果が異なる数値演算の関連付けが変更されたのため。 たとえば、シリアル加算の削減には、並列リダクションと加算の関連付けのさまざまなパターンがあります。 これらの異なる関連付けでは、浮動小数点加算の結果を変更できます。  
  
 OpenMP C と C++ API で書かれたプログラムと呼ばれる実行の 1 つのスレッドで実行を開始、*マスター スレッド*です。 最初の parallel コンストラクトが出現するまで、マスター スレッドはシリアル領域で実行します。 OpenMP C と C++ API では、**並列**ディレクティブは、parallel コンストラクトを構成します。 Parallel コンストラクトが発生した場合に、マスター スレッドが、スレッドのチームを作成し、チームのマスターになります。 チーム内の各スレッドは、work-sharing コンス トラクターを除く、並行領域の動的範囲内のステートメントを実行します。 Work-sharing コンス トラクターは、同じ順序で、チームのすべてのスレッドで発生する必要があり、関連付けられている構造化ブロック内のステートメントが 1 つまたは複数のスレッドによって実行されます。 Work-sharing コンス トラクターなしの末尾に暗黙的なバリア、`nowait`句は、チーム内のすべてのスレッドで実行します。  
  
 スレッドが共有オブジェクトを変更する場合だけでなく、独自の実行環境も、プログラム内の他のスレッドに影響します。 変更が完了するため、次のシーケンス ポイントで他のスレッドの 1 つの観点から (で定義されているベース言語) を volatile にするオブジェクトが宣言されている場合にのみ保証されます。 それ以外の場合、変更が保証される完了後、変更したスレッドし (または同時に) 他のスレッドが発生する、**フラッシュ**ディレクティブ (暗黙的または明示的に) オブジェクトを指定します。 場合、**フラッシュ**他の OpenMP ディレクティブによって暗黙的に指定されたディレクティブが目的の順序は、副作用が生じることを確認するための十分な追加、明示的なを指定するプログラマの責任である**フラッシュ**ディレクティブです。  
  
 完了すると、parallel コンストラクトのチーム内のスレッドが、暗黙的なバリアに同期してマスター スレッドのみが実行を継続します。 1 つのプログラムでは、parallel コンストラクトの任意の数を指定できます。 結果として、プログラムはフォークし、実行中に何度もを参加させる可能性があります。  
  
 OpenMP C と C++ API では、parallel コンストラクト内から呼び出された関数でディレクティブを使用するプログラマできます。 ディレクティブを parallel コンストラクトの構文の範囲では表示されませんが、動的範囲内にある場合がありますと呼ばれる*孤立した*ディレクティブです。 孤立したディレクティブにより、プログラマは、連続したプログラムにのみ最小限の変更で並列的に、プログラムの主要な部分を実行する機能。 この機能により、ユーザーは、プログラムのコール ツリーの最上位レベルでの parallel コンストラクトのコードし、ディレクティブを使用して呼び出された関数のいずれかで実行を制御します。  
  
 非同期で呼び出す C および C++ では、同じファイルに書き込む関数は、順不同で別のスレッドで書き込まれたデータが表示される出力を可能性がありますを出力します。 同様に、同じファイルから読み取られた関数の入力に非同期で呼び出すには、順不同でデータを読み取ることができます。 I/O の使用が同期されていない各スレッドが別のファイルにアクセスするように、I/O 関数の直列実行と同じ結果を生成します。