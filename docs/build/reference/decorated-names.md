---
title: "装飾名 |Microsoft ドキュメント"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-tools
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
helpviewer_keywords:
- decorated names, definition
- name decoration [C++]
- names [C++], decorated
ms.assetid: a4e9ae8e-b239-4454-b401-4102793cb344
caps.latest.revision: "10"
author: corob-msft
ms.author: corob
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: a2ad7fc8e6d9b7fa261d7811086ef02738c77e49
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/21/2017
---
# <a name="decorated-names"></a>装飾名
C および C++ プログラム内の関数、データ、オブジェクトは、内部ではそれぞれの装飾名で表されます。 A*装飾名*オブジェクト、データ、または関数定義のコンパイル時に、コンパイラによって作成されたエンコードされた文字列します。 これにより、呼び出し規則、型、関数のパラメーター、およびその他の情報が、名前と共に記録されます。 呼ばれるこの名前の装飾*名前マングル*により、正しい関数を検索、リンカー、およびオブジェクトの実行可能ファイルをリンクするときにします。  
  
 装飾名の名前付け規則は、Visual C++ のさまざまなバージョンごとに変化しており、ターゲット アーキテクチャによっても異なる場合があります。 Visual C++ を使用して作成されたソース ファイルと正しくリンクするには、C および C++ の DLL とライブラリを、同じコンパイラ ツールセット、フラグ、およびターゲット アーキテクチャを使用してコンパイルする必要があります。  
  
 **目次**  
  
-   [装飾名の使用](#Using)  
  
-   [C++ の形式の装飾名](#Format)  
  
-   [C の装飾形式名](#FormatC)  
  
-   [装飾名の確認](#Viewing)  
  
-   [非装飾の表示名](#Undecorated)  
  
##  <a name="Using"></a>装飾名の使用  
 正常にコンパイルされ、リンクされるコードを記述するために、通常は装飾名を把握している必要はありません。 装飾名は、コンパイラおよびリンカー内部の実装の詳細です。 通常、ツールは非装飾形式の名前を処理できます。 ただし、リンカーやその他のツールに関数名を指定するときは、装飾名が必要な場合もあります。 たとえば、オーバーロードされた C++ 関数、名前空間のメンバー、クラス コンストラクター、デストラクターと、特殊メンバー関数を一致させるには、装飾名を指定する必要があります。 オプション フラグや、装飾名を必要とするその他の状況の詳細については、使用しているツールおよびオプションに関するドキュメントを参照してください。  
  
 関数名、クラス、呼び出し規約、戻り値の型、またはいずれかのパラメーターを変更する場合、装飾名も同様に変更されます。 この場合、新しい装飾名を取得し、それを装飾名が指定されているすべての場所で使用する必要があります。  
  
 名前の装飾は、他のプログラミング言語で記述されたコードにリンクする場合や、他のコンパイラを使用する場合にも重要です。 コンパイラによって、使用する名前装飾規約は異なります。 実行可能ファイルを別の言語で記述されたコードにリンクする場合、エクスポートおよびインポートされた名前と呼び出し規約を一致させるには、特別な配慮が必要です。 アセンブリ言語のコードを Visual C++ で記述されたソース コードにリンクするには、Visual C++ の装飾名と呼び出し規則を使用する必要があります。  
  
##  <a name="Format"></a>C++ の形式の装飾名  
 C++ の関数の装飾名には、次の情報が含まれます。  
  
-   関数名。  
  
-   関数をメンバーに持つクラス (その関数がメンバー関数の場合)。 これには、関数を含むクラスの外側のクラスなども含まれます。  
  
-   関数が属している名前空間 (その関数が名前空間の一部である場合)。  
  
-   関数のパラメーターの型。  
  
-   呼び出し規約  
  
-   関数の戻り値の型。  
  
 装飾名では、関数とクラスの名前はエンコードされます。 装飾名の残りの部分は、コンパイラとリンカーに対してのみ内部的な意味を持つコードです。 C++ の非装飾名および装飾名の例を次に示します。  
  
|非装飾名|装飾名|  
|----------------------|--------------------|  
|`int a(char){int i=3;return i;};`|`?a@@YAHD@Z`|  
|`void __stdcall b::c(float){};`|`?c@b@@AAGXM@Z`|  
  
##  <a name="FormatC"></a>C の装飾形式名  
 C の関数の装飾形式は、次の表に示すように、その宣言で使用される呼び出し規則によって決まります。 これは、C++ のコードが `extern "C"` リンケージを持つように宣言されている場合に使用される装飾形式でも同様です。 既定の呼び出し規約は `__cdecl` です。 64 ビット環境では、関数は装飾されません。  
  
|呼び出し規則|[装飾]|  
|------------------------|----------------|  
|`__cdecl`|先頭にアンダー スコア (**_**)|  
|`__stdcall`|先頭にアンダー スコア (**_**) および、末尾にアット マーク (@) 後に 10 進数のパラメーター リスト内のバイト数|  
|`__fastcall`|先頭と末尾にアット マーク (@) があり、その後ろにパラメーター リスト内のバイト数を表す 10 進数が続きます。|  
|`__vectorcall`|末尾に 2 つのアット マーク (@@) があり、その後にパラメーター リスト内のバイト数が 10 進数で続きます|  
  
##  <a name="Viewing"></a>装飾名の確認  
 データ、オブジェクト、関数定義、または関数プロトタイプを含むソース ファイルをコンパイルした後に、装飾形式のシンボル名を取得できます。 プログラム内の修飾名を確認するために、次のいずれかのメソッドを使用できます。  
  
-   #### <a name="to-use-a-listing-to-view-decorated-names"></a>リスティング ファイルを使用して装飾名を確認するには  
  
    1.  データ、オブジェクト、または関数の定義またはプロトタイプを含むソース ファイルをコンパイルしてリストを生成、[リスティング ファイルの種類](../../build/reference/fa-fa-listing-file.md)コンパイラ オプションのソース コードを持つアセンブリに設定 (**/FAs**)。  
  
         たとえば、入力`cl /c /FAs example.cpp`、リスティング ファイルを生成する開発者コマンド プロンプトで example.asm です。  
  
    2.  結果として得られるリスティング ファイルから、先頭が PUBLIC で、末尾にはセミコロンと非装飾のデータまたは関数名が続く行を見つけます。 PUBLIC とセミコロンの間にあるシンボルが、装飾名です。  
  
-   #### <a name="to-use-dumpbin-to-view-decorated-names"></a>DUMPBIN を使用して装飾名を確認するには  
  
    1.  .Obj または .lib ファイルにエクスポートされたシンボルを表示するには、次のように入力します。 `dumpbin /symbols` `objfile`開発者コマンド プロンプトでします。  
  
    2.  装飾形式のシンボルを見つけるには、かっこに囲まれた非装飾名を探します。 装飾名は、同じ行に、パイプ (&#124;) の後に文字と非装飾名の前にします。  
  
##  <a name="Undecorated"></a>非装飾の表示名  
 undname.exe を使用すると、装飾名を非装飾形式に変換できます。 変換の動作を次の例に示します。  
  
```  
C:\>undname ?func1@a@@AAEXH@Z  
Microsoft (R) C++ Name Undecorator  
Copyright (C) Microsoft Corporation. All rights reserved.  
  
Undecoration of :- "?func1@a@@AAEXH@Z"  
is :- "private: void __thiscall a::func1(int)"  
```  
  
## <a name="see-also"></a>参照  
 [C/C++ ビルド ツール](../../build/reference/c-cpp-build-tools.md)   
 [extern を使用したリンケージの指定](../../cpp/using-extern-to-specify-linkage.md)