---
title: "IEEE 浮動小数点表現 |Microsoft ドキュメント"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-tools
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- C++
helpviewer_keywords:
- float keyword
- real*8 value
- floating-point numbers, IEEE representation
- double data type, floating-point representation
- IEEE floating point representation
- real*10 value
- long double
- real*4 value
ms.assetid: 537833e8-fe05-49fc-8169-55fd0314b195
caps.latest.revision: 
author: corob-msft
ms.author: corob
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: 17fae0cbb16208d5c7e7346f354f3501e4803d96
ms.sourcegitcommit: 9239c52c05e5cd19b6a72005372179587a47a8e4
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/16/2018
---
# <a name="ieee-floating-point-representation"></a>IEEE 浮動小数点表現
Microsoft Visual C は、IEEE 数値標準に準拠したです。 実数の 3 種類の内部表現があります。 Real\*4 と real\*8 は、Visual C で使用されます。 Real\*4 は、word を使用して宣言されている**float**です。 Real\*8 は、word を使用して宣言されている**二重**です。 Windows 32 ビットのプログラミングでは、`long double`データ型にマップ**二重**です。 ただし、アセンブリ言語サポート、実数を使用した計算 * 10 個のデータ型。  
  
 値は、次のように格納されます。  
  
|[値]|として格納されています。|  
|-----------|---------------|  
|real * 4|符号ビット、指数 8 ビット、仮数 23 ビット|  
|real * 8|符号ビット、11 ビット指数 52 ビット仮数部|  
|real * 10|符号ビット、指数 15 ビット、64 ビットの仮数部|  
  
 リアルタイム * 4 と real\*8 形式は、のでのみ 23 または 52 ビットが格納されている場合でも、実際に 24 ビットまたは 53 ビット、仮数、メモリに保存されていない仮数部が想定した先頭 1 です。 Real\*10 形式は、このビットを実際に格納します。  
  
 指数は、その最大値の半分でバイアスされます。 これは、実際の指数部を取得する格納された指数からバイアス値を減算することを意味します。 格納された指数がバイアス値より小さい場合は、負の指数実際になります。  
  
 指数は、次のようにバイアスされます。  
  
|指数|バイアス|  
|--------------|---------------|  
|8 ビット (real * 4)|127|  
|11 ビット (real * 8)|1023|  
|15 ビット (real * 10)|16383|  
  
 これらの指数が; 10 の累乗ではありません。これらは、2 の累乗です。 つまり、8 ビットで格納される指数は最大 127 を指定できます。 2 * * 127 の値は 10 にほぼ等しく\*\*38 で、実際の実際の制限は、\*4 です。  
  
 仮数部がフォームの進小数として格納されている... 1.XXX です。 この割合は、1 以上 2 未満の値を持ちます。 実数は常に正規化された形式で格納することに注意してください。つまり、仮数部が左シフトされ、仮数の上位ビットは常に 1 です。 このビットが 1 では常に、ためにと見なされます (格納しません real * 4 と real\*8 形式です。 バイナリ (ない 10 進数) ポイントは、先頭の 1 の右横にあると見なされます。  
  
 形式を次に、さまざまなサイズのとおりです。  
  
|形式|1 バイト|バイト 2|3 バイト|バイト 4|...|バイト n|  
|------------|------------|------------|------------|------------|---------|------------|  
|real * 4|`SXXX XXXX`|`XMMM MMMM`|`MMMM MMMM`|`MMMM MMMM`|||  
|real * 8|`SXXX XXXX`|`XXXX MMMM`|`MMMM MMMM`|`MMMM MMMM`|...|`MMMM MMMM`|  
|real * 10|`SXXX XXXX`|`XXXX XXXX`|`1MMM MMMM`|`MMMM MMMM`|...|`MMMM MMMM`|  
  
 `S` 符号ビット、`X`の指数部のビットは、および`M`の仮数部のビットは、します。 最上位ビットが実際にいると見なすことに注意してください * 4 と real\*8 書式を設定しますが、実際のバイト 3 では、「1」として存在\*10 形式です。  
  
 バイナリのポイントを正しくシフトするには、最初指数しバイナリの位置を右に移動したりした適切な数のビットを左します。  
  
## <a name="examples"></a>使用例  
 実際には、いくつか例を次に * 4 つの形式。  
  
-   次の例では、符号ビットが 0 の場合、格納された指数 128、または 100 0000 127 +1 は 2 進法で 0。 格納された仮数 (1)。000 0000 ...0000 0000 は、暗黙的な先頭 1 とバイナリのポイント、実際の仮数部が 1 つであるためです。  
  
    ```  
                        SXXX XXXX XMMM MMMM ... MMMM MMMM  
    2   =  1  * 2**1  = 0100 0000 0000 0000 ... 0000 0000 = 4000 0000  
    ```  
  
-   符号ビットが設定される点を除いて、-2 の場合も同じです。 これは、すべての IEEE 形式の浮動小数点数の場合は true です。  
  
    ```  
    -2  = -1  * 2**1  = 1100 0000 0000 0000 ... 0000 0000 = C000 0000  
    ```  
  
-   仮数は同じで、指数部が 1 ずつ増えます (バイアスをかけた値は 129、バイナリで 100 0000 は 1 です。  
  
    ```  
    4  =  1  * 2**2  = 0100 0000 1000 0000 ... 0000 0000 = 4080 0000  
    ```  
  
-   同じ指数部の仮数部が半分大きい-it の (1)。100 0000 しています.0000 0000、バイナリの分数は、これ以降は 1 1/2 (小数部の桁の値は 1/2、1/4、1/8、およびなど)。  
  
    ```  
    6  = 1.5 * 2**2  = 0100 0000 1100 0000 ... 0000 0000 = 40C0 0000  
    ```  
  
-   2 つ、仮数の指数は同じは 2 つ以上 127 文字で、またはバイナリで 011 1111 は 1 です。  
  
    ```  
    1  = 1   * 2**0  = 0011 1111 1000 0000 ... 0000 0000 = 3F80 0000  
    ```  
  
-   バイアスをかけたの指数部は 126、011 1111 0 のバイナリと仮数は (1)。100 0000 ...0000 0000 が 1 1/2。  
  
    ```  
    .75 = 1.5 * 2**-1 = 0011 1111 0100 0000 ... 0000 0000 = 3F40 0000  
    ```  
  
-   いる点を除き、2 つとまったく同じ 1/4 を表すビットが設定仮数部。  
  
    ```  
    2.5 = 1.25 * 2**1 = 0100 0000 0010 0000 ... 0000 0000 = 4020 0000  
    ```  
  
-   1/10 では、バイナリ内の繰り返しの分数がします。 仮数 1.6 だけよりは、バイアスをかけた指数という 1.6 が 16 で割ることがある (これはバイナリで、10 進数で 123 011 1101 1 です)。 実際の指数は 123 127 = - 4 で、乗算に使用する場合の係数が 2 * *-4 = 1/16 であることを意味します。 ストアドの仮数部が最後のビットで切り上げ注 — を表す数をできるだけ正確に表すしようとします。 (理由 1/10 と 1/100 はバイナリで正確に表現できる理由を 1/3 は 10 進数で表現できる正確に一致しないことに似ています)。  
  
    ```  
    0.1 = 1.6 * 2**-4 = 0011 1101 1100 1100 ... 1100 1101 = 3DCC CCCD  
    ```  
  
-   `0  = 1.0 * 2**-128 = all zeros--a special case.`  
  
## <a name="see-also"></a>関連項目  
 [浮動小数点数の精度の低下](../../build/reference/why-floating-point-numbers-may-lose-precision.md)