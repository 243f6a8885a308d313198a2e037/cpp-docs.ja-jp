---
title: "ガイド付き最適化のプロファイル | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "最適化, ガイド付きプロファイル [C++]"
  - "ガイド付き最適化のプロファイル"
ms.assetid: 2225c307-d3ae-42c1-8345-a5a959d132dc
caps.latest.revision: 26
author: "corob-msft"
ms.author: "corob"
manager: "ghogen"
caps.handback.revision: 24
---
# ガイド付き最適化のプロファイル
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

ガイド付き最適化のプロファイルによって出力ファイルを最適化できます。この場合、オプティマイザーは .exe ファイルまたは .dll ファイルのテスト実行データを使用します。  このデータは、稼働環境でのプログラムの実行動作を示します。  
  
 ガイド付き最適化のプロファイルは x86 または [!INCLUDE[vcprx64](../Token/vcprx64_md.md)] のネイティブ ターゲットにのみ使用できます。  ガイド付き最適化のプロファイルは、共通言語ランタイムで実行する出力ファイルでは使用できません。  **\/clr** でコンパイルを行い、混合ネイティブおよびマネージ コードを持つアセンブリを生成した場合でも、ガイド付き最適化のプロファイルはネイティブ コードだけで使用することはできません。  IDE でこれらのオプション セットを使用してプロジェクトのビルドを試みると、結果としてビルド エラーが発生します。  
  
> [!NOTE]
>  プロファイリングのテスト実行から収集される情報により、**\/Ob**、**\/Os**、または **\/Ot** を指定する場合に有効な最適化がオーバーライドされます。  詳細については、「[\/Ob \(関数のインライン展開\)](../../build/reference/ob-inline-function-expansion.md)」および「[\/Os、\/Ot \(実行可能ファイルのサイズの優先、実行速度の優先\)](../../build/reference/os-ot-favor-small-code-favor-fast-code.md)」を参照してください。  
  
 パフォーマンス ハブと診断ハブで自動化された Visual C\+\+ 用ガイド付き最適化のプロファイル プラグインを使用して、Visual Studio 内の最適化プロセスを簡略化および合理化できます。また、Visual Studio またはコマンド ラインで最適化手順を手動で実行することもできます。  Microsoft では、使いやすいプラグインをお勧めします。  アプリを最適化するためにプラグインを入手して使用する方法については、「[ガイド付き最適化のプロファイル プラグイン](../../build/reference/profile-guided-optimization-in-the-performance-and-diagnostics-hub.md)」を参照してください。  
  
 ガイド付き最適化のプロファイル プラグインとガイド付き最適化のプロファイルの手動操作は、どちらも次の手順に従ってアプリを最適化します。  
  
-   [\/GL](../../build/reference/gl-whole-program-optimization.md) を指定して、1 つ以上のソース コード ファイルをコンパイルします。  
  
     ガイド付きプロファイルが実行時の動作をキャプチャして最適化テストを実行している間に、\/GL で作成された各モジュールを検証できます。  ガイド付き最適化のプロファイル ビルド内のすべてのモジュールは、\/GL を指定してコンパイルする必要はありません。  ただし、\/GL を指定してコンパイルされたこれらのモジュールのみがインストルメント化され、ガイド付き最適化のプロファイルに使用できるようになります。  
  
-   [\/LTCG:PGINSTRUMENT](../../build/reference/ltcg-link-time-code-generation.md) にリンクします。  
  
     \/LTCG:PGINSTRUMENT によって、空の .pgd ファイルが作成されます。  テスト実行データが追加された .pgd ファイルは、次のリンク ステップ \(最適化イメージの作成\) での入力として使用できます。  \/LTCG:PGINSTRUMENT を指定する場合、[\/PGD](../../build/reference/pgd-specify-database-for-profile-guided-optimizations.md) に .pgd ファイルの既定以外の名前や場所をオプションで指定できます。  
  
-   アプリケーションのプロファイリングを行います。  
  
     プロファイリングされた EXE セッションが終了するたび、またはプロファイリングされた DLL がアンロードされるたびに、*appname*\!\#.pgc ファイルが作成されます。  .pgc ファイルには、特定のアプリケーションのテスト実行情報が含まれます。  \# は 1 から始まる番号で、ディレクトリ内の他の *appname*\!\#.pgc ファイルの数に従って 1 つずつ値が増加します。  テスト実行の結果が目的の最適化のシナリオを示さない場合は、.pgc ファイルを削除できます。  
  
     テスト実行中に、強制的に、開いている .pgc ファイルを閉じ、[pgosweep](../../build/reference/pgosweep.md) ユーティリティを使用して新しい .pgc ファイルを作成できます。たとえば、テスト シナリオの終了がアプリケーションの終了と一致しない場合などです。  
  
     アプリケーションのプロファイリングを行うときに、`PogoSafeMode` オプションを使用できます。  このオプションを使用することで、アプリケーションをセーフ モードと高速モードのどちらでプロファイリングするかを指定できます。  これらのモードの詳細については、「[PogoSafeMode](../../build/reference/pogosafemode.md)」を参照してください。  
  
-   \/LTCG:PGOPTIMIZE にリンクします。  
  
     \/LTCG:PGOPTIMIZE によって、最適化されたイメージが作成されます。  このステップでは、.pgd ファイルを入力として使用します。  詳細については、「[\/LTCG \(リンク時のコード生成\)](../../build/reference/ltcg-link-time-code-generation.md)」を参照してください。  
  
 最適化された出力ファイルを作成し、追加のプロファイリングによりさらに最適化されたイメージを作成できるかどうかを後で判断することもできます。  インストルメントされたイメージとその .pgd ファイルを使用できる場合は、追加のテストを実行し、最適化されたイメージをより新しい .pgd ファイルでビルドし直すことができます。  
  
 ガイド付き最適化のプロファイルの一覧を次に示します。  
  
-   インライン展開 – たとえば、関数 B を頻繁に呼び出す関数 A があり、関数 B が比較的小さい場合は、ガイド付き最適化のプロファイルにより、関数 B が関数 A にインライン展開されます。  
  
-   **仮想呼び出し推理** – 仮想呼び出し、または関数ポインターからのその他の呼び出しが特定の関数を頻繁に呼び出す場合は、ガイド付き最適化のプロファイルにより、条件付きで実行される直接呼び出しを頻繁に呼び出される関数に挿入し、その直接呼び出しをインライン展開できます。  
  
-   レジスタの割り当て – プロファイル データで最適化を行うと、レジスタの割り当てが改善されます。  
  
-   基本ブロックの最適化 – 基本ブロックの最適化を行うと、一定のフレーム内で一時的に実行する一般的な実行基本ブロックをローカルの同じページ セットに配置できます。  これにより使用されるページ数が最小限に抑えられ、メモリのオーバーヘッドが最小限になります。  
  
-   **サイズ\/速度の最適化** – プログラムで時間を要する関数の速度を最適化できます。  
  
-   **関数のレイアウト** – 呼び出しグラフおよびプロファイリングされた呼び出し元\/呼び出し先の動作に基づいて、同じ実行パスになる傾向のある関数を同じセクション内に配置します。  
  
-   条件付き分岐の最適化 – 値プローブを使用し、switch ステートメント内の特定の値が他の値よりも頻繁に使用されているかどうかを、ガイド付き最適化のプロファイルで検出できます。  この値は switch ステートメントから取得できます。  また、if ブロックまたは else ブロックのどちらがより頻繁に true になるかに応じて、このどちらかのブロックを最初に置くようにオプティマイザーが if\/else を並べ替えることができる場合には、これと同じことを if\/else 命令でも行うことができます。  
  
-   **実行されないコードの分離** – プロファイリングの実行中に呼び出されないコードを、一連のセクションの最後に追加した特別なセクションに移動します。  これにより、頻繁に使用されるページからこのセクションが切り離されます。  
  
-   EH コードの分離 – 例外的な条件の場合にのみ例外が発生することがガイド付き最適化のプロファイルで判断できる場合は、例外的に実行される EH コードを別のセクションに移動できます。  
  
-   メモリの組み込み – 組み込みが頻繁に呼び出されるかどうかを判断できる場合は、組み込みの拡張をより的確に判断できます。  また、組み込みは、移動またはコピーのブロック サイズに基づいて最適化することもできます。  
  
 IDE またはコマンド ラインで手動で最適化を実行する方法の詳細については、「[チュートリアル: ガイド付き最適化のプロファイルの使用](http://msdn.microsoft.com/ja-jp/6e36421b-ec8c-4626-9c29-fa5ffb6f27f8)」を参照してください。  
  
## このセクションの内容  
 [ガイド付き最適化のプロファイル プラグイン](../../build/reference/profile-guided-optimization-in-the-performance-and-diagnostics-hub.md)  
  
 [ガイド付き最適化のプロファイル用ツール](../../build/reference/tools-for-manual-profile-guided-optimization.md)  
  
 [方法 : 複数の PGO プロファイルを単一のプロファイルにマージする](../Topic/How%20to:%20Merge%20Multiple%20PGO%20Profiles%20into%20a%20Single%20Profile.md)  
  
## 参照  
 [C と C\+\+ のビルド ツール](../Topic/C-C++%20Build%20Tools.md)