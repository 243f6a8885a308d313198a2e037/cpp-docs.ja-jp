---
title: 一般的な Visual C の ARM 移行問題 |Microsoft ドキュメント
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-tools
ms.topic: conceptual
dev_langs:
- C++
ms.assetid: 0f4c434e-0679-4331-ba0a-cc15dd435a46
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 04253b5d71de75f6a06f2934dae24df2e6d4e3e2
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/03/2018
---
# <a name="common-visual-c-arm-migration-issues"></a>Visual C++ の ARM への移行に関する一般的な問題

Microsoft Visual C++ (MSVC) を使用すると同じ C++ ソース コードを可能性があります結果と異なる、ARM アーキテクチャに x86 または x64 のアーキテクチャではよりもします。

## <a name="sources-of-migration-issues"></a>移行に関する問題の原因

X86 または x64 のアーキテクチャからコードを ARM アーキテクチャに移行するときに発生する問題の多くは、未定義または指定されていない、実装定義の動作を呼び出すことがありますソース コードの構造に関連付けられます。

*未定義の動作*は C++ 標準が定義されていない動作と妥当な結果を持たない操作によって発生した: 浮動小数点値を符号なし整数に変換するなど、位置の番号によって、値をシフト負の値またはその型の昇格されたビット数を超えています。

*実装で定義された動作*C++ 標準では、定義を文書化するコンパイラの販売元の動作です。 プログラムはことができる場合でも、そのようにできない可能性がありますポータブル、実装定義の動作に安全に依存します。 実装定義の動作の例には、組み込みのデータ型、およびそのアラインメント要件のサイズが含まれます。 実装定義の動作の影響を受ける操作の例は、可変個の引数リストにアクセスします。

*動作を指定しない*は C++ 標準のままに意図的に非確定的な動作です。 動作は、非決定的と見なされますが、未定義の動作の特定の呼び出しはコンパイラ実装によって決まります。 ただし、コンパイラ仕入先、結果を事前に定義または同等の呼び出しの動作の一貫性を保証するための要件はありませんし、ドキュメントの要件はありません。 未定義の動作の例では、関数の呼び出しに引数を含めるには、サブ式が評価される順序です。

その他の移行に関する問題が原因で ARM および C++ 標準と異なる方法で対話する x86 または x64 のアーキテクチャのハードウェアが異なる。 たとえば、x86 および x64 アーキテクチャの強力なメモリ モデルが`volatile`-特定の種類の過去のスレッド間通信を容易にするために使用されているいくつか追加のプロパティに変数を修飾します。 この使用をサポートしていない、ARM アーキテクチャの弱いメモリ モデルもは、C++ 標準で必要とします。

> [!IMPORTANT]
>  `volatile`向上 x86 および x64、これらの追加プロパティで、スレッド間通信の制限付きのフォームを実装するために使用する一部のプロパティが実装するための十分なスレッド間の通信に一般的です。 C++ 標準では、代わりに、適切な同期プリミティブを使用して、このような通信を実装することをお勧めします。

さまざまなプラットフォームでは、異なる方法でこれらの種類の動作を express 可能性があります、ためプラットフォーム間でのソフトウェアの移植でき、困難なバグが発生しやすい場合は、特定のプラットフォームの動作に依存しています。 これらの種類の動作の多く発生する可能性が安定して表示される可能性があります、少なくとも移植可能でない、それらの証明書利用者がおり動作が定義されていないか、未指定の場合も、エラーがします。 このドキュメントに示されているが、動作もは、依存しないようにし、コンパイラや CPU 実装を後で変更します。

## <a name="example-migration-issues"></a>例の移行に関する問題

このドキュメントの残りの部分では、これらの C++ 言語要素の動作の違いがさまざまなプラットフォームで異なる結果を生成する方法について説明します。

### <a name="conversion-of-floating-point-to-unsigned-integer"></a>浮動小数点数の符号なし整数への変換

ARM アーキテクチャは、浮動小数点値の 32 ビット整数への変換は、浮動小数点値は、範囲の整数が表すことができる場合、整数が表すことのできる最も近い値に飽和です。 X86 と x64 のアーキテクチャで変換周りで折り返されます場合は、整数の符号なし、またはに設定されている-2147483648 整数が署名されている場合。 浮動小数点値の小さい整数型への変換を直接サポートなしのこれらのアーキテクチャ代わりに、32 ビットに、変換が実行し、結果は、小さいサイズに切り捨てられます。

ARM アーキテクチャの飽和状態と切り捨ての組み合わせは意味を 32 ビット整数を飽和なりますよりも大きい値の結果が切り捨てられた、符号なしの型への変換がその小さい符号なしの型を正しく飽和する、小さい型は、完全な 32 ビット整数が飽和状態が小さすぎる表すことができます。 32 ビットの符号付き整数に、変換を正しくも飽和が彩度の高い、符号付き整数の切り捨てに対し肯定的な飽和状態になって値の場合は-1 と 0 値の悪影響を及ぼす飽和状態になります。 小さい符号付き整数への変換には、予測可能ではない切り捨てられた結果が生成されます。

、X86 および x64 アーキテクチャの符号なし整数の変換を折り返して動作と符号付き整数変換ではオーバーフローについては、切り捨て、と共に明示的な評価を組み合わせた結果ようにシフトするほとんどしている場合に予期しません。大きすぎます。

これらのプラットフォームは、NaN (Not a Number) の整数型への変換の処理方法も異なります。 Arm 版、NaN は 0x00000000; に変換します。x86 および x64、0x80000000 に変換します。

変換される整数型の範囲内で値がわかっている場合、浮動小数点の変換で依存だけことができます。

### <a name="shift-operator---behavior"></a>シフト演算子 (\< \< >>) の動作

ARM アーキテクチャの値に移動できる左または右最大 255 ビット パターンの繰り返しが開始される前にします。 X86 および x64 のアーキテクチャのパターンが繰り返されます 32 のすべての倍数でパターンのソースが 64 ビット変数; しない限り、その場合は、x 64、およびソフトウェアの実装が採用されている、x86 256 のすべての倍数で 64 のすべての倍数でパターンが繰り返されます。 たとえば、32 の位置の左シフト 1 の値を持つ、32 ビット変数に ARM では、結果は 0、on x86 結果は 1 で x64 で結果も 1 です。 ただし、値のソースが 64 ビットの変数の場合は、次の 3 つすべてのプラットフォームで、結果は、4294967296、値は「回り」x64、または ARM 上の 256 の位置および x86 で 64 の位置がシフトまで。

ソースの種類のビット数を超えるシフト演算の結果は定義されないため、コンパイラがすべての状況で動作の一貫性がある必要はありません。 たとえば、シフトの両方のオペランドはコンパイル時に既知の場合コンパイラ可能性がありますプログラム内部ルーチンを使用して、シフトの結果を事前計算して、シフト演算の代わりに、結果を置き換えることによって最適化します。 シフト数が大きすぎるか、負の値の場合は、内部のルーチンの結果が、CPU によって実行される同じ shift 式の結果と異なる場合があります。

### <a name="variable-arguments-varargs-behavior"></a>可変個の引数 (vararg) の動作

ARM アーキテクチャでは、可変個の引数リストから、スタックに渡されるパラメーターが配置適用されます。 たとえば、64 ビットのパラメーターは 64 ビットの境界に配置されます。 X86 と x64 の場合は、スタックに渡される引数が配置対象とパック緊密に。 この違いには、可変個引数関数のような可能性があります`printf`を目的としていた ARM 上の余白として可変個の引数リストの予期されるレイアウトが正確に一致しない場合も、x86 上でいくつかの値のサブセットの動作がありますもメモリ アドレスを読み取るまたは x64 のアーキテクチャです。 次の例について考えます。

```C
// notice that a 64-bit integer is passed to the function, but '%d' is used to read it.
// on x86 and x64 this may work for small values because %d will “parse” the low-32 bits of the argument.
// on ARM the calling convention will align the 64-bit value and the code will print a random value
printf("%d\n", 1LL);
```

バグを修正して、正しい形式の仕様を使用することを確認することでこのケースでは、できるように、引数の配置になっています。 このコードは、正しい。

```C
// CORRECT: use %I64d for 64-bit integers
printf("%I64d\n", 1LL);
```

### <a name="argument-evaluation-order"></a>引数の評価順序

X86 および x64、ARM プロセッサが異なるため、コンパイラの実装、およびも最適化のための別の営業案件に要件が異なる提示することができます。 呼び出し規約と最適化の設定と同様に、その他の要因と共にはこのため、コンパイラが異なるアーキテクチャまたはその他の要因が変更されたときに異なる順序で関数の引数を評価する可能性があります。 これにより、予期せずに変更する特定の評価順序に依存しているアプリの動作が発生することができます。

この種のエラーは、関数の引数が、同じ呼び出しで関数の他の引数に影響を与える副作用がある場合に発生することができます。 この依存関係の種類は簡単に避けるには、通常けれども、そのことがあります隠されることを識別するが困難である依存関係または演算子のオーバー ロードによって このコード例について考えます。

```cpp
handle memory_handle;

memory_handle->acquire(*p);
```

これは見えますが適切に定義された場合に、`->`と`*`がオーバー ロードされた演算子は、このコードは、次のようなものに変換されます。

```cpp
Handle::acquire(operator->(memory_handle), operator*(p));
```

間の依存関係がある場合と`operator->(memory_handle)`と`operator*(p)`、一定の評価順序に基づいて、コード、可能な依存関係はありません、元のコードのように見えます。

### <a name="volatile-keyword-default-behavior"></a>volatile キーワードの既定の動作

MSVC コンパイラの 2 つの異なる意味をサポートしている、`volatile`記憶域の修飾子をコンパイラ スイッチを使用して指定することができます。 [/Volatile:ms](../build/reference/volatile-volatile-keyword-interpretation.md)スイッチは、Microsoft がそれらのアーキテクチャで強力なメモリ モデルにより、x86 と x64 用の従来のケースが済みとして、強力な順序は保証揮発性のセマンティクスを拡張を選択します。 [/Volatile:iso](../build/reference/volatile-volatile-keyword-interpretation.md)スイッチは、厳密な C++ 標準揮発性セマンティクスを厳密な順序を保証しないものを選択します。

既定では、ARM アーキテクチャ **/volatile:iso**メモリ モデルを順序付け ARM プロセッサがある十分ではないため、および ARM のソフトウェアは、従来の拡張のセマンティクスに依存するがあるないため **/volatile:ms**および持っていない通常はソフトウェアとやり取りします。 ただし、場合もあります不便または拡張のセマンティクスを使用する、ARM プログラムをコンパイルする必須です。 たとえば、ISO C のセマンティクスを使用するプログラムに移植するコストが高くなる可能性があるまたはドライバー ソフトウェアが正常に機能する従来のセマンティクスに準拠する必要があります。 このような場合は、使用することができます、 **/volatile:ms**スイッチですただし、ARM を対象の従来の揮発性のセマンティクスを再作成には、コンパイラ挿入必要がありますごとの読み取りまたは書き込みの周囲のメモリ バリア、`volatile`変数を適用するには。強力な順序では、パフォーマンスにマイナスの影響であることができます。

既定では、x86 および x64 のアーキテクチャで **/volatile:ms** MSVC を使用して、それらのアーキテクチャを既に作成されているソフトウェアのほとんどが依存しているためです。 X86 と x64 のプログラムをコンパイルするときに指定できます、 **/volatile:iso**スイッチの不要な従来の揮発性のセマンティクスに依存していることを回避して、移植性を昇格します。

## <a name="see-also"></a>関連項目

[ARM プロセッサ用の Visual C ++ の構成する](../build/configuring-programs-for-arm-processors-visual-cpp.md)  
