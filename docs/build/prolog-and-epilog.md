---
title: "プロローグとエピローグ |Microsoft ドキュメント"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-tools
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- C++
ms.assetid: 0453ed1a-3ff1-4bee-9cc2-d6d3d6384984
caps.latest.revision: 
author: corob-msft
ms.author: corob
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: 700b467065d17a61dcfabf9dcaa6577a7ecffc11
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/21/2017
---
# <a name="prolog-and-epilog"></a>プロローグとエピローグ
すべての関数にスタック領域の割り当て、不揮発性レジスタの保存、または、例外処理を使用して他の関数の呼び出しはそれぞれの関数のテーブルのエントリに関連付けられたアンワインド データ アドレス制限が説明されているプロローグを設定する必要があります (を参照してください[例外処理 (x64)](../build/exception-handling-x64.md))。 プロローグは、レジスタ、自宅の住所に必要な場合、スタックにプッシュ不揮発性レジスタ引数を保存し、ローカル変数の一時要素のスタックの固定部分を割り当てるし、フレーム ポインターを必要に応じて確立します。 関連付けられたアンワインド データ プロローグのアクションを記述する必要があり、プロローグ コードの効果を元に戻すために必要な情報を提供する必要があります。  
  
 スタック内の固定割り当てが 1 つ以上のページ (つまり、4096 バイトより大きい)、スタックの割り当てが 1 つ以上の仮想メモリのページにわたる可能性し、そのため、実際に割り当てられる前に、割り当てをチェックする必要がある可能性がします。 プロローグ内から呼び出すことであるし、引数のレジスタを破壊しない特殊なルーチンは、この目的で提供されます。  
  
 不揮発性レジスタの保存に適した方法では、固定のスタック割り当てする前にスタックに移動します。 固定のスタック割り当ては、不揮発性レジスタの保存された前に、ほとんどの場合、32 ビットの変位アドレスに必要な実行された場合、保存されているを登録およびの領域 (報告されているレジスタのプッシュは移動するときだけ高速ほどのままにする必要があります。近い将来プッシュ間の暗黙的な依存関係を行っても)。 任意の順序では、不揮発性レジスタを保存することができます。 ただし、不揮発性レジスタ プロローグ内の最初の使用は、保存する必要があります。  
  
 典型的なプロローグ コードは次のようになります。  
  
```  
mov       [RSP + 8], RCX  
push   R15  
push   R14  
push   R13  
sub      RSP, fixed-allocation-size  
lea      R13, 128[RSP]  
...  
```  
  
 このプロローグのホームの場所に引数のレジスタ RCX を格納する、保存不揮発性 R13 R15 をレジスタ、スタック フレームの固定部分を割り当てます固定割り当て領域に 128 バイトを指すフレーム ポインターを確立します。 オフセットを使用すると、複数の固定割り当て領域の 1 バイト オフセットでアドレス指定することできます。  
  
 固定割り当てのサイズがメモリのページを 1 つ以上の場合は、RSP を変更する前に、ヘルパー関数を呼び出す必要があります。 このヘルパーに渡し、_chkstk は、スタックが適切に拡張することを確認する、スタックの割り当てしたい範囲をプローブします。 その場合は、プロローグの前の例はようになります。  
  
```  
mov       [RSP + 8], RCX  
push   R15  
push   R14  
push   R13  
mov      RAX,  fixed-allocation-size  
call   __chkstk  
sub      RSP, RAX  
lea      R13, 128[RSP]  
...  
```  
  
 _Chkstk ヘルパーでは、任意のレジスタ R10、R11、および条件コード以外は変更されません。 具体的には、そのまま RAX を返す、すべての不揮発性レジスタと引数を渡すレジスタが未変更のままにされます。  
  
 エピローグ コードは、関数には、各終了に存在します。 1 つだけプロローグ通常は、一方は、多くのエピローグがあります。 エピローグ コードは、(必要な場合)、スタックの固定割り当てサイズを小さくするとき、固定のスタック割り当ての割り当てを解除して、保存されている値、スタックからポップすることで不揮発性レジスタを復元したうえを返します。  
  
 エピローグ コードは、厳密なアンワインド コードのルール セットを確実にアンワインド例外および割り込みに従う必要があります。 これは、量が減り、各エピローグを記述する追加のデータは必要ありませんので、必要なデータをアンワインドします。 代わりに、アンワインド コードは、エピローグを識別するコード ストリームを前方向にスキャンして、エピローグが実行されていることを確認できます。  
  
 関数エピローグ必要があります最初の割り当てを解除、スタックの固定部分でフレーム ポインターを使用しない場合、不揮発性レジスタがポップされ、および制御が呼び出し元の関数に返されます。 たとえば、オブジェクトに適用された  
  
```  
add      RSP, fixed-allocation-size  
pop      R13  
pop      R14  
pop      R15  
ret  
```  
  
 フレーム ポインターが関数で使用されている場合は、エピローグの実行前に固定の割り当てにスタックをトリムする必要があります。 これは、技術的には含まれない、エピローグのです。 たとえば、以前使用したプロローグを元に戻す次のエピローグを使用できます。  
  
```  
lea      RSP, -128[R13]  
; epilogue proper starts here  
add      RSP, fixed-allocation-size  
pop      R13  
pop      R14  
pop      R15  
ret  
```  
  
 実際には、フレーム ポインターを使用する場合は次のエピローグが代わりに使用されるように、2 つの手順で RSP を調整する理由。  
  
```  
lea      RSP, fixed-allocation-size - 128[R13]  
pop      R13  
pop      R14  
pop      R15  
ret  
```  
  
 これらは、エピローグとしてのみ有効な形式です。 いずれかで構成されている必要があります、`add RSP,constant`または`lea RSP,constant[FPReg]`一連の 0 個以上の 8 バイト レジスタ ポップし、戻り値または、jmp 順です。 (エピローグで許容されるは、jmp ステートメントのサブセットのみです。 これらは ModRM メモリ参照の jmp のクラスの排他的 ModRM mod フィールドが 00 を値です。 Jmp ModRM mod フィールド値 01 または 10 エピローグでの使用が禁止されています。 AMD x86 アーキテクチャ プログラマの手動ボリューム 3 での表の「A-15: 一般的な用途とシステム手順については、許容される ModRM 参照についての詳細です。)。 その他のコードは表示できません。 具体的には、戻り値の読み込みを含め、エピローグ内でスケジュールすることです。  
  
 、フレーム ポインターを使用しない場合、エピローグを使用することに注意してください`add RSP,constant`スタックの固定部分の割り当てを解除します。 これが使用されない`lea RSP,constant[RSP]`代わりにします。 この制限は、アンワインド コードは、エピローグを検索するときに認識されるパターンを持つように存在します。  
  
 これらの規則により、アンワインド コードをエピローグが現在実行されていることを確認し、呼び出し元の関数のコンテキストを再作成を許可するエピローグの残りの部分の実行をシミュレートします。  
  
## <a name="see-also"></a>参照  
 [x64 ソフトウェア規約](../build/x64-software-conventions.md)