---
title: プロローグとエピローグ |Microsoft Docs
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-tools
ms.topic: conceptual
dev_langs:
- C++
ms.assetid: 0453ed1a-3ff1-4bee-9cc2-d6d3d6384984
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 9c2a1a9b1891af1c5616e78932cf4a530a300786
ms.sourcegitcommit: 92f2fff4ce77387b57a4546de1bd4bd464fb51b6
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/17/2018
ms.locfileid: "45718875"
---
# <a name="prolog-and-epilog"></a>プロローグとエピローグ

スタック領域の割り当てをすべての関数呼び出し他の関数、不揮発性レジスタの保存または例外処理を使用のプロローグ アンワインド データが各関数のテーブル エントリに関連付けられているアドレスの制限が説明されている必要があります (を参照してください[。例外処理 (x64)](../build/exception-handling-x64.md))。 プロローグは、レジスタ、自宅の住所で必要な場合、スタックにプッシュ不揮発性レジスタ引数を保存します、ローカル変数と一時要素は、スタックの固定部分が割り当てられ、必要に応じてフレーム ポインターを確立します。 関連付けられているデータのアンワインド、プロローグのアクションを記述する必要があり、プロローグ コードの効果を元に戻すために必要な情報を提供する必要があります。

スタック内の固定割り当てが 1 つ以上のページ (つまり、4096 バイトより大きい)、スタック割り当てが 1 つ以上の仮想メモリ ページにわたることがあり、そのため、実際に割り当てられる前に、割り当てをチェックする必要がある可能性があります。 この目的は、プロローグから呼び出すことと、引数のレジスタを破壊しない特殊なルーチンを提供しています。

不揮発性レジスタを保存するための推奨される方法では、固定のスタック割り当てする前にスタックに移動します。 保存されている登録 (報告されているレジスタのプッシュは移動するときだけ高速およびのようにしておく領域固定のスタック割り当ては、その 32 ビットの変位をアドレスするために必要になります可能性が最も高い不揮発性レジスタが保存された、前に実行された場合暗黙的な依存関係のあるにもかかわらず、近い将来間にプッシュ) します。 任意の順序では、不揮発性レジスタを保存できます。 ただし、不揮発性レジスタ プロローグ内の最初の使用は、保存する必要があります。

典型的なプロローグ コードは次のようになります。

```
mov       [RSP + 8], RCX
push   R15
push   R14
push   R13
sub      RSP, fixed-allocation-size
lea      R13, 128[RSP]
...
```

このプロローグのホーム場所引数 RCX レジスタに格納、保存の不揮発性 R13 R15 を登録、スタック フレームの固定部分を割り当てます 128 バイトを指すの固定割り当て領域にフレーム ポインターを確立します。 オフセットを使用すると、複数の固定割り当て領域の 1 バイトのオフセットで対処できます。

固定の割り当てのサイズがメモリのページを 1 つ以上の場合は、RSP を変更する前に、ヘルパー関数を呼び出す必要があります。 このヘルパーは _chkstk は、スタックが適切に拡張されたことを確認します。 スタックの割り当てされる範囲をプローブします。 その場合は、プロローグの前の例はようになります。

```
mov       [RSP + 8], RCX
push   R15
push   R14
push   R13
mov      RAX,  fixed-allocation-size
call   __chkstk
sub      RSP, RAX
lea      R13, 128[RSP]
...
```

_Chkstk ヘルパーでは、任意のレジスタ R10、R11、および条件コード以外は変更されません。 具体的には、そのまま RAX を返すされすべての不揮発性レジスタと引数を渡すレジスタが未変更の状態のままにします。

エピローグ コードは、各終了関数に存在します。 一方、通常 1 つだけプロローグは、多くのエピローグがあります。 エピローグ コードは、(必要な) 場合、スタックの固定割り当てのサイズをトリム、固定のスタック割り当ての割り当てを解除して、保存されている値をスタックからポップすることで不揮発性レジスタを復元したうえを返します。

エピローグ コードは、例外および割り込みが確実にアンワインドする厳密な一連のアンワインド コードの規則に従う必要があります。 これは、量が減り、各エピローグを記述する追加のデータは必要ありませんので、必要なデータをアンワインドします。 代わりに、アンワインド コードは、エピローグを識別するコード ストリームを前方向にスキャンして、エピローグが実行されていることを確認できます。

関数エピローグする必要があります最初の割り当てを解除、スタックの固定部分でフレーム ポインターを使用しない場合、不揮発性レジスタをポップ、および呼び出し元の関数に制御が返されます。 たとえば、オブジェクトに適用された

```
add      RSP, fixed-allocation-size
pop      R13
pop      R14
pop      R15
ret
```

フレーム ポインターを関数で使用する場合は、エピローグの実行前に、固定の割り当てにスタックをトリムする必要があります。 これは、技術的には含まれていない、エピローグです。 たとえば、次のエピローグを使用して、以前使用したプロローグを取り消します。

```
lea      RSP, -128[R13]
; epilogue proper starts here
add      RSP, fixed-allocation-size
pop      R13
pop      R14
pop      R15
ret
```

実際には、フレーム ポインターを使用する場合は次のエピローグが代わりに使用されるため、2 つの手順で RSP を調整する理由。

```
lea      RSP, fixed-allocation-size - 128[R13]
pop      R13
pop      R14
pop      R15
ret
```

これらは、エピローグとしてのみ有効な形式です。 いずれかで構成されている必要があります、`add RSP,constant`または`lea RSP,constant[FPReg]`一連の 0 個以上の 8 バイト レジスタ pop と戻り値または jmp、その後にします。 (エピローグで許容されるは、jmp ステートメントのサブセットのみです。 これらは、jmp ModRM メモリ参照のクラスの排他的 ModRM mod フィールドが 00 を値します。 ModRM mod フィールド値が 01 または 10 でエピローグで jmp の使用が禁止されています。 AMD の x86 64 アーキテクチャ プログラマの手動ボリューム 3 でのテーブルを参照してください A-15: 汎用および許容 ModRM 参照の詳細については、システムの手順です。)。 その他のコードを表示できません。 具体的には、戻り値の読み込みを含め、エピローグ内で何もスケジュールできます。

、フレーム ポインターを使用しない場合、エピローグを使用することに注意してください。`add RSP,constant`スタックの固定部分の割り当てを解除します。 使用されて`lea RSP,constant[RSP]`代わりにします。 この制限には、アンワインド コードはエピローグを検索するときに認識されるパターンが存在します。

これらの規則では、エピローグが現在実行されていることを確認して、呼び出し元関数のコンテキストを再作成を許可するエピローグの残りの部分の実行をシミュレートするためにアンワインド コード。

## <a name="see-also"></a>関連項目

[x64 ソフトウェア規約](../build/x64-software-conventions.md)