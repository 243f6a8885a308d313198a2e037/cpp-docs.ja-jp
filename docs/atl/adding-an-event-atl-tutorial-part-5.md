---
title: "イベントの追加 (ATL チュートリアル、パート 5) | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "get-started-article"
dev_langs: 
  - "C++"
ms.assetid: 2de12022-3148-4ce3-8606-8a9d4274f0e9
caps.latest.revision: 13
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
caps.handback.revision: 8
---
# イベントの追加 (ATL チュートリアル、パート 5)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

この手順では、ATL コントロールに `ClickIn` と `ClickOut` のイベントを追加します。  ユーザーが外側をクリックするとユーザーが多角形と発生 `ClickOut` 内でクリックすると `ClickIn` のイベントを発生させます。  イベントの追加タスクは次のとおりです。:  
  
-   `ClickIn` と `ClickOut` メソッドの追加  
  
-   タイプ ライブラリの生成  
  
-   コネクション ポイント インターフェイスの実装  
  
## ClickIn と ClickOut メソッドの追加  
 手順 2 の ATL コントロールの作成時に、**\[接続ポイント\]** のチェック ボックスを選択します。  これは Polygon.idl ファイルの `_IPolyCtlEvents` のインターフェイスを作成しました。  ようにアンダースコアがインターフェイスの名前の先頭に注意してください。  これは、インターフェイスが内部インターフェイスであることを示す規則です。  ユーザー インターフェイスを表示せずには、COM オブジェクトを検索できるプログラムを選択できます。  また **\[接続ポイント\]** を選択する場合に `_IPolyCtlEvents` が既定のソース インターフェイスであることを示すために追加 Polygon.idl ファイルに次の行を表示する:  
  
 `[default, source] dispinterface _IPolyCtlEvents;`  
  
 ソースの属性は、コントロールが通知ソースであるため、コンテナーは、このインターフェイスことを示します。  
  
 これで `ClickIn` を追加 `_IPolyCtlEvents` への `ClickOut` のメソッドは、インターフェイスです。  
  
#### ClickIn と ClickOut のメソッドを追加するには  
  
1.  クラス ビューで、\_IPolyCtlEvents を表示するには、多角形、および PolygonLib を展開します。  
  
2.  \_IPolyCtlEvents を右クリックします。  ショートカット メニューのをクリック **追加**は、を **\[メソッドの追加\]**をクリックします。  
  
3.  `void`の **\[戻り値の型\]** を選択します。  
  
4.  **\[メソッド名\]** ボックスに `ClickIn` を入力します。  
  
5.  **\[パラメーターの属性\]**の下に、**\[in\]** ボックスをオンにします。  
  
6.  `LONG`の **\[パラメーターの型\]** を選択します。  
  
7.  `X` を **\[パラメーター名\]**として **追加**入力し、をクリックします。  
  
8.  手順 5 ~ 7、`y`.の **\[パラメーター名\]** の今度は\) を繰り返します。  
  
9. **\[次へ\]** をクリックします。  
  
10. **helpstring**として型 `method ClickIn`。  
  
11. をクリック **\[完了\]**。  
  
12. `LONG` のパラメーターと同じ `x``y`、同じ **\[パラメーターの属性\]** の `ClickOut` のメソッドと同じ `void` の戻り値の型定義するには、上で説明した手順を繰り返します。  
  
 コードが `_IPolyCtlEvents` ディスパッチ インターフェイスに追加されたことを Polygon.idl ファイルを確認します。  
  
 自分の Polygon.idl ファイルの `_IPolyCtlEvents` のディスパッチ インターフェイスはこのように、:なります。  
  
 [!code-cpp[NVC_ATL_Windowing#56](../atl/codesnippet/CPP/adding-an-event-atl-tutorial-part-5_1.idl)]  
  
 `ClickIn` と `ClickOut` のメソッドは、パラメーターとしてクリックした位置の x 座標と y 座標を受け取ります。  
  
## タイプ ライブラリの生成  
 コントロール用のコネクション ポイント インターフェイス、コネクション ポイント コンテナーのインターフェイスを作成する必要がある情報を取得するには、コネクション ポイント ウィザードが使用するため、この時点でタイプ ライブラリを生成します。  
  
#### タイプ ライブラリを生成します。  
  
1.  プロジェクトをリビルドします。  
  
     または  
  
2.  ソリューション エクスプローラーで Polygon.idl ファイルを右クリックし、ショートカット メニューの **\[コンパイル\]** をクリックします。  
  
 これにより、タイプ ライブラリである Polygon.tlb ファイルを作成します。  Polygon.tlb のファイルがバイナリ ファイルに直接表示または編集できないため、ソリューション エクスプローラーからは参照できません。  
  
## コネクション ポイント インターフェイスの実装  
 コントロール用のコネクション ポイント インターフェイス、コネクション ポイント コンテナーのインターフェイスを実装します。  COM では、イベントはコネクション ポイント機構を使用します。  COM オブジェクトからのイベントを受け取るには、コンテナーは、コネクション ポイントへのアドバイザリ コネクションを COM オブジェクトがを実装する確立します。  COM オブジェクトは、複数のコネクション ポイントを持つことができるため、COM オブジェクトに、コネクション ポイント コンテナーのインターフェイスを実装します。  このインターフェイスから、コンテナーは、コネクション ポイントがサポートされているかを判断できます。  
  
 コネクション ポイントを実装するインターフェイスは `IConnectionPoint`、コネクション ポイント コンテナーを実装するインターフェイスと呼びます `IConnectionPointContainer`と呼ばれます。  
  
 `IConnectionPoint`を実装するために、接続ポイントの実装ウィザードを使用します。  このウィザードでは、のタイプ ライブラリを読み込み、起動できる各イベントの関数を実行して `IConnectionPoint` のインターフェイスを生成します。  
  
#### 接続ポイントの実装ウィザードを使用するには  
  
1.  クラス ビューで、コントロールの実装クラス `CPolyCtl`を右クリックします。  
  
2.  ショートカット メニューのをクリック **追加**は、を **\[接続ポイントの追加\]**をクリックします。  
  
3.  **\[ソース インターフェイス\]** の一覧から `_IPolyCtlEvents` を選択し、**\[接続ポイントの実装\]** の列に列を追加するには、をダブルクリックします。  をクリック **\[完了\]**。  コネクション ポイントのプロキシ クラスは、この場合、`CProxy_IPolyCtlEvents`生成されます。  
  
 ソリューション エクスプローラーで生成された\_IPolyCtlEvents\_CP.h のファイルを見ると、`CProxy_IPolyCtlEvents` という `IConnectionPointImpl`から派生するクラスがあることが示されます。  \_IPolyCtlEvents\_CP.h は、2 種類の座標のパラメーターを受け取る 2 とおりの方法 `Fire_ClickIn` と `Fire_ClickOut`を定義します。  作成したコントロールからのイベントを発生させますするときにこれらのメソッドを呼び出します。  
  
 ウィザードは、コントロールの多重継承の一覧に `CProxy_PolyEvents` と `IConnectionPointContainerImpl` を追加。  ウィザードは、COM マップに該当するエントリを追加して、の `IConnectionPointContainer` を発行します。  
  
 終了します。イベントをサポートするコードを実装します。  次に、必要なときにイベントを発生させるコードを追加します。  ユーザーがコントロールのマウスの左ボタンをクリックすると、`ClickIn` または `ClickOut` のイベントを発生させる実行する注意してください。  ユーザーがボタンをクリックすると確認するには、`WM_LBUTTONDOWN` のメッセージのハンドラーを追加します。  
  
#### WM\_LBUTTONDOWN のメッセージのハンドラーを追加します。  
  
1.  クラス ビューで、CPolyCtl のクラスを右クリックし、ショートカット メニューの **プロパティ** をクリックします。  
  
2.  **プロパティ** のペインで、**\[メッセージ\]** のアイコンをクリックし、左の一覧から `WM_LBUTTONDOWN` をクリックします。  
  
3.  ドロップダウン リストのをクリック **\<Add\> \[ OnLButtonDown\]**。  `OnLButtonDown` のハンドラーの宣言は、PolyCtl.h に追加され、ハンドラーの実装は PolyCtl.cpp に追加されます。  
  
 次に、ハンドラーを変更します。  
  
#### OnLButtonDown のメソッドを変更するには  
  
1.  次のように PolyCtl.cpp の `OnLButtonDown` のメソッドを構成するコードを変更します \(ウィザードで設定するコードを削除する\) :  
  
     [!code-cpp[NVC_ATL_Windowing#57](../atl/codesnippet/CPP/adding-an-event-atl-tutorial-part-5_2.cpp)]  
  
 このコードは `PtInRegion`を呼び出して、ユーザーのマウス クリックが検出される領域を作成するに `OnDraw` 関数で計算されるポイントを使用します。  
  
 `uMsg` のパラメーターで、Windows メッセージの ID です。  これは、メッセージの範囲を処理する 1 とおりの関数を持つことができます。  `wParam` と `lParam` のパラメーターで、メッセージの標準値です。  bHandled パラメーターは、関数からメッセージが処理されたかどうかを指定することができます。  既定では、値は `TRUE` に関数がメッセージを処理した、`FALSE`にコントロールを配置できることを示すようにに設定されます。  これにより、ATL はメッセージを送信する別のメッセージ ハンドラー関数を検索します。  
  
## コントロールのビルドとテスト  
 これはイベントをテストします。  コントロールをビルドして ActiveX コントロール テスト コンテナーを再起動します。  今度は、イベント ログ ウィンドウを表示します。  出力ウィンドウにイベントをルーティングするには、**オプション** のメニューの **\[ログ記録\]** をクリックし、**\[ログ出力\]ウィンドウ\]**を選択します。  ウィンドウでをクリックすると、コントロールを挿入します。  ツールボックスの外部をクリックすると塗りつぶされた多角形内でクリックした場合は、`ClickOut` が発生します `ClickIn` が発生することに注意してください。  
  
 次に、プロパティ ページを追加します。  
  
 [手順 4 に戻します](../atl/changing-the-drawing-code-atl-tutorial-part-4.md) &#124; [手順 6 ~](../Topic/Adding%20a%20Property%20Page%20\(ATL%20Tutorial,%20Part%206\).md)  
  
## 参照  
 [チュートリアル](../Topic/Active%20Template%20Library%20\(ATL\)%20Tutorial.md)