---
title: "ヒープ競合の回避 | Microsoft Docs"
ms.custom: ""
ms.date: "12/03/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "reference"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "ヒープ競合"
ms.assetid: 797129d7-5f8c-4b0e-8974-bb93217e9ab5
caps.latest.revision: 12
caps.handback.revision: 8
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# ヒープ競合の回避
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

MFC および ATL によって提供される既定の文字列マネージャーは、グローバル ヒープ上に簡単なラッパーです。  このグローバル ヒープは完全に複数のスレッドが、バッファーのヒープを破損しないようにしてメモリを解放できることを意味するスレッド セーフです。  スレッド セーフを提供するにはヒープは、それ自体へのアクセスをシリアル化する必要があります。  これは通常、クリティカル セクションまたは同様のロック機構により実行されます。  2 種類のスレッドがヒープを同時にアクセスするたびに 1 個のスレッドが他のスレッドの要求が完了するまでブロックします。  多くのアプリケーションでは、この状況はほとんどで発生し、ヒープのロック機構のパフォーマンスへの影響はほとんどありません。  ただし、頻繁にアクセスするアプリケーションの単一通ったら複数のヒープは、ヒープのロックの競合に遅延実行するアプリケーションを作成できます \(複数の CPU、スレッドのコンピューターで\)。  
  
 [CStringT](../atl-mfc-shared/reference/cstringt-class.md) を使用するアプリケーションは、`CStringT` のオブジェクトの操作が頻繁に文字列バッファーの再割り当てを要求するため、ヒープの競合に特に重要です。  
  
 スレッド間のヒープの競合を軽減する 1 とおりの方法は、プライベート、スレッド ローカル ヒープから文字列を各スレッドを代入することです。  特定のスレッドのアロケーターに割り当てられた文字列がそのスレッドでのみ使用される限り、アロケーターはスレッド セーフである必要はありません。  
  
## 使用例  
 次の例は、そのスレッドの文字列に使用するための独自のプライベート スレッド セーフでないヒープを割り当てるスレッドの手順の説明です:  
  
 [!code-cpp[NVC_ATLMFC_Utilities#182](../atl-mfc-shared/codesnippet/CPP/avoidance-of-heap-contention_1.cpp)]  
  
## コメント  
 複数のスレッドが同じスレッド プロシージャを使用して実行できますが、各スレッドには、独自のヒープがあるため、スレッド間に競合がありません。  また、各ヒープがスレッド セーフでないということは、スレッドの 1 種類のコピーが実行パフォーマンスの測定可能な増加を示します。  これは、同時アクセスに対して保護する高いインタロックされた操作を使用してヒープの結果ありません。  
  
 より複雑なスレッドのプロシージャには、スレッド ローカル ストレージの \(TLS\) のスロットにスレッドの文字列マネージャーへのポインターを格納した方が便利な場合があります。  これは、スレッドの文字列マネージャーを開くにスレッド プロシージャによって呼び出された他の関数を割り当てます。  
  
## 参照  
 [CStringT によるメモリ管理](../atl-mfc-shared/memory-management-with-cstringt.md)