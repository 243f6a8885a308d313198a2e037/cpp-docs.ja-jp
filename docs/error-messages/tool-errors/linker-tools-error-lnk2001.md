---
title: "リンカ ツール エラー LNK2001 |Microsoft ドキュメント"
ms.custom: 
ms.date: 05/17/2017
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-tools
ms.tgt_pltfrm: 
ms.topic: error-reference
f1_keywords:
- LNK2001
dev_langs:
- C++
helpviewer_keywords:
- LNK2001
ms.assetid: dc1cf267-c984-486c-abd2-fd07c799f7ef
caps.latest.revision: 
author: corob-msft
ms.author: corob
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: 51f78f436d0e19779d0ebca499a559a60d12bcf9
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/21/2017
---
# <a name="linker-tools-error-lnk2001"></a>リンカ ツール エラー LNK2001
未解決の外部シンボル"*シンボル*"  
  
参照またはへの呼び出しは、コンパイルされたコードは*シンボル*が、そのシンボルがリンカーに指定されたオブジェクト ファイル、ライブラリのいずれかで定義されていません。  
  
このエラー メッセージの致命的なエラーが続く[LNK1120](../../error-messages/tool-errors/linker-tools-error-lnk1120.md)です。 エラー LNK1120 を修正するすべての LNK2001 および LNK2019 エラーを修正する必要があります。  
  
## <a name="possible-causes"></a>考えられる原因  
  
このエラーが発生するさまざまな方法がありますが、関数またはリンカーできません変数への参照を含むすべての*解決*定義を見つけられないか。 コンパイラがシンボルがない場合に特定できます*宣言*がない場合ではありません*定義*定義が別のソース ファイルまたはライブラリ内であるので、します。 シンボルが参照されるが、定義されていることはありません、リンカーでエラーが発生します。  
  
### <a name="coding-issues"></a>コードの問題  
  
ソース コードまたはモジュール定義 (.def) が一致しない場合、このエラーは発生するファイル。 たとえば、変数の名前を付ける場合`var1`で 1 つの C++ ソース ファイルととしてアクセスを試みる`VAR1`このエラーを生成する、別のです。 この問題を解決するには、使用は一貫したスペルし、名前、大文字と小文字です。  
  
このエラーは、使用するプロジェクトで発生することができます[関数のインライン展開](../../error-messages/tool-errors/function-inlining-problems.md)ヘッダー ファイルではなく、ソース ファイルで関数を定義する場合。 それを定義するソース ファイルの外部関数のインライン展開を表示できません。 この問題を解決するには、宣言されているヘッダーの関数のインライン展開を定義します。  
  
使用せず、C++ プログラムから C の関数を呼び出す場合は、このエラーを発生することができます、 `extern "C"` C 関数の宣言。 コンパイラが C および C++ コードでは、さまざまな内部シンボルの名前付け規則を使用し、リンカー検索シンボルを解決するときに内部シンボルの名前です。 この問題を解決するには、`extern "C"`コンパイラが、これらのシンボルを C 内部名前付け規則を使用する C++ コードで使用する C 関数のすべての宣言をラップするラッパー。 コンパイラ オプション[/Tp](../../build/reference/tc-tp-tc-tp-specify-source-file-type.md)と[/Tc](../../build/reference/tc-tp-tc-tp-specify-source-file-type.md)ファイルとしてコンパイル C++ または C が、それぞれ、ファイル名拡張子に関係なくコンパイラが発生します。 これらのオプションには、内部の関数名が予期したものと異なる可能性があります。  
  
このエラーは、関数または外部リンケージを持たないデータを参照しようとして発生することができます。 C++ では、インライン関数と`const`として明示的に指定されていない限り、データが内部リンケージを持ちます`extern`です。 この問題を解決するには明示的な使用`extern`シンボルの宣言が定義するソース ファイルの外部に呼ばれます。  
  
このエラーは、によって発生することができます、[関数本体または変数がありません](../../error-messages/tool-errors/missing-function-body-or-variable.md)定義します。 このエラーは、宣言、定義していない、変数、関数、またはクラス コードにする場合に共通です。 コンパイラでは、関数プロトタイプのみが必要か`extern`関数のコードまたは変数の領域がないために、エラーは、リンカーないオブジェクト ファイルを生成する変数の宣言が関数への呼び出しや、変数への参照を解決できません予約されています。 この問題を解決するには、すべての参照先の関数と変数完全に定義されているソース ファイルまたは link に含まれているライブラリを確認します。  
  
このエラーは、戻り値およびパラメーター型またはと一致しない場合、関数定義で呼び出し規約を使用する関数呼び出しによって発生することができます。 オブジェクトの C++ ファイルで[装飾の名前を付けます](../../error-messages/tool-errors/name-decoration.md)を必要とする場合に一致するようにシンボルが使用する最終の装飾関数名に、呼び出し規約、クラスまたは名前空間のスコープ、および関数の戻り値およびパラメーターの型が組み込まれていますその他のオブジェクト ファイルからの関数に解決されます。 この問題を解決するには、同じスコープ、型、および呼び出し規約の宣言、定義、およびすべての関数への呼び出しを使用することを確認します。  
  
このエラーはクラス定義の関数プロトタイプが含まれますに失敗するときに、C++ コードで発生することができます[実装が含まれて](../../error-messages/tool-errors/missing-function-body-or-variable.md)関数のし、それを呼び出します。 この問題を解決するには、クラスのメンバーの宣言と呼ばれるすべての定義を指定することを確認します。  
  
このエラーは、抽象基本クラスからの純粋仮想関数を呼び出そうとすると、発生することができます。 純粋仮想関数には、基本クラス実装がありません。 この問題を解決するには、仮想関数を呼び出すすべて実装されていることを確認します。  
  
このエラーは、関数内で宣言された変数を使用しようとして発生することができます ([ローカル変数](../../error-messages/tool-errors/automatic-function-scope-variables.md)) その関数のスコープ外です。 この問題を解決するには、スコープに含まれていない変数への参照を削除する変数を上位のスコープに移動したりできます。  
  
ATL プロジェクトのリリース バージョンをビルドすると、CRT スタートアップ コードが必要であるメッセージを生成したときに、このエラーが発生することができます。 この問題を修正するには、次のいずれかの操作  
  
-   削除`_ATL_MIN_CRT`CRT スタートアップ コードが含まれるようにプリプロセッサの一覧からを定義します。 参照してください[[全般] プロパティ ページ (プロジェクト)](../../ide/general-property-page-project.md)詳細についてはします。  
  
-   可能であれば、CRT スタートアップ コードを必要とする CRT 関数の呼び出しを削除します。 代わりに、対応する win32 関数を使用します。 たとえば、使用して`lstrcmp`の代わりに`strcmp`です。 CRT スタートアップ コードを必要とする既知の関数は、文字列および浮動小数点関数の一部を示します。  
  
### <a name="compilation-and-link-issues"></a>コンパイルとリンクの問題  
  
このエラーは、プロジェクトのライブラリへの参照がない場合に発生することができます (です。LIB) またはオブジェクト (です。OBJ) ファイルです。 この問題を解決するには、プロジェクトに必要なライブラリまたはオブジェクト ファイルへの参照を追加します。 詳細については、次を参照してください。[リンカー入力としての .lib ファイル](../../build/reference/dot-lib-files-as-linker-input.md)です。  
  
このエラーは、使用する場合に発生することができます、 [/NODEFAULTLIB](../../build/reference/nodefaultlib-ignore-libraries.md)または[/Zl](../../build/reference/zl-omit-default-library-name.md)オプション。 これらのオプションを指定するときに 明示的に含めていた場合を除き、プロジェクトに必要なコードが含まれているライブラリはリンクされません。 この問題を解決するには、リンクのコマンドラインで使用するすべてのライブラリを明示的に指定します。 これらのオプションを使用する場合、多くの不足している CRT または標準ライブラリ関数名が表示された場合、リンクに、CRT、標準のライブラリ Dll ファイルまたはライブラリ ファイルを明示的に含めます。  

使用してコンパイルする場合、 **/clr**オプションで、.cctor に未解決の参照があります。 この問題を修正するのを参照してください。[混在アセンブリの初期化](../../dotnet/initialization-of-mixed-assemblies.md)詳細についてはします。  
  
このエラーは、アプリケーションのデバッグ バージョンを作成するときに、リリース モード ライブラリにリンクする場合に発生することができます。 同様に、オプションを使用する場合**/MTd**または**/MDd**定義または`_DEBUG`リリース ライブラリにリンクして、その他の問題の多く可能性がある未解決の外部参照には、表示されるはずです。 ような問題が発生もリリース モードのデバッグ ライブラリと一緒にビルドをリンクします。 この問題を解決するには、デバッグ ビルドでデバッグ ライブラリを使用して、小売り業で小売りライブラリのビルドを確認します。  
  
このエラーは、ライブラリの 1 つのバージョンからシンボルをコードから参照が、リンカーのライブラリの別のバージョンを指定する場合に発生します。 一般に、オブジェクト ファイルまたは別のバージョンのコンパイラに組み込まれているライブラリを混在させることはできません。 新しいバージョンに含まれているライブラリには、以前のバージョン、およびその逆に含まれているライブラリで見つからないシンボルが格納されて可能性があります。 この問題を解決するには、それらを一緒にリンクする前にすべてのオブジェクト ファイルと同じバージョンのコンパイラとライブラリを構築します。  
  
-  ツールは、&#124;です。オプション &#124;です。プロジェクト &#124;です。Vc++ ディレクトリ ダイアログの ライブラリ ファイルの選択 では、ライブラリの検索順序を変更することができます。 プロジェクトのプロパティ ページ ダイアログ ボックスで リンカー フォルダーでは、期限切れの可能性があるパスもあります。  
  
-  この問題が表示されます (おそらく別の場所に)、新しい SDK がインストールされているし、新しい場所を指す検索順序は更新されません。 通常、新しい SDK にパスを配置する必要がありますを含めるおよび lib の既定の Visual C の場所の前にディレクトリ。 また、埋め込みパスを含むプロジェクトは、有効であっても別の場所にインストールされている、新しいバージョンで追加された新機能の期限切れである古いパスを指す場合があります。  
  
-   コマンドラインでビルドして、独自の環境変数を作成した場合は、ツール、ライブラリ、およびヘッダー ファイルへのパスが、一貫したバージョンに送られることを確認します。 詳細については、次を参照してください[コマンド ライン ビルドのパスと環境変数を設定。](../../build/setting-the-path-and-environment-variables-for-command-line-builds.md)
  
現在の標準はありません[C++ の名前付け](../../error-messages/tool-errors/name-decoration.md)コンパイラ販売元間またはコンパイラの異なるバージョン間でさえもします。 そのため、他のコンパイラでコンパイルされたオブジェクト ファイルをリンク可能性がありますいない、同じ名前付けスキームを生成およびエラー LNK2001 が発生するためです。  
  
[コンパイル オプションのミキシングのインラインと非インライン](../../error-messages/tool-errors/function-inlining-problems.md)モジュールごとに異なることができます LNK2001 が発生します。 C++ ライブラリがオンになっている関数のインライン展開で作成されたかどうか (**/Ob1**または**/Ob2**) がになっているインライン展開が、関数を記述する、対応するヘッダー ファイル (ありません`inline`キーワード)、このエラー発生します。 この問題を解決する関数を定義する`inline`ヘッダー ファイルを他のソース ファイルが含まれます。  
  
使用する場合、`#pragma inline_depth`コンパイラ ディレクティブを確認するが、 [2 以上のセットの値](../../error-messages/tool-errors/function-inlining-problems.md)、また使用するかどうかを確認し、 [/Ob1](../../build/reference/ob-inline-function-expansion.md)または[/Ob2](../../build/reference/ob-inline-function-expansion.md)コンパイラ オプション。  
  
このエラーは、リンクを省略した場合に発生する可能性が/NOENTRY をリソース専用 DLL を作成するときにオプションです。 この問題を解決するには、リンクのコマンドに/NOENTRY オプションを追加します。  
  
このエラーは、プロジェクトに正しくない/SUBSYSTEM または/ENTRY 設定を使用する場合に発生することができます。 たとえば、コンソール アプリケーションを書く/SUBSYSTEM:WINDOWS を指定すると、未解決の外部エラーが生成の`WinMain`します。 この問題を解決するには、プロジェクトの種類には、オプションの一致を確認します。 これらのオプションとエントリ ポイントの詳細については、次を参照してください。、 [/SUBSYSTEM](../../build/reference/subsystem-specify-subsystem.md)と[/ENTRY](../../build/reference/entry-entry-point-symbol.md)リンカー オプション。  
  
### <a name="exported-symbol-issues"></a>エクスポートされたシンボルの問題  
  
このエラーは、.def ファイルに一覧表示、エクスポートが見つからない場合に発生します。 存在しない、スペルが正しいか、C の装飾名を使用する可能性があります。 .Def ファイルには、装飾名は取りません。 この問題を修正するには、不要なエクスポートを取り出して使用`extern "C"`エクスポートされたシンボルを宣言します。  
  
## <a name="what-is-an-unresolved-external-symbol"></a>未解決の外部シンボルとは何ですか。  
  
A*シンボル*関数またはコンパイル済みのオブジェクト ファイルまたはライブラリによって内部的に使用するグローバル変数の名前を指定します。 シンボルは*定義*関数本体のコンパイル済みコードの配置場所のグローバル変数または関数の場合、記憶域が割り当てられているオブジェクト ファイルにします。 *外部シンボル*記号の*参照*、つまり、使用または 1 つのオブジェクト ファイルで呼び出されますが、別のライブラリまたはオブジェクト ファイルで定義されています。 *エクスポートされたシンボル*は、オブジェクト ファイルまたはそれを定義するライブラリによって公開されている使用可能です。 リンカーである必要があります*解決*、または、対応する定義、アプリケーションまたは DLL にリンクされている場合は、オブジェクト ファイルで参照されているすべての外部シンボルを検索します。 リンカーは、リンクされたファイルのいずれかに一致するエクスポートされたシンボルを見つけることによって、外部シンボルを解決できないときにエラーを生成します。    
  
## <a name="use-the-decorated-name-to-find-the-error"></a>装飾名を使用して、エラーを検出
  
C++ コンパイラとリンカーの使用[名前の装飾](../../error-messages/tool-errors/name-decoration.md)とも呼ばれる、*名前マングル*変数の型または戻り値の型、パラメーターの型、スコープ、および呼び出し元に関する追加情報をエンコードするにはシンボル名の関数の規則。 この装飾名は、外部シンボルを解決するのには、リンカーが検索シンボル名です。  
  
追加情報がシンボル名の一部となり、ために、関数または変数の宣言は関数または変数の定義と一致しない場合にリンク エラーが発生することができます。 これは、ソース ファイルをコンパイルするときに、別のコンパイラ フラグを使用する場合、同じヘッダー ファイルが呼び出し元のコードと定義のコードの両方で使用される場合でもに発生することができます。 たとえば、すれば、このエラーを使用するコードがコンパイルされている場合、`__vectorcall`呼び出し規約、ですが、既定値を使用してそれを呼び出すクライアントが必要ですが、ライブラリにリンク`__cdecl`または`__fastcall`呼び出し規約です。 この場合、シンボルが違って、呼び出し規約が異なるため   
  
この種のエラーの原因を確認するために、リンカーのエラー メッセージが両方"フレンドリ名が表示、"ソース コード、および未解決の外部シンボルの装飾名 (かっこ内) で使用される名前です。 その他の装飾名と比較することができる、装飾名を変換する方法を理解する必要はありません。 期待される記号名と実際のシンボル名の比較にコンパイラに含まれているコマンド ライン ツールを使用することができます。  

-   [/Exports](../../build/reference/dash-exports.md)と[/symbols](../../build/reference/symbols.md) DUMPBIN コマンド ライン ツールのオプションを使用して、どのシンボルが、.dll やオブジェクト ファイルまたはライブラリ ファイルで定義されているを発見できます。 エクスポートされた装飾する装飾名、リンカー検索の名前が一致することを確認するのにには、これを使用できます。  
  
場合によっては、リンカーは、シンボルの装飾名のみをレポートできます。 UNDNAME コマンド ライン ツールを使用すると、装飾名の非装飾形式を取得します。  
  
## <a name="additional-resources"></a>その他の技術情報  
  
LNK2001 の考えられる原因および解決方法に関する詳細については、スタック オーバーフローの質問を参照してください。 [、未定義の参照/未解決外部シンボルというエラーと、その修正方法?](http://stackoverflow.com/q/12573816/2002113)です。  

